<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>InternalComponentManager.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Core XMPP Server</a> &gt; <a href="index.source.html" class="el_package">org.jivesoftware.openfire.component</a> &gt; <span class="el_source">InternalComponentManager.java</span></div><h1>InternalComponentManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2005-2008 Jive Software. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jivesoftware.openfire.component;

import org.dom4j.Element;
import org.jivesoftware.openfire.*;
import org.jivesoftware.openfire.cluster.ClusterEventListener;
import org.jivesoftware.openfire.cluster.ClusterManager;
import org.jivesoftware.openfire.cluster.NodeID;
import org.jivesoftware.openfire.container.BasicModule;
import org.jivesoftware.openfire.disco.IQDiscoItemsHandler;
import org.jivesoftware.openfire.session.ComponentSession;
import org.jivesoftware.util.JiveGlobals;
import org.jivesoftware.util.cache.Cache;
import org.jivesoftware.util.cache.CacheFactory;
import org.jivesoftware.util.cache.CacheUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xmpp.component.*;
import org.xmpp.packet.IQ;
import org.xmpp.packet.JID;
import org.xmpp.packet.Packet;
import org.xmpp.packet.Presence;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * Manages the registration and delegation of Components, which includes External Components as well as components
 * that run in the Openfire JVM.
 *
 * The ComponentManager is responsible for managing registration and delegation of {@link Component Components},
 * as well as offering a facade around basic server functionality such as sending and receiving of packets.
 *
 * This component manager will be an internal service whose JID will be component.[domain]. So the
 * component manager will be able to send packets to other internal or external components and also
 * receive packets from other components or even from trusted clients (e.g. ad-hoc commands).
 *
 * @author Derek DeMoro
 */
public class InternalComponentManager extends BasicModule implements ClusterEventListener, ComponentManager, RoutableChannelHandler {

<span class="nc" id="L60">    private static final Logger Log = LoggerFactory.getLogger(InternalComponentManager.class);</span>

    public static final String COMPONENT_CACHE_NAME = &quot;Components&quot;;

    /**
     * Cache (unlimited, never expire) that tracks what component is available on which cluster node.
     * Key: component address, Value: identifier of each cluster node holding serving the component.
     */
    private Cache&lt;JID, HashSet&lt;NodeID&gt;&gt; componentCache;

    /**
     * A map that maps an address to a (facade for a) component.
     *
     * This map only contains data for components connected to the local cluster node.
     */
<span class="nc" id="L75">    final private Map&lt;String, RoutableComponents&gt; routables = new ConcurrentHashMap&lt;&gt;();</span>

    /**
     * A map that has service discovery information for components.
     *
     * This map contains data for components all over the cluster.
     */
<span class="nc" id="L82">    private Map&lt;String, IQ&gt; componentInfo = new ConcurrentHashMap&lt;&gt;();</span>

    /**
     * A map that maps the identify of an entity that requests a presence probe from
     * a component (where the value is the JID of the component.
     */
    // FIXME this construct limits every probee to exactly one presence probe. If the probee requests another probe after the first, the first request is silently overwritten. That's unlikely to be intended.
<span class="nc" id="L89">    private Map&lt;JID, JID&gt; presenceMap = new ConcurrentHashMap&lt;&gt;();</span>

    /**
     * Holds the list of listeners that will be notified of component events.
     */
<span class="nc" id="L94">    private List&lt;ComponentEventListener&gt; listeners = new CopyOnWriteArrayList&lt;&gt;();</span>

    private static InternalComponentManager instance;
    /**
     * XMPP address of this internal service. The address is of the form: component.[domain]
     */
    private JID serviceAddress;
    /**
     * Holds the domain of the server. We are using an iv since we use this value many times
     * in many methods.
     */
    private String serverDomain;
    private RoutingTable routingTable;

    public InternalComponentManager() {
<span class="nc" id="L109">        super(&quot;Internal Component Manager&quot;);</span>
<span class="nc" id="L110">        instance = this;</span>
<span class="nc" id="L111">    }</span>

    public static InternalComponentManager getInstance() {
<span class="nc" id="L114">        return instance;</span>
    }

    @Override
    public void initialize(XMPPServer server) {
<span class="nc" id="L119">        super.initialize(server);</span>
<span class="nc" id="L120">        routingTable = server.getRoutingTable();</span>
<span class="nc" id="L121">        componentCache = CacheFactory.createCache( COMPONENT_CACHE_NAME );</span>
<span class="nc" id="L122">        ClusterManager.addListener( this );</span>
<span class="nc" id="L123">    }</span>

    @Override
    public void start() {
        // Set this ComponentManager as the current component manager
<span class="nc" id="L128">        ComponentManagerFactory.setComponentManager(instance);</span>

<span class="nc" id="L130">        XMPPServer server = XMPPServer.getInstance();</span>
<span class="nc" id="L131">        serverDomain = server.getServerInfo().getXMPPDomain();</span>
        // Set the address of this internal service. component.[domain]
<span class="nc" id="L133">        serviceAddress = new JID(null, &quot;component.&quot; + serverDomain, null);</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">        if (!server.isSetupMode()) {</span>
            // Add a route to this service
<span class="nc" id="L136">            server.getRoutingTable().addComponentRoute(getAddress(), this);</span>
        }
<span class="nc" id="L138">    }</span>

    @Override
    public void stop() {
<span class="nc" id="L142">        super.stop();</span>
<span class="nc" id="L143">        synchronized ( routables ) {</span>
            // OF-1700: Shut down each connected component properly, which benefits other cluster nodes.
<span class="nc" id="L145">            final Set&lt;String&gt; subdomains = routables.keySet();</span>
<span class="nc" id="L146">            subdomains.forEach( this::removeComponent );</span>
<span class="nc" id="L147">        }</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (getAddress() != null) {</span>
            // Remove the route to this service
<span class="nc" id="L150">            XMPPServer.getInstance().getRoutingTable().removeComponentRoute(getAddress());</span>
        }
<span class="nc" id="L152">    }</span>

    @Override
    public void destroy() {
<span class="nc" id="L156">        super.destroy();</span>
<span class="nc" id="L157">        ClusterManager.removeListener( this );</span>
<span class="nc" id="L158">    }</span>

    @Override
    public void addComponent(String subdomain, Component component) throws ComponentException {
<span class="nc" id="L162">        synchronized (routables) {</span>
<span class="nc" id="L163">            RoutableComponents routable = routables.get(subdomain);</span>
<span class="nc bnc" id="L164" title="All 4 branches missed.">            if (routable != null &amp;&amp; routable.hasComponent(component)) {</span>
                // This component has already registered with this subdomain.
                // TODO: Is this all we should do?  Should we return an error?
<span class="nc" id="L167">                return;</span>
            }
<span class="nc" id="L169">            Log.debug(&quot;InternalComponentManager: Registering component for domain: &quot; + subdomain);</span>
<span class="nc" id="L170">            JID componentJID = new JID(subdomain + &quot;.&quot; + serverDomain);</span>
<span class="nc" id="L171">            boolean isNewComponentRoute = false; // A subdomain can be served by more than one Component instance (mainly for load distribution).</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">            if (routable != null) {</span>
<span class="nc" id="L173">                routable.addComponent(component);</span>
            }
            else {
<span class="nc" id="L176">                routable = new RoutableComponents(componentJID, component);</span>
<span class="nc" id="L177">                routables.put(subdomain, routable);</span>

<span class="nc bnc" id="L179" title="All 2 branches missed.">                if (!routingTable.hasComponentRoute(componentJID)) {</span>
<span class="nc" id="L180">                    isNewComponentRoute = true;</span>
                }
                // Add the route to the new service provided by the component
<span class="nc" id="L183">                routingTable.addComponentRoute(componentJID, routable);</span>
<span class="nc" id="L184">                CacheUtil.addValueToMultiValuedCache( componentCache, componentJID, XMPPServer.getInstance().getNodeID(), HashSet::new );</span>
            }

            // Initialize the new component
            try {
<span class="nc" id="L189">                component.initialize(componentJID, this);</span>
<span class="nc" id="L190">                component.start();</span>

<span class="nc bnc" id="L192" title="All 2 branches missed.">                if (isNewComponentRoute) {</span>
                    // Notify listeners that a new component has been registered
<span class="nc" id="L194">                    notifyComponentRegistered(componentJID);</span>
                    // Alert other nodes of new registered domain event
<span class="nc" id="L196">                    CacheFactory.doClusterTask(new NotifyComponentRegistered(componentJID));</span>
                }

                // Check for potential interested users.
<span class="nc" id="L200">                checkPresences();</span>

<span class="nc bnc" id="L202" title="All 2 branches missed.">                if (isNewComponentRoute) {</span>
                    // Send a disco#info request to the new component. If the component provides information
                    // then it will be added to the list of discoverable server items.
<span class="nc" id="L205">                    checkDiscoSupport( component, componentJID );</span>
                }
<span class="nc" id="L207">                Log.debug(&quot;InternalComponentManager: Component registered for domain: &quot; + subdomain);</span>
            }
<span class="nc" id="L209">            catch (Exception e) {</span>
                // Unregister the component's domain
<span class="nc" id="L211">                routable.removeComponent(component);</span>

<span class="nc bnc" id="L213" title="All 2 branches missed.">                if (e instanceof ComponentException) {</span>
                    // Rethrow the exception
<span class="nc" id="L215">                    throw (ComponentException)e;</span>
                }
                // Rethrow the exception
<span class="nc" id="L218">                throw new ComponentException(e);</span>
            }
            finally {
<span class="nc bnc" id="L221" title="All 4 branches missed.">                if (routable.numberOfComponents() == 0) {</span>
                    // If there are no more components associated with this subdomain, remove it.
<span class="nc" id="L223">                    routables.remove(subdomain);</span>
                    // Remove the route
<span class="nc" id="L225">                    CacheUtil.removeValueFromMultiValuedCache( componentCache, componentJID, XMPPServer.getInstance().getNodeID() );</span>
<span class="nc" id="L226">                    XMPPServer.getInstance().getRoutingTable().removeComponentRoute(componentJID);</span>
                }
<span class="nc" id="L228">            }</span>
<span class="nc" id="L229">        }</span>
<span class="nc" id="L230">    }</span>

    void notifyComponentRegistered(JID componentJID) {
<span class="nc bnc" id="L233" title="All 2 branches missed.">        for (ComponentEventListener listener : listeners) {</span>
            try {
<span class="nc" id="L235">                listener.componentRegistered(componentJID);</span>
<span class="nc" id="L236">            } catch (Exception e) {</span>
<span class="nc" id="L237">                Log.warn(&quot;An exception occurred while dispatching a 'componentRegistered' event!&quot;, e);</span>
<span class="nc" id="L238">            }</span>
<span class="nc" id="L239">        }</span>
<span class="nc" id="L240">    }</span>

    /**
     * Removes a component. The {@link Component#shutdown} method will be called on the
     * component. Note that if the component was an external component that was connected
     * several times then all its connections will be terminated.
     *
     * @param subdomain the subdomain of the component's address.
     */
    @Override
    public void removeComponent(String subdomain) {
<span class="nc" id="L251">        RoutableComponents components = null;</span>
<span class="nc bnc" id="L252" title="All 4 branches missed.">        if (routables == null || (components = routables.get(subdomain)) == null) {</span>
<span class="nc" id="L253">            return;</span>
        }
<span class="nc" id="L255">        List&lt;Component&gt; componentsToRemove = new ArrayList&lt;&gt;(components.getComponents());</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">        for (Component component : componentsToRemove) {</span>
<span class="nc" id="L257">            removeComponent(subdomain, component);</span>
<span class="nc" id="L258">        }</span>
<span class="nc" id="L259">    }</span>

    /**
     * Removes a given component. Unlike {@link #removeComponent(String)} this method will just
     * remove a single component instead of all components associated to the subdomain. External
     * components may connect several times and register for the same subdomain. This method
     * just removes a singled connection not all of them.
     *
     * @param subdomain the subdomain of the component's address.
     * @param component specific component to remove.
     */
    public void removeComponent(String subdomain, Component component) {
<span class="nc bnc" id="L271" title="All 2 branches missed.">        if (component == null) {</span>
<span class="nc" id="L272">            return;</span>
        }
<span class="nc" id="L274">        synchronized (routables) {</span>
<span class="nc" id="L275">            Log.debug(&quot;InternalComponentManager: Unregistering component for domain: &quot; + subdomain);</span>
<span class="nc" id="L276">            RoutableComponents routable = routables.get(subdomain);</span>
<span class="nc" id="L277">            routable.removeComponent(component);</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">            if (routable.numberOfComponents() == 0) {</span>
<span class="nc" id="L279">                routables.remove(subdomain);</span>

<span class="nc" id="L281">                JID componentJID = new JID(subdomain + &quot;.&quot; + serverDomain);</span>

                // Remove the route for the service provided by the component
<span class="nc" id="L284">                CacheUtil.removeValueFromMultiValuedCache( componentCache, componentJID, XMPPServer.getInstance().getNodeID() );</span>
<span class="nc" id="L285">                routingTable.removeComponentRoute(componentJID);</span>

                // Ask the component to shutdown
<span class="nc" id="L288">                component.shutdown();</span>

<span class="nc bnc" id="L290" title="All 2 branches missed.">                if (!routingTable.hasComponentRoute(componentJID)) {</span>
                    // Remove the disco item from the server for the component that is being removed
<span class="nc" id="L292">                    IQDiscoItemsHandler iqDiscoItemsHandler = XMPPServer.getInstance().getIQDiscoItemsHandler();</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">                    if (iqDiscoItemsHandler != null) {</span>
<span class="nc" id="L294">                        iqDiscoItemsHandler.removeComponentItem(componentJID.toBareJID());</span>
                    }
<span class="nc" id="L296">                    removeComponentInfo(componentJID);</span>
                    // Notify listeners that an existing component has been unregistered
<span class="nc" id="L298">                    notifyComponentUnregistered(componentJID);</span>
                    // Alert other nodes of component removed event
<span class="nc" id="L300">                    CacheFactory.doClusterTask(new NotifyComponentUnregistered(componentJID));</span>
                }
<span class="nc" id="L302">                Log.debug(&quot;InternalComponentManager: Component unregistered for domain: &quot; + subdomain);</span>
<span class="nc" id="L303">            }</span>
            else {
<span class="nc" id="L305">                Log.debug(&quot;InternalComponentManager: Other components still tied to domain: &quot; + subdomain);</span>
            }
<span class="nc" id="L307">        }</span>
<span class="nc" id="L308">    }</span>

    void notifyComponentUnregistered(JID componentJID) {
<span class="nc bnc" id="L311" title="All 2 branches missed.">        for (ComponentEventListener listener : listeners) {</span>
            try {
<span class="nc" id="L313">                listener.componentUnregistered(componentJID);</span>
<span class="nc" id="L314">            } catch (Exception e) {</span>
<span class="nc" id="L315">                Log.warn(&quot;An exception occurred while dispatching a 'componentUnregistered' event!&quot;, e);</span>
<span class="nc" id="L316">            }</span>
<span class="nc" id="L317">        }</span>
<span class="nc" id="L318">    }</span>

    void removeComponentInfo(JID componentJID) {
        // Remove any info stored with the component being removed
<span class="nc" id="L322">        componentInfo.remove(componentJID.getDomain());</span>
<span class="nc" id="L323">    }</span>

    @Override
    public void sendPacket(Component component, Packet packet) {
<span class="nc bnc" id="L327" title="All 4 branches missed.">        if (packet != null &amp;&amp; packet.getFrom() == null) {</span>
<span class="nc" id="L328">            throw new IllegalArgumentException(&quot;Packet with no FROM address was received from component.&quot;);</span>
        }
        
<span class="nc" id="L331">        PacketRouter router = XMPPServer.getInstance().getPacketRouter();</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (router != null) {</span>
<span class="nc" id="L333">            router.route(packet);</span>
        }
<span class="nc" id="L335">    }</span>

    @Override
    public IQ query(Component component, IQ packet, long timeout) throws ComponentException {
<span class="nc" id="L339">        final LinkedBlockingQueue&lt;IQ&gt; answer = new LinkedBlockingQueue&lt;&gt;(8);</span>
<span class="nc" id="L340">        XMPPServer.getInstance().getIQRouter().addIQResultListener(packet.getID(), new IQResultListener() {</span>
            @Override
            public void receivedAnswer(IQ packet) {
<span class="nc" id="L343">                answer.offer(packet);</span>
<span class="nc" id="L344">            }</span>

            @Override
            public void answerTimeout(String packetId) {
<span class="nc" id="L348">                Log.warn(&quot;An answer to a previously sent IQ stanza was never received. Packet id: &quot; + packetId);</span>
<span class="nc" id="L349">            }</span>
        });
<span class="nc" id="L351">        sendPacket(component, packet);</span>
<span class="nc" id="L352">        IQ reply = null;</span>
        try {
<span class="nc" id="L354">            reply = answer.poll(timeout, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L355">        } catch (InterruptedException e) {</span>
            // Ignore
<span class="nc" id="L357">        }</span>
<span class="nc" id="L358">        return reply;</span>
    }

    @Override
    public void query(Component component, IQ packet, IQResultListener listener) throws ComponentException {
<span class="nc" id="L363">        XMPPServer.getInstance().getIQRouter().addIQResultListener(packet.getID(), listener);</span>
<span class="nc" id="L364">        sendPacket(component, packet);</span>
<span class="nc" id="L365">    }</span>

    /**
     * Adds a new listener that will be notified of component events. Events being
     * notified are: 1) when a component is added to the component manager, 2) when
     * a component is deleted and 3) when disco#info is received from a component.
     *
     * @param listener the new listener to notify of component events.
     */
    public void addListener(ComponentEventListener listener) {
<span class="nc" id="L375">        listeners.add(listener);</span>
        // Notify the new listener about existing components
<span class="nc bnc" id="L377" title="All 2 branches missed.">        for (String domain : routingTable.getComponentsDomains()) {</span>
<span class="nc" id="L378">            JID componentJID = new JID(domain);</span>
<span class="nc" id="L379">            listener.componentRegistered(componentJID);</span>
            // Check if there is disco#info stored for the component
<span class="nc" id="L381">            IQ disco = componentInfo.get(domain);</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">            if (disco != null) {</span>
<span class="nc" id="L383">                listener.componentInfoReceived(disco);</span>
            }
<span class="nc" id="L385">        }</span>
<span class="nc" id="L386">    }</span>

    IQ getComponentInfo( JID domain )
    {
<span class="nc" id="L390">        return componentInfo.get( domain.toString() );</span>
    }

    /**
     * Removes the specified listener from the listeners being notified of component
     * events.
     *
     * @param listener the listener to remove.
     */
    public void removeListener(ComponentEventListener listener) {
<span class="nc" id="L400">        listeners.remove(listener);</span>
<span class="nc" id="L401">    }</span>

    @Override
    public String getProperty(String name) {
<span class="nc" id="L405">        return JiveGlobals.getProperty(name);</span>
    }

    @Override
    public void setProperty(String name, String value) {
        //Ignore
<span class="nc" id="L411">    }</span>

    @Override
    public String getServerName() {
<span class="nc" id="L415">        return serverDomain;</span>
    }

    public String getHomeDirectory() {
<span class="nc" id="L419">        return JiveGlobals.getHomeDirectory();</span>
    }

    @Override
    public boolean isExternalMode() {
<span class="nc" id="L424">        return false;</span>
    }


    /**
     * Retrieves the &lt;code&gt;Component&lt;/code&gt; which is mapped to the specified JID. The
     * look up will only be done on components that were registered with this JVM. That
     * means that components registered in other cluster nodes are not going to be
     * considered.
     *
     * @param componentJID the jid mapped to the component.
     * @return the list of components with the specified id.
     */
    private List&lt;Component&gt; getComponents(JID componentJID) {
<span class="nc" id="L438">        synchronized (routables) {</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">            if (componentJID.getNode() != null) {</span>
<span class="nc" id="L440">                return Collections.emptyList();</span>
            }
<span class="nc" id="L442">            RoutableComponents routable = routables.get(componentJID.getDomain());</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">            if (routable != null) {</span>
<span class="nc" id="L444">                return routable.getComponents();</span>
            }
            else {
                // Search again for those JIDs whose domain include the server name but this
                // time remove the server name from the JID's domain
<span class="nc" id="L449">                String serverName = componentJID.getDomain();</span>
<span class="nc" id="L450">                int index = serverName.lastIndexOf(&quot;.&quot; + serverDomain);</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">                if (index &gt; -1) {</span>
<span class="nc" id="L452">                    routable = routables.get(serverName.substring(0, index));</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">                    if (routable != null) {</span>
<span class="nc" id="L454">                        return routable.getComponents();</span>
                    }
                }
            }
<span class="nc" id="L458">            return Collections.emptyList();</span>
<span class="nc" id="L459">        }</span>
    }

    /**
     * Returns true if a component is associated to the specified address. Components
     * registered with this JVM or other cluster nodes are going to be considered.
     *
     * @param componentJID the address of the component. This is the complete domain.
     * @return true if a component is associated to the specified address.
     */
    public boolean hasComponent(JID componentJID) {
<span class="nc" id="L470">        synchronized (routables) {</span>
<span class="nc bnc" id="L471" title="All 4 branches missed.">            if (componentJID.getNode() != null || componentJID.getResource() != null) {</span>
<span class="nc" id="L472">                return false;</span>
            }
    //        if (componentJID.getDomain().lastIndexOf(&quot;.&quot; + serverDomain) == -1) {
    //            componentJID = new JID(componentJID.getDomain() + &quot;.&quot; + serverDomain);
    //        }
<span class="nc" id="L477">            return routingTable.hasComponentRoute(componentJID);</span>
<span class="nc" id="L478">        }</span>
    }

    /**
     * Registers Probers who have not yet been serviced.
     *
     * @param prober the jid probing.
     * @param probee the presence being probed.
     */
    public void addPresenceRequest(JID prober, JID probee) {
<span class="nc" id="L488">        presenceMap.put(prober, probee);</span>
<span class="nc" id="L489">    }</span>

    private void checkPresences() {
<span class="nc bnc" id="L492" title="All 2 branches missed.">        for (JID prober : presenceMap.keySet()) {</span>
<span class="nc" id="L493">            JID probee = presenceMap.get(prober);</span>

<span class="nc bnc" id="L495" title="All 2 branches missed.">            if (routingTable.hasComponentRoute(probee)) {</span>
<span class="nc" id="L496">                Presence presence = new Presence();</span>
<span class="nc" id="L497">                presence.setFrom(prober);</span>
<span class="nc" id="L498">                presence.setTo(probee);</span>
<span class="nc" id="L499">                routingTable.routePacket(probee, presence, false);</span>

                // No reason to hold onto prober reference.
<span class="nc" id="L502">                presenceMap.remove(prober);</span>
            }
<span class="nc" id="L504">        }</span>
<span class="nc" id="L505">    }</span>

    /**
     *  Send a disco#info request to the new component. If the component provides information
     *  then it will be added to the list of discoverable server items.
     *
     * @param component the new component that was added to this manager.
     * @param componentJID the XMPP address of the new component.
     */
    private void checkDiscoSupport(Component component, JID componentJID) {
        // Build a disco#info request that will be sent to the component
<span class="nc" id="L516">        IQ iq = new IQ(IQ.Type.get);</span>
<span class="nc" id="L517">        iq.setFrom(getAddress());</span>
<span class="nc" id="L518">        iq.setTo(componentJID);</span>
<span class="nc" id="L519">        iq.setChildElement(&quot;query&quot;, &quot;http://jabber.org/protocol/disco#info&quot;);</span>
        // Send the disco#info request to the component. The reply (if any) will be processed in
        // #process(Packet)
//        sendPacket(component, iq);
<span class="nc" id="L523">        component.processPacket(iq);</span>
<span class="nc" id="L524">    }</span>

    @Override
    public JID getAddress() {
<span class="nc" id="L528">        return serviceAddress;</span>
    }

    /**
     * Processes packets that were sent to this service. Currently only packets that were sent from
     * registered components are being processed. In the future, we may also process packet of
     * trusted clients. Trusted clients may be able to execute ad-hoc commands such as adding or
     * removing components.
     *
     * @param packet the packet to process.
     */
    @Override
    public void process(Packet packet) throws PacketException {
<span class="nc" id="L541">        List&lt;Component&gt; components = getComponents(packet.getFrom());</span>
        // Only process packets that were sent by registered components
<span class="nc bnc" id="L543" title="All 2 branches missed.">        if (!components.isEmpty()) {</span>
<span class="nc bnc" id="L544" title="All 4 branches missed.">            if (packet instanceof IQ &amp;&amp; IQ.Type.result == ((IQ) packet).getType()) {</span>
<span class="nc" id="L545">                IQ iq = (IQ) packet;</span>
<span class="nc" id="L546">                Element childElement = iq.getChildElement();</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">                if (childElement != null) {</span>
<span class="nc" id="L548">                    String namespace = childElement.getNamespaceURI();</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">                    if (&quot;http://jabber.org/protocol/disco#info&quot;.equals(namespace)) {</span>
                        // Add a disco item to the server for the component that supports disco
<span class="nc" id="L551">                        Element identity = childElement.element(&quot;identity&quot;);</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">                        if (identity == null) {</span>
                            // Do nothing since there are no identities in the disco#info packet
<span class="nc" id="L554">                            return;</span>
                        }
                        try {
<span class="nc" id="L557">                            XMPPServer.getInstance().getIQDiscoItemsHandler().addComponentItem(packet.getFrom()</span>
<span class="nc" id="L558">                                    .toBareJID(),</span>
<span class="nc" id="L559">                                    identity.attributeValue(&quot;name&quot;));</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">                            for (Component component : components) {</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">                                if (component instanceof ComponentSession.ExternalComponent) {</span>
<span class="nc" id="L562">                                    ComponentSession.ExternalComponent externalComponent =</span>
                                            (ComponentSession.ExternalComponent) component;
<span class="nc" id="L564">                                    externalComponent.setName(identity.attributeValue(&quot;name&quot;));</span>
<span class="nc" id="L565">                                    externalComponent.setType(identity.attributeValue(&quot;type&quot;));</span>
<span class="nc" id="L566">                                    externalComponent.setCategory(identity.attributeValue(&quot;category&quot;));</span>
                                }
<span class="nc" id="L568">                            }</span>
                        }
<span class="nc" id="L570">                        catch (Exception e) {</span>
<span class="nc" id="L571">                            Log.error(&quot;Error processing disco packet of components: &quot; + components +</span>
<span class="nc" id="L572">                                    &quot; - &quot; + packet.toXML(), e);</span>
<span class="nc" id="L573">                        }</span>
                        // Store the IQ disco#info returned by the component
<span class="nc" id="L575">                        addComponentInfo(iq);</span>
                        // Notify listeners that a component answered the disco#info request
<span class="nc" id="L577">                        notifyComponentInfo(iq);</span>
                        // Alert other cluster nodes
<span class="nc" id="L579">                        CacheFactory.doClusterTask(new NotifyComponentInfo(iq));</span>
                    }
                }
            }
        }
<span class="nc" id="L584">    }</span>

    void notifyComponentInfo(IQ iq) {
<span class="nc bnc" id="L587" title="All 2 branches missed.">        for (ComponentEventListener listener : listeners) {</span>
            try {
<span class="nc" id="L589">                listener.componentInfoReceived(iq);</span>
<span class="nc" id="L590">            } catch (Exception e) {</span>
<span class="nc" id="L591">                Log.warn(&quot;An exception occurred while dispatching a 'componentInfoReceived' event!&quot;, e);</span>
<span class="nc" id="L592">            }</span>
<span class="nc" id="L593">        }</span>
<span class="nc" id="L594">    }</span>

    void addComponentInfo(IQ iq) {
<span class="nc" id="L597">        componentInfo.put(iq.getFrom().getDomain(), iq);</span>
<span class="nc" id="L598">    }</span>

    @Override
    public void joinedCluster()
    {
        // Upon joining a cluster, the server can get a new ID. Here, all old IDs are replaced with the new identity.
<span class="nc" id="L604">        final NodeID defaultNodeID = XMPPServer.getInstance().getDefaultNodeID();</span>
<span class="nc" id="L605">        final NodeID nodeID = XMPPServer.getInstance().getNodeID();</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">        if ( !defaultNodeID.equals( nodeID ) ) // In more recent versions of Openfire, the ID does not change.</span>
        {
<span class="nc" id="L608">            CacheUtil.replaceValueInMultivaluedCache( componentCache, defaultNodeID, nodeID );</span>
        }

        // We joined a cluster. Determine what components run on other nodes,
        // and raise events for those that are not running on this node.
        // Eventing should be limited to the local cluster node, as other nodes
        // would already have had events when the components became available to
        // them.
<span class="nc" id="L616">        componentCache.entrySet().stream()</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">            .filter( entrySet -&gt; !entrySet.getValue().contains( nodeID ) )</span>
<span class="nc" id="L618">            .forEach( entry -&gt; {</span>
<span class="nc" id="L619">                Log.debug( &quot;The local cluster node joined the cluster. The component '{}' is living on one (or more) other cluster nodes, but not ours. Invoking the 'component registered' event, and requesting service info.&quot;, entry.getKey());</span>
<span class="nc" id="L620">                notifyComponentRegistered( entry.getKey() );</span>
                // Request one of the cluster nodes to sent us a NotifyComponentInfo instance. This async request does not block the current thread, and will update the instance eventually, after which notifications are sent out.
<span class="nc" id="L622">                CacheFactory.doClusterTask( new RequestComponentInfoNotification( entry.getKey(), nodeID ), entry.getValue().iterator().next().toByteArray() );</span>
<span class="nc" id="L623">            } );</span>

        // Additionally, let other cluster nodes know about the components that the local
        // node offers, to allow them to raise events if needed.
<span class="nc" id="L627">        componentCache.entrySet().stream()</span>
<span class="nc bnc" id="L628" title="All 4 branches missed.">            .filter( entrySet -&gt; entrySet.getValue().contains( nodeID ) &amp;&amp; entrySet.getValue().size() == 1 )</span>
<span class="nc" id="L629">            .map( Map.Entry::getKey )</span>
<span class="nc" id="L630">            .forEach( componentJID -&gt; {</span>
<span class="nc" id="L631">                Log.debug( &quot;The local cluster node joined the cluster. The component '{}' is living on our cluster node, but not on any others. Invoking the 'component registered' (and if applicable, the 'component info received') event on the remote nodes.&quot;, componentJID );</span>
<span class="nc" id="L632">                CacheFactory.doClusterTask( new NotifyComponentRegistered( componentJID ) );</span>
<span class="nc" id="L633">                final IQ info = componentInfo.get( componentJID.toString() );</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">                if ( info != null )</span>
                {
<span class="nc" id="L636">                    CacheFactory.doClusterTask( new NotifyComponentInfo( info ) );</span>
                }
<span class="nc" id="L638">            } );</span>
<span class="nc" id="L639">    }</span>

    @Override
    public void joinedCluster( final byte[] nodeID )
    {
        // Another node joined a cluster that we're already part of. It is expected that
        // the implementation of #joinedCluster() as executed on the cluster node that just
        // joined will synchronize all relevant data. This method need not do anything.
<span class="nc" id="L647">    }</span>

    @Override
    public void leftCluster()
    {
        // Upon leaving a cluster, the server uses its non-clustered/default ID again. Here, all clustered IDs are replaced with the new identity.
<span class="nc" id="L653">        final NodeID defaultNodeID = XMPPServer.getInstance().getDefaultNodeID();</span>
<span class="nc" id="L654">        final NodeID nodeID = XMPPServer.getInstance().getNodeID();</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">        if ( !defaultNodeID.equals( nodeID ) ) // In more recent versions of Openfire, the ID does not change.</span>
        {
<span class="nc" id="L657">            CacheUtil.replaceValueInMultivaluedCache( componentCache, nodeID, defaultNodeID );</span>
        }

        // The local cluster node left the cluster.
        //
        // Determine what components that we are broadcasting were available only on other
        // cluster nodes than the local one. For these, unavailability events need
        // to be sent out (eventing will be limited to the local node, as we're no longer
        // part of a cluster).
<span class="nc" id="L666">        final Map&lt;Boolean, Map&lt;JID, HashSet&lt;NodeID&gt;&gt;&gt; modified = CacheUtil.retainValueInMultiValuedCache( componentCache, defaultNodeID );</span>

<span class="nc" id="L668">        modified.get( false ).keySet().forEach( removedDomain -&gt; {</span>
<span class="nc" id="L669">            Log.debug( &quot;The local cluster node left the cluster. The component '{}' was living on one (or more) other cluster nodes, and is no longer available. Invoking the 'component unregistered' event.&quot;, removedDomain );</span>
<span class="nc" id="L670">            notifyComponentUnregistered( removedDomain );</span>

            // Also clean up the cache of cluster-wide service discovery results.
<span class="nc" id="L673">            componentInfo.remove( removedDomain.toString() );</span>
<span class="nc" id="L674">        } );</span>
<span class="nc" id="L675">    }</span>

    @Override
    public void leftCluster( final byte[] nodeID )
    {
        // Another node left the cluster.
        //
        // If the cluster node leaves in an orderly fashion, it might have broadcasted
        // the necessary events itself. This cannot be depended on, as the cluster node
        // might have disconnected unexpectedly (as a result of a crash or network issue).
        //
        // Determine what components were available only on that node, and remove them.
        // For these, 'component unavailable' events need to be sent out. If the cluster
        // node exited cleanly, we won't find any entries to work on. If it did not
        // exit cleanly, all remaining cluster nodes will be in a race to clean up the
        // same data. The implementation below accounts for that, by being thread- and
        // cluster safe.
<span class="nc" id="L692">        final Map&lt;Boolean, Map&lt;JID, HashSet&lt;NodeID&gt;&gt;&gt; modified = CacheUtil.removeValueFromMultiValuedCache( componentCache, NodeID.getInstance( nodeID ) );</span>

<span class="nc" id="L694">        modified.get( false ).keySet().forEach( removedDomain -&gt; {</span>
<span class="nc" id="L695">            Log.debug( &quot;Cluster node {} just left the cluster, and was the only node on which component '{}' was living. Invoking the 'component unregistered' event on all remaining cluster nodes.&quot;, NodeID.getInstance( nodeID ), removedDomain );</span>
<span class="nc" id="L696">            notifyComponentUnregistered( removedDomain );</span>

            // As we have removed the disappeared components from the clustered cache, other nodes
            // can no longer determine what components became unavailable. We'll need to broadcast
            // the unavailable event over the entire cluster!
<span class="nc" id="L701">            CacheFactory.doClusterTask( new NotifyComponentUnregistered( removedDomain ) );</span>

            // Also clean up the cache of cluster-wide service discovery results.
<span class="nc" id="L704">            componentInfo.remove( removedDomain.toString() );</span>
<span class="nc" id="L705">        } );</span>
<span class="nc" id="L706">    }</span>

    @Override
    public void markedAsSeniorClusterMember()
    {
        // No action needed.
<span class="nc" id="L712">    }</span>

    /**
     * Exposes a Component as a RoutableChannelHandler.
     */
    private static class RoutableComponents implements RoutableChannelHandler {

        private JID jid;
<span class="nc" id="L720">        final private List&lt;Component&gt; components = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L722">        public RoutableComponents(JID jid, Component component) {</span>
<span class="nc" id="L723">            this.jid = jid;</span>
<span class="nc" id="L724">            addComponent(component);</span>
<span class="nc" id="L725">        }</span>

        public void addComponent(Component component) {
<span class="nc" id="L728">            synchronized (components) {</span>
<span class="nc" id="L729">                components.add(component);</span>
<span class="nc" id="L730">            }</span>
<span class="nc" id="L731">        }</span>

        public void removeComponent(Component component) {
<span class="nc" id="L734">            synchronized (components) {</span>
<span class="nc" id="L735">                components.remove(component);</span>
<span class="nc" id="L736">            }</span>
<span class="nc" id="L737">        }</span>

        public void removeAllComponents() {
<span class="nc" id="L740">            synchronized (components) {</span>
<span class="nc" id="L741">                components.clear();</span>
<span class="nc" id="L742">            }</span>
<span class="nc" id="L743">        }</span>

        public Boolean hasComponent(Component component) {
<span class="nc" id="L746">            return components.contains(component);</span>
        }

        public Integer numberOfComponents() {
<span class="nc" id="L750">            return components.size();</span>
        }

        public List&lt;Component&gt; getComponents() {
<span class="nc" id="L754">            return components;</span>
        }

        private Component getNextComponent() {
            Component component;
<span class="nc" id="L759">            synchronized (components) {</span>
<span class="nc" id="L760">                component = components.get(0);</span>
<span class="nc" id="L761">                Collections.rotate(components, 1);</span>
<span class="nc" id="L762">            }</span>
<span class="nc" id="L763">            return component;</span>
        }

        @Override
        public JID getAddress() {
<span class="nc" id="L768">            return jid;</span>
        }

        @Override
        public void process(Packet packet) throws PacketException {
<span class="nc" id="L773">            Component component = getNextComponent();</span>
<span class="nc" id="L774">            component.processPacket(packet);</span>
<span class="nc" id="L775">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>