<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>LocalClientSession.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Core XMPP Server</a> &gt; <a href="index.source.html" class="el_package">org.jivesoftware.openfire.session</a> &gt; <span class="el_source">LocalClientSession.java</span></div><h1>LocalClientSession.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2005-2008 Jive Software. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jivesoftware.openfire.session;

import java.net.UnknownHostException;
import java.util.*;

import org.jivesoftware.openfire.Connection;
import org.jivesoftware.openfire.SessionManager;
import org.jivesoftware.openfire.StreamID;
import org.jivesoftware.openfire.XMPPServer;
import org.jivesoftware.openfire.auth.AuthToken;
import org.jivesoftware.openfire.auth.UnauthorizedException;
import org.jivesoftware.openfire.cluster.ClusterManager;
import org.jivesoftware.openfire.entitycaps.EntityCapabilities;
import org.jivesoftware.openfire.entitycaps.EntityCapabilitiesManager;
import org.jivesoftware.openfire.net.SASLAuthentication;
import org.jivesoftware.openfire.privacy.PrivacyList;
import org.jivesoftware.openfire.privacy.PrivacyListManager;
import org.jivesoftware.openfire.roster.RosterManager;
import org.jivesoftware.openfire.spi.ConnectionConfiguration;
import org.jivesoftware.openfire.streammanagement.StreamManager;
import org.jivesoftware.openfire.user.PresenceEventDispatcher;
import org.jivesoftware.openfire.user.UserNotFoundException;
import org.jivesoftware.util.JiveGlobals;
import org.jivesoftware.util.LocaleUtils;
import org.jivesoftware.util.cache.Cache;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmpp.packet.*;

/**
 * Represents a session between the server and a client.
 *
 * @author Gaston Dombiak
 */
public class LocalClientSession extends LocalSession implements ClientSession {

<span class="nc" id="L55">    private static final Logger Log = LoggerFactory.getLogger(LocalClientSession.class);</span>

    private static final String ETHERX_NAMESPACE = &quot;http://etherx.jabber.org/streams&quot;;
    private static final String FLASH_NAMESPACE = &quot;http://www.jabber.com/streams/flash&quot;;

    /**
     * Keep the list of IP address that are allowed to connect to the server.
     *
     * If the list is  empty then anyone is allowed to connect to the server, unless the IP is on the blacklist (which
     * always takes precedence over the whitelist).
     *
     * Note: the values in this list can be hostnames, IP addresses or IP ranges (with wildcards).
     */
<span class="nc" id="L68">    private static Set&lt;String&gt; allowedIPs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L69">    private static Set&lt;String&gt; allowedAnonymIPs = new HashSet&lt;&gt;();</span>

    /**
     * Similar to {@link #allowedIPs}, but used for blacklisting rather than whitelisting.
     */
<span class="nc" id="L74">    private static Set&lt;String&gt; blockedIPs = new HashSet&lt;&gt;();</span>

    private boolean messageCarbonsEnabled;

    /**
     * The authentication token for this session.
     */
    protected AuthToken authToken;

    /**
     * Flag indicating if this session has been initialized yet (upon first available transition).
     */
    private boolean initialized;

    /**
     * Flag that indicates if the session was available ever.
     */
<span class="nc" id="L91">    private boolean wasAvailable = false;</span>

    /**
     * Flag indicating if the user requested to not receive offline messages when sending
     * an available presence. The user may send a disco request with node
     * &quot;http://jabber.org/protocol/offline&quot; so that no offline messages are sent to the
     * user when he becomes online. If the user is connected from many resources then
     * if one of the sessions stopped the flooding then no session should flood the user.
     */
<span class="nc" id="L100">    private boolean offlineFloodStopped = false;</span>

<span class="nc" id="L102">    private Presence presence = null;</span>

<span class="nc" id="L104">    private int conflictCount = 0;</span>

    /**
     * Privacy list that overrides the default privacy list. This list affects only this
     * session and only for the duration of the session.
     */
    private String activeList;

    /**
     * Default privacy list used for the session's user. This list is processed if there
     * is no active list set for the session.
     */
    private String defaultList;

    /**
     * Defines whether a XEP-0191 blocklist was requested by the client of this session.
     */
<span class="nc" id="L121">    private boolean hasRequestedBlocklist = false;</span>

    static {
        // Fill out the allowedIPs with the system property
<span class="nc" id="L125">        String allowed = JiveGlobals.getProperty(ConnectionSettings.Client.LOGIN_ALLOWED, &quot;&quot;);</span>
<span class="nc" id="L126">        StringTokenizer tokens = new StringTokenizer(allowed, &quot;, &quot;);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        while (tokens.hasMoreTokens()) {</span>
<span class="nc" id="L128">            String address = tokens.nextToken().trim();</span>
<span class="nc" id="L129">            allowedIPs.add( address );</span>
<span class="nc" id="L130">        }</span>
<span class="nc" id="L131">        String allowedAnonym = JiveGlobals.getProperty(ConnectionSettings.Client.LOGIN_ANONYM_ALLOWED, &quot;&quot;);</span>
<span class="nc" id="L132">        tokens = new StringTokenizer(allowedAnonym, &quot;, &quot;);</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">        while (tokens.hasMoreTokens()) {</span>
<span class="nc" id="L134">            String address = tokens.nextToken().trim();</span>
<span class="nc" id="L135">            allowedAnonymIPs.add(address);</span>
<span class="nc" id="L136">        }</span>
<span class="nc" id="L137">        String blocked = JiveGlobals.getProperty(ConnectionSettings.Client.LOGIN_BLOCKED, &quot;&quot;);</span>
<span class="nc" id="L138">        tokens = new StringTokenizer(blocked, &quot;, &quot;);</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">        while (tokens.hasMoreTokens()) {</span>
<span class="nc" id="L140">            String address = tokens.nextToken().trim();</span>
<span class="nc" id="L141">            blockedIPs.add( address );</span>
<span class="nc" id="L142">        }</span>
<span class="nc" id="L143">    }</span>

    /**
     * Returns the list of IP address that are allowed to connect to the server. If the list is
     * empty then anyone is allowed to connect to the server except for anonymous users that are
     * subject to {@link #getAllowedAnonymIPs()}. This list is used for both anonymous and
     * non-anonymous users.
     *
     * Note that the blacklist in {@link #getBlacklistedIPs()} should take precedence!
     *
     * @return the list of IP address that are allowed to connect to the server.
     * @deprecated Use #getWhitelistedIPs instead.
     */
    @Deprecated
    public static Map&lt;String, String&gt; getAllowedIPs()
    {
<span class="nc" id="L159">        final Map&lt;String, String&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">        for ( String item : allowedIPs )</span>
        {
<span class="nc" id="L162">            result.put( item, null );</span>
<span class="nc" id="L163">        }</span>
<span class="nc" id="L164">        return result;</span>
    }

    /**
     * Returns the list of IP address that are allowed to connect to the server. If the list is empty then anyone is
     * allowed to connect to the server except for anonymous users that are subject to
     * {@link #getWhitelistedAnonymousIPs()}. This list is used for both anonymous and non-anonymous users.
     *
     * Note that the blacklist in {@link #getBlacklistedIPs()} should take precedence!
     *
     * @return the collection of IP address that are allowed to connect to the server. Never null, possibly empty.
     */
<span class="nc" id="L176">    public static Set&lt;String&gt; getWhitelistedIPs() { return allowedIPs; }</span>

    /**
     * Returns the list of IP address that are allowed to connect to the server for anonymous
     * users. If the list is empty then anonymous will be only restricted by {@link #getAllowedIPs()}.
     *
     * Note that the blacklist in {@link #getBlacklistedIPs()} should take precedence!
     *
     * @return the list of IP address that are allowed to connect to the server.
     * @deprecated Use #getWhitelistedAnonymousIPs instead.
     */
    public static Map&lt;String, String&gt; getAllowedAnonymIPs()
    {
<span class="nc" id="L189">        final Map&lt;String, String&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        for ( String item : allowedAnonymIPs )</span>
        {
<span class="nc" id="L192">            result.put( item, null );</span>
<span class="nc" id="L193">        }</span>
<span class="nc" id="L194">        return result;</span>
    }

    /**
     * Returns the list of IP address that are allowed to connect to the server for anonymous users. If the list is
     * empty then anonymous will be only restricted by {@link #getWhitelistedIPs()}.
     *
     * Note that the blacklist in {@link #getBlacklistedIPs()} should take precedence!
     *
     * @return the collection of IP address that are allowed to connect to the server. Never null, possibly empty.
     */
    public static Set&lt;String&gt; getWhitelistedAnonymousIPs() {
<span class="nc" id="L206">        return allowedAnonymIPs;</span>
    }

    /**
     * Returns the list of IP address that are disallowed to connect to the server. If the list is empty then anyone is
     * allowed to connect to the server, subject to whitelisting. This list is used for both anonymous and
     * non-anonymous users.
     *
     * @return the collection of IP address that are not allowed to connect to the server. Never null, possibly empty.
     */
<span class="nc" id="L216">    public static Set&lt;String&gt; getBlacklistedIPs() { return blockedIPs; }</span>

    /**
     * Returns a newly created session between the server and a client. The session will
     * be created and returned only if correct name/prefix (i.e. 'stream' or 'flash')
     * and namespace were provided by the client.
     *
     * @param serverName the name of the server where the session is connecting to.
     * @param xpp the parser that is reading the provided XML through the connection.
     * @param connection the connection with the client.
     * @return a newly created session between the server and a client.
     * @throws org.xmlpull.v1.XmlPullParserException if an error occurs while parsing incoming data.
     */
    public static LocalClientSession createSession(String serverName, XmlPullParser xpp, Connection connection)
            throws XmlPullParserException {
<span class="nc" id="L231">        boolean isFlashClient = xpp.getPrefix().equals(&quot;flash&quot;);</span>
<span class="nc" id="L232">        connection.setFlashClient(isFlashClient);</span>

        // Conduct error checking, the opening tag should be 'stream'
        // in the 'etherx' namespace
<span class="nc bnc" id="L236" title="All 4 branches missed.">        if (!xpp.getName().equals(&quot;stream&quot;) &amp;&amp; !isFlashClient) {</span>
<span class="nc" id="L237">            throw new XmlPullParserException(</span>
<span class="nc" id="L238">                    LocaleUtils.getLocalizedString(&quot;admin.error.bad-stream&quot;));</span>
        }

<span class="nc bnc" id="L241" title="All 4 branches missed.">        if (!xpp.getNamespace(xpp.getPrefix()).equals(ETHERX_NAMESPACE) &amp;&amp;</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">                !(isFlashClient &amp;&amp; xpp.getNamespace(xpp.getPrefix()).equals(FLASH_NAMESPACE)))</span>
        {
<span class="nc" id="L244">            throw new XmlPullParserException(LocaleUtils.getLocalizedString(</span>
                    &quot;admin.error.bad-namespace&quot;));
        }

<span class="nc bnc" id="L248" title="All 2 branches missed.">        if (!isAllowed(connection))</span>
        {
            // Client cannot connect from this IP address so end the stream and TCP connection.
<span class="nc" id="L251">            String hostAddress = &quot;Unknown&quot;;</span>
            try {
<span class="nc" id="L253">                hostAddress = connection.getHostAddress();</span>
<span class="nc" id="L254">            } catch (UnknownHostException e) {</span>
                // Do nothing
<span class="nc" id="L256">            }</span>

<span class="nc" id="L258">            Log.debug(&quot;LocalClientSession: Closed connection to client attempting to connect from: &quot; + hostAddress);</span>
            // Include the not-authorized error in the response
<span class="nc" id="L260">            StreamError error = new StreamError(StreamError.Condition.not_authorized);</span>
<span class="nc" id="L261">            connection.deliverRawText(error.toXML());</span>
            // Close the underlying connection
<span class="nc" id="L263">            connection.close();</span>
<span class="nc" id="L264">            return null;</span>
        }

        // Default language is English (&quot;en&quot;).
<span class="nc" id="L268">        Locale language = Locale.forLanguageTag(&quot;en&quot;);</span>
        // Default to a version of &quot;0.0&quot;. Clients written before the XMPP 1.0 spec may
        // not report a version in which case &quot;0.0&quot; should be assumed (per rfc3920
        // section 4.4.1).
<span class="nc" id="L272">        int majorVersion = 0;</span>
<span class="nc" id="L273">        int minorVersion = 0;</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">        for (int i = 0; i &lt; xpp.getAttributeCount(); i++) {</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">            if (&quot;lang&quot;.equals(xpp.getAttributeName(i))) {</span>
<span class="nc" id="L276">                language = Locale.forLanguageTag(xpp.getAttributeValue(i));</span>
            }
<span class="nc bnc" id="L278" title="All 2 branches missed.">            if (&quot;version&quot;.equals(xpp.getAttributeName(i))) {</span>
                try {
<span class="nc" id="L280">                    int[] version = decodeVersion(xpp.getAttributeValue(i));</span>
<span class="nc" id="L281">                    majorVersion = version[0];</span>
<span class="nc" id="L282">                    minorVersion = version[1];</span>
                }
<span class="nc" id="L284">                catch (Exception e) {</span>
<span class="nc" id="L285">                    Log.error(e.getMessage(), e);</span>
<span class="nc" id="L286">                }</span>
            }
        }

        // If the client supports a greater major version than the server,
        // set the version to the highest one the server supports.
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (majorVersion &gt; MAJOR_VERSION) {</span>
<span class="nc" id="L293">            majorVersion = MAJOR_VERSION;</span>
<span class="nc" id="L294">            minorVersion = MINOR_VERSION;</span>
        }
<span class="nc bnc" id="L296" title="All 2 branches missed.">        else if (majorVersion == MAJOR_VERSION) {</span>
            // If the client supports a greater minor version than the
            // server, set the version to the highest one that the server
            // supports.
<span class="nc bnc" id="L300" title="All 2 branches missed.">            if (minorVersion &gt; MINOR_VERSION) {</span>
<span class="nc" id="L301">                minorVersion = MINOR_VERSION;</span>
            }
        }

<span class="nc" id="L305">        connection.setXMPPVersion(majorVersion, minorVersion);</span>
<span class="nc" id="L306">        final ConnectionConfiguration connectionConfiguration = connection.getConfiguration();</span>

        // Indicate the TLS policy to use for this connection
<span class="nc bnc" id="L309" title="All 2 branches missed.">        if (!connection.isSecure()) {</span>
<span class="nc" id="L310">            boolean hasCertificates = false;</span>
            try {
<span class="nc bnc" id="L312" title="All 2 branches missed.">                hasCertificates = connectionConfiguration.getIdentityStore().getAllCertificates().size() &gt; 0;</span>
            }
<span class="nc" id="L314">            catch (Exception e) {</span>
<span class="nc" id="L315">                Log.error(e.getMessage(), e);</span>
<span class="nc" id="L316">            }</span>
<span class="nc" id="L317">            Connection.TLSPolicy tlsPolicy = connectionConfiguration.getTlsPolicy();</span>
<span class="nc bnc" id="L318" title="All 4 branches missed.">            if (Connection.TLSPolicy.required == tlsPolicy &amp;&amp; !hasCertificates) {</span>
<span class="nc" id="L319">                Log.error(&quot;Client session rejected. TLS is required but no certificates &quot; +</span>
                        &quot;were created.&quot;);
<span class="nc" id="L321">                return null;</span>
            }
            // Set default TLS policy
<span class="nc bnc" id="L324" title="All 2 branches missed.">            connection.setTlsPolicy(hasCertificates ? tlsPolicy : Connection.TLSPolicy.disabled);</span>
<span class="nc" id="L325">        } else {</span>
            // Set default TLS policy
<span class="nc" id="L327">            connection.setTlsPolicy(Connection.TLSPolicy.disabled);</span>
        }

        // Indicate the compression policy to use for this connection
<span class="nc" id="L331">        connection.setCompressionPolicy( connectionConfiguration.getCompressionPolicy() );</span>

        // Create a ClientSession for this user.
<span class="nc" id="L334">        LocalClientSession session = SessionManager.getInstance().createClientSession(connection, language);</span>

        // Build the start packet response
<span class="nc" id="L337">        StringBuilder sb = new StringBuilder(200);</span>
<span class="nc" id="L338">        sb.append(&quot;&lt;?xml version='1.0' encoding='&quot;);</span>
<span class="nc" id="L339">        sb.append(CHARSET);</span>
<span class="nc" id="L340">        sb.append(&quot;'?&gt;&quot;);</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">        if (isFlashClient) {</span>
<span class="nc" id="L342">            sb.append(&quot;&lt;flash:stream xmlns:flash=\&quot;http://www.jabber.com/streams/flash\&quot; &quot;);</span>
        }
        else {
<span class="nc" id="L345">            sb.append(&quot;&lt;stream:stream &quot;);</span>
        }
<span class="nc" id="L347">        sb.append(&quot;xmlns:stream=\&quot;http://etherx.jabber.org/streams\&quot; xmlns=\&quot;jabber:client\&quot; from=\&quot;&quot;);</span>
<span class="nc" id="L348">        sb.append(serverName);</span>
<span class="nc" id="L349">        sb.append(&quot;\&quot; id=\&quot;&quot;);</span>
<span class="nc" id="L350">        sb.append(session.getStreamID().toString());</span>
<span class="nc" id="L351">        sb.append(&quot;\&quot; xml:lang=\&quot;&quot;);</span>
<span class="nc" id="L352">        sb.append(language.toLanguageTag());</span>
        // Don't include version info if the version is 0.0.
<span class="nc bnc" id="L354" title="All 2 branches missed.">        if (majorVersion != 0) {</span>
<span class="nc" id="L355">            sb.append(&quot;\&quot; version=\&quot;&quot;);</span>
<span class="nc" id="L356">            sb.append(majorVersion).append('.').append(minorVersion);</span>
        }
<span class="nc" id="L358">        sb.append(&quot;\&quot;&gt;&quot;);</span>
<span class="nc" id="L359">        connection.deliverRawText(sb.toString());</span>

        // If this is a &quot;Jabber&quot; connection, the session is now initialized and we can
        // return to allow normal packet parsing.
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (majorVersion == 0) {</span>
<span class="nc" id="L364">            return session;</span>
        }
        // Otherwise, this is at least XMPP 1.0 so we need to announce stream features.

<span class="nc" id="L368">        sb = new StringBuilder(490);</span>
<span class="nc" id="L369">        sb.append(&quot;&lt;stream:features&gt;&quot;);</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">        if (connection.getTlsPolicy() != Connection.TLSPolicy.disabled) {</span>
<span class="nc" id="L371">            sb.append(&quot;&lt;starttls xmlns=\&quot;urn:ietf:params:xml:ns:xmpp-tls\&quot;&gt;&quot;);</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">            if (connection.getTlsPolicy() == Connection.TLSPolicy.required) {</span>
<span class="nc" id="L373">                sb.append(&quot;&lt;required/&gt;&quot;);</span>
            }
<span class="nc" id="L375">            sb.append(&quot;&lt;/starttls&gt;&quot;);</span>
        }
        // Include available SASL Mechanisms
<span class="nc" id="L378">        sb.append(SASLAuthentication.getSASLMechanisms(session));</span>
        // Include Stream features
<span class="nc" id="L380">        String specificFeatures = session.getAvailableStreamFeatures();</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">        if (specificFeatures != null) {</span>
<span class="nc" id="L382">            sb.append(specificFeatures);</span>
        }
<span class="nc" id="L384">        sb.append(&quot;&lt;/stream:features&gt;&quot;);</span>

<span class="nc" id="L386">        connection.deliverRawText(sb.toString());</span>
<span class="nc" id="L387">        return session;</span>
    }

    public static boolean isAllowed( Connection connection )
    {
        try
        {
<span class="nc" id="L394">            final String hostAddress = connection.getHostAddress();</span>
<span class="nc" id="L395">            final byte[] address = connection.getAddress();</span>

            // Blacklist takes precedence over whitelist.
<span class="nc bnc" id="L398" title="All 4 branches missed.">            if ( blockedIPs.contains( hostAddress ) || isAddressInRange( address, blockedIPs ) ) {</span>
<span class="nc" id="L399">                return false;</span>
            }

            // When there's a whitelist (not empty), you must be on it to be allowed.
<span class="nc bnc" id="L403" title="All 6 branches missed.">            return allowedIPs.isEmpty() || allowedIPs.contains( hostAddress ) || isAddressInRange( address, allowedIPs );</span>
        }
<span class="nc" id="L405">        catch ( UnknownHostException e )</span>
        {
<span class="nc" id="L407">            return false;</span>
        }
    }

    public static boolean isAllowedAnonymous( Connection connection )
    {
        try
        {
<span class="nc" id="L415">            final String hostAddress = connection.getHostAddress();</span>
<span class="nc" id="L416">            final byte[] address = connection.getAddress();</span>

            // Blacklist takes precedence over whitelist.
<span class="nc bnc" id="L419" title="All 4 branches missed.">            if ( blockedIPs.contains( hostAddress ) || isAddressInRange( address, blockedIPs ) ) {</span>
<span class="nc" id="L420">                return false;</span>
            }

            // When there's a whitelist (not empty), you must be on it to be allowed.
<span class="nc bnc" id="L424" title="All 6 branches missed.">            return allowedAnonymIPs.isEmpty() || allowedAnonymIPs.contains( hostAddress ) || isAddressInRange( address, allowedAnonymIPs );</span>
        }
<span class="nc" id="L426">        catch ( UnknownHostException e )</span>
        {
<span class="nc" id="L428">            return false;</span>
        }
    }

    // TODO Add IPv6 support
    public static boolean isAddressInRange( byte[] address, Set&lt;String&gt; ranges ) {
<span class="nc" id="L434">        final String range0 = (address[0] &amp; 0xff) + &quot;.&quot; + (address[1] &amp; 0xff) + &quot;.&quot; + (address[2] &amp; 0xff) + &quot;.&quot; + (address[3] &amp; 0xff);</span>
<span class="nc" id="L435">        final String range1 = (address[0] &amp; 0xff) + &quot;.&quot; + (address[1] &amp; 0xff) + &quot;.&quot; + (address[2] &amp; 0xff) + &quot;.*&quot;;</span>
<span class="nc" id="L436">        final String range2 = (address[0] &amp; 0xff) + &quot;.&quot; + (address[1] &amp; 0xff) + &quot;.*.*&quot;;</span>
<span class="nc" id="L437">        final String range3 = (address[0] &amp; 0xff) + &quot;.*.*.*&quot;;</span>
<span class="nc bnc" id="L438" title="All 8 branches missed.">        return ranges.contains(range0) || ranges.contains(range1) || ranges.contains(range2) || ranges.contains(range3);</span>
    }

    /**
     * Sets the list of IP address that are allowed to connect to the server. If the list is
     * empty then anyone is allowed to connect to the server except for anonymous users that are
     * subject to {@link #getAllowedAnonymIPs()}. This list is used for both anonymous and
     * non-anonymous users.
     *
     * @param allowed the list of IP address that are allowed to connect to the server.
     * @deprecated Use setWhitelistedIPs instead.
     */
    @Deprecated
    public static void setAllowedIPs(Map&lt;String, String&gt; allowed) {
<span class="nc" id="L452">        setWhitelistedIPs( allowed.keySet() );</span>
<span class="nc" id="L453">    }</span>

    /**
     * Sets the list of IP address that are allowed to connect to the server. If the list is empty then anyone not on
     * {@link #getBlacklistedIPs()} is  allowed to connect to the server except for anonymous users that are subject to
     * {@link #getWhitelistedAnonymousIPs()}. This list is used for both anonymous and non-anonymous users.
     *
     * Note that blacklisting takes precedence over whitelisting: if an address is matched by both, access is denied.
     *
     * @param allowed the list of IP address that are allowed to connect to the server. Can be empty, but not null.
     */
    public static void setWhitelistedIPs(Set&lt;String&gt; allowed) {
<span class="nc bnc" id="L465" title="All 2 branches missed.">        if (allowed == null) {</span>
<span class="nc" id="L466">            throw new NullPointerException();</span>
        }
<span class="nc" id="L468">        allowedIPs = allowed;</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">        if (allowedIPs.isEmpty()) {</span>
<span class="nc" id="L470">            JiveGlobals.deleteProperty(ConnectionSettings.Client.LOGIN_ALLOWED);</span>
        }
        else {
            // Iterate through the elements in the map.
<span class="nc" id="L474">            StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L475">            Iterator&lt;String&gt; iter = allowedIPs.iterator();</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">            if (iter.hasNext()) {</span>
<span class="nc" id="L477">                buf.append(iter.next());</span>
            }
<span class="nc bnc" id="L479" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L480">                buf.append(&quot;, &quot;).append(iter.next());</span>
            }
<span class="nc" id="L482">            JiveGlobals.setProperty(ConnectionSettings.Client.LOGIN_ALLOWED, buf.toString());</span>
        }
<span class="nc" id="L484">    }</span>

    /**
     * Sets the list of IP address that are allowed to connect to the server for anonymous
     * users. If the list is empty then anonymous will be only restricted by {@link #getAllowedIPs()}.
     *
     * @param allowed the list of IP address that are allowed to connect to the server.
     * @deprecated use #setWhitelistedAnonymousIPs instead.
     */
    @Deprecated
    public static void setAllowedAnonymIPs(Map&lt;String, String&gt; allowed) {
<span class="nc" id="L495">        setWhitelistedAnonymousIPs( allowed.keySet() );</span>
<span class="nc" id="L496">    }</span>

    /**
     * Sets the list of IP address that are allowed to connect to the server for anonymous users. If the list is empty
     * then anonymous will be only restricted by {@link #getBlacklistedIPs()} and {@link #getWhitelistedIPs()}.
     *
     * @param allowed the list of IP address that are allowed to connect to the server. Can be empty, but not null.
     */
    public static void setWhitelistedAnonymousIPs(Set&lt;String&gt; allowed) {
<span class="nc bnc" id="L505" title="All 2 branches missed.">        if (allowed == null) {</span>
<span class="nc" id="L506">            throw new NullPointerException();</span>
        }
<span class="nc" id="L508">        allowedAnonymIPs = allowed;</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">        if (allowedAnonymIPs.isEmpty()) {</span>
<span class="nc" id="L510">            JiveGlobals.deleteProperty(ConnectionSettings.Client.LOGIN_ANONYM_ALLOWED);</span>
        }
        else {
            // Iterate through the elements in the map.
<span class="nc" id="L514">            StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L515">            Iterator&lt;String&gt; iter = allowedAnonymIPs.iterator();</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">            if (iter.hasNext()) {</span>
<span class="nc" id="L517">                buf.append(iter.next());</span>
            }
<span class="nc bnc" id="L519" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L520">                buf.append(&quot;, &quot;).append(iter.next());</span>
            }
<span class="nc" id="L522">            JiveGlobals.setProperty(ConnectionSettings.Client.LOGIN_ANONYM_ALLOWED, buf.toString());</span>
        }
<span class="nc" id="L524">    }</span>

    /**
     * Sets the list of IP address that are not allowed to connect to the server. This list is used for both anonymous
     * and non-anonymous users, and always takes precedence over a whitelist.
     *
     * @param blocked the list of IP address that are not allowed to connect to the server. Can be empty, but not null.
     */
    public static void setBlacklistedIPs(Set&lt;String&gt; blocked) {
<span class="nc bnc" id="L533" title="All 2 branches missed.">        if (blocked == null) {</span>
<span class="nc" id="L534">            throw new NullPointerException();</span>
        }
<span class="nc" id="L536">        blockedIPs = blocked;</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (blockedIPs.isEmpty()) {</span>
<span class="nc" id="L538">            JiveGlobals.deleteProperty(ConnectionSettings.Client.LOGIN_BLOCKED);</span>
        }
        else {
            // Iterate through the elements in the map.
<span class="nc" id="L542">            StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L543">            Iterator&lt;String&gt; iter = blocked.iterator();</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">            if (iter.hasNext()) {</span>
<span class="nc" id="L545">                buf.append(iter.next());</span>
            }
<span class="nc bnc" id="L547" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L548">                buf.append(&quot;, &quot;).append(iter.next());</span>
            }
<span class="nc" id="L550">            JiveGlobals.setProperty(ConnectionSettings.Client.LOGIN_BLOCKED, buf.toString());</span>
        }
<span class="nc" id="L552">    }</span>

    /**
     * Returns the Privacy list that overrides the default privacy list. This list affects
     * only this session and only for the duration of the session.
     *
     * @return the Privacy list that overrides the default privacy list.
     */
    @Override
    public PrivacyList getActiveList() {
<span class="nc bnc" id="L562" title="All 2 branches missed.">        if (activeList != null) {</span>
            try {
<span class="nc" id="L564">                return PrivacyListManager.getInstance().getPrivacyList(getUsername(), activeList);</span>
<span class="nc" id="L565">            } catch (UserNotFoundException e) {</span>
<span class="nc" id="L566">                Log.error(e.getMessage(), e);</span>
            }
        }
<span class="nc" id="L569">        return null;</span>
    }

    /**
     * Sets the Privacy list that overrides the default privacy list. This list affects
     * only this session and only for the duration of the session.
     *
     * @param activeList the Privacy list that overrides the default privacy list.
     */
    @Override
    public void setActiveList(PrivacyList activeList) {
<span class="nc bnc" id="L580" title="All 2 branches missed.">        this.activeList = activeList != null ? activeList.getName() : null;</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">        if (ClusterManager.isClusteringStarted()) {</span>
            // Track information about the session and share it with other cluster nodes
<span class="nc" id="L583">            Cache&lt;String,ClientSessionInfo&gt; cache = SessionManager.getInstance().getSessionInfoCache();</span>
<span class="nc" id="L584">            cache.put(getAddress().toString(), new ClientSessionInfo(this));</span>
        }
<span class="nc" id="L586">    }</span>

    /**
     * Returns the default Privacy list used for the session's user. This list is
     * processed if there is no active list set for the session.
     *
     * @return the default Privacy list used for the session's user.
     */
    @Override
    public PrivacyList getDefaultList() {
<span class="nc bnc" id="L596" title="All 2 branches missed.">        if (defaultList != null) {</span>
            try {
<span class="nc" id="L598">                return PrivacyListManager.getInstance().getPrivacyList(getUsername(), defaultList);</span>
<span class="nc" id="L599">            } catch (UserNotFoundException e) {</span>
<span class="nc" id="L600">                Log.error(e.getMessage(), e);</span>
            }
        }
<span class="nc" id="L603">        return null;</span>
    }

    /**
     * Sets the default Privacy list used for the session's user. This list is
     * processed if there is no active list set for the session.
     *
     * @param defaultList the default Privacy list used for the session's user.
     */
    @Override
    public void setDefaultList(PrivacyList defaultList) {
        // Do nothing if nothing has changed
<span class="nc bnc" id="L615" title="All 6 branches missed.">        if ((this.defaultList == null &amp;&amp; defaultList == null) ||</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">                (defaultList != null &amp;&amp; defaultList.getName().equals(this.defaultList))) {</span>
<span class="nc" id="L617">            return;</span>
        }
<span class="nc bnc" id="L619" title="All 2 branches missed.">        this.defaultList = defaultList != null ? defaultList.getName() : null;</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">        if (ClusterManager.isClusteringStarted()) {</span>
            // Track information about the session and share it with other cluster nodes
<span class="nc" id="L622">            Cache&lt;String,ClientSessionInfo&gt; cache = SessionManager.getInstance().getSessionInfoCache();</span>
<span class="nc" id="L623">            cache.put(getAddress().toString(), new ClientSessionInfo(this));</span>
        }
<span class="nc" id="L625">    }</span>

    /**
     * Creates a session with an underlying connection and permission protection.
     *
     * @param serverName name of the server.
     * @param connection The connection we are proxying.
     * @param streamID unique identifier of this session.
     * @param language the language
     */
    public LocalClientSession(String serverName, Connection connection, StreamID streamID, Locale language) {
<span class="nc" id="L636">        super(serverName, connection, streamID, language);</span>
        // Set an unavailable initial presence
<span class="nc" id="L638">        presence = new Presence();</span>
<span class="nc" id="L639">        presence.setType(Presence.Type.unavailable);</span>
<span class="nc" id="L640">    }</span>

    /**
     * Returns the username associated with this session. Use this information
     * with the user manager to obtain the user based on username.
     *
     * @return the username associated with this session
     * @throws org.jivesoftware.openfire.user.UserNotFoundException if a user is not associated with a session
     *      (the session has not authenticated yet)
     */
    @Override
    public String getUsername() throws UserNotFoundException {
<span class="nc bnc" id="L652" title="All 2 branches missed.">        if (authToken == null) {</span>
<span class="nc" id="L653">            throw new UserNotFoundException();</span>
        }
<span class="nc" id="L655">        return getAddress().getNode();</span>
    }

    /**
     * Sets the new Authorization Token for this session. The session is not yet considered fully
     * authenticated (i.e. active) since a resource has not been binded at this point. This
     * message will be sent after SASL authentication was successful but yet resource binding
     * is required.
     *
     * @param auth the authentication token obtained from SASL authentication.
     */
    public void setAuthToken(AuthToken auth) {
<span class="nc" id="L667">        authToken = auth;</span>
<span class="nc" id="L668">    }</span>

    /**
     * Initialize the session with a valid authentication token and
     * resource name. This automatically upgrades the session's
     * status to authenticated and enables many features that are not
     * available until authenticated (obtaining managers for example).
     *
     * @param auth the authentication token obtained from the AuthFactory.
     * @param resource the resource this session authenticated under.
     */
    public void setAuthToken(AuthToken auth, String resource) {
        final JID jid;
<span class="nc bnc" id="L681" title="All 2 branches missed.">        if (auth.isAnonymous()) {</span>
<span class="nc" id="L682">            jid = new JID(resource, getServerName(), resource);</span>
        } else {
<span class="nc" id="L684">            jid = new JID(auth.getUsername(), getServerName(), resource);</span>
        }
<span class="nc" id="L686">        setAddress(jid);</span>
<span class="nc" id="L687">        authToken = auth;</span>
<span class="nc" id="L688">        setStatus(Session.STATUS_AUTHENTICATED);</span>

        // Set default privacy list for this session
<span class="nc bnc" id="L691" title="All 2 branches missed.">        if (!auth.isAnonymous()) {</span>
<span class="nc" id="L692">            setDefaultList( PrivacyListManager.getInstance().getDefaultPrivacyList( auth.getUsername() ) );</span>
        }
        // Add session to the session manager. The session will be added to the routing table as well
<span class="nc" id="L695">        sessionManager.addSession(this);</span>
<span class="nc" id="L696">    }</span>

    /**
     * Initialize the session as an anonymous login. This automatically upgrades the session's
     * status to authenticated and enables many features that are not available until
     * authenticated (obtaining managers for example).
     */
    public void setAnonymousAuth() {
        // Anonymous users have a full JID. Use the random resource as the JID's node
<span class="nc" id="L705">        String resource = getAddress().getResource();</span>
<span class="nc" id="L706">        setAddress(new JID(resource, getServerName(), resource, true));</span>
<span class="nc" id="L707">        setStatus(Session.STATUS_AUTHENTICATED);</span>
<span class="nc" id="L708">        authToken = AuthToken.generateAnonymousToken();</span>
        // Add session to the session manager. The session will be added to the routing table as well
<span class="nc" id="L710">        sessionManager.addSession(this);</span>
<span class="nc" id="L711">    }</span>

    /**
     * Returns the authentication token associated with this session.
     *
     * @return the authentication token associated with this session (can be null).
     */
    public AuthToken getAuthToken() {
<span class="nc" id="L719">        return authToken;</span>
    }

    @Override
    public boolean isAnonymousUser() {
<span class="nc bnc" id="L724" title="All 4 branches missed.">        return authToken == null || authToken.isAnonymous();</span>
    }

    /**
     * Flag indicating if this session has been initialized once coming
     * online. Session initialization occurs after the session receives
     * the first &quot;available&quot; presence update from the client. Initialization
     * actions include pushing offline messages, presence subscription requests,
     * and presence statuses to the client. Initialization occurs only once
     * following the first available presence transition.
     *
     * @return True if the session has already been initializsed
     */
    @Override
    public boolean isInitialized() {
<span class="nc" id="L739">        return initialized;</span>
    }

    /**
     * Sets the initialization state of the session.
     *
     * @param isInit True if the session has been initialized
     * @see #isInitialized
     */
    @Override
    public void setInitialized(boolean isInit) {
<span class="nc" id="L750">        initialized = isInit;</span>
<span class="nc" id="L751">    }</span>

    /**
     * Returns true if the session was available ever.
     *
     * @return true if the session was available ever.
     */
    public boolean wasAvailable() {
<span class="nc" id="L759">        return wasAvailable;</span>
    }

    /**
     * Returns true if the offline messages of the user should be sent to the user when
     * the user becomes online. If the user sent a disco request with node
     * &quot;http://jabber.org/protocol/offline&quot; before the available presence then do not
     * flood the user with the offline messages. If the user is connected from many resources
     * then if one of the sessions stopped the flooding then no session should flood the user.
     *
     * @return true if the offline messages of the user should be sent to the user when the user
     *         becomes online.
     * @see &lt;a href=&quot;http://www.xmpp.org/extensions/xep-0160.html&quot;&gt;XEP-0160: Best Practices for Handling Offline Messages&lt;/a&gt;
     */
    @Override
    public boolean canFloodOfflineMessages() {
        // XEP-0160: When the recipient next sends non-negative available presence to the server, the server delivers the message to the resource that has sent that presence.
<span class="nc bnc" id="L776" title="All 4 branches missed.">        if(offlineFloodStopped || presence.getPriority() &lt; 0) {</span>
<span class="nc" id="L777">            return false;</span>
        }
<span class="nc" id="L779">        String username = getAddress().getNode();</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">        for (ClientSession session : sessionManager.getSessions(username)) {</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">            if (session.isOfflineFloodStopped()) {</span>
<span class="nc" id="L782">                return false;</span>
            }
<span class="nc" id="L784">        }</span>
<span class="nc" id="L785">        return true;</span>
    }

    /**
     * Returns true if the user requested to not receive offline messages when sending
     * an available presence. The user may send a disco request with node
     * &quot;http://jabber.org/protocol/offline&quot; so that no offline messages are sent to the
     * user when he becomes online. If the user is connected from many resources then
     * if one of the sessions stopped the flooding then no session should flood the user.
     *
     * @return true if the user requested to not receive offline messages when sending
     *         an available presence.
     */
    @Override
    public boolean isOfflineFloodStopped() {
<span class="nc" id="L800">        return offlineFloodStopped;</span>
    }

    /**
     * Sets if the user requested to not receive offline messages when sending
     * an available presence. The user may send a disco request with node
     * &quot;http://jabber.org/protocol/offline&quot; so that no offline messages are sent to the
     * user when he becomes online. If the user is connected from many resources then
     * if one of the sessions stopped the flooding then no session should flood the user.
     *
     * @param offlineFloodStopped if the user requested to not receive offline messages when
     *        sending an available presence.
     */
    public void setOfflineFloodStopped(boolean offlineFloodStopped) {
<span class="nc" id="L814">        this.offlineFloodStopped = offlineFloodStopped;</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">        if (ClusterManager.isClusteringStarted()) {</span>
            // Track information about the session and share it with other cluster nodes
<span class="nc" id="L817">            Cache&lt;String,ClientSessionInfo&gt; cache = SessionManager.getInstance().getSessionInfoCache();</span>
<span class="nc" id="L818">            cache.put(getAddress().toString(), new ClientSessionInfo(this));</span>
        }
<span class="nc" id="L820">    }</span>

    /**
     * Obtain the presence of this session.
     *
     * @return The presence of this session or null if not authenticated
     */
    @Override
    public Presence getPresence() {
<span class="nc" id="L829">        return presence;</span>
    }

    /**
     * Set the presence of this session
     *
     * @param presence The presence for the session
     */
    @Override
    public void setPresence(Presence presence) {
<span class="nc" id="L839">        Presence oldPresence = this.presence;</span>
<span class="nc" id="L840">        this.presence = presence;</span>
<span class="nc bnc" id="L841" title="All 4 branches missed.">        if (oldPresence.isAvailable() &amp;&amp; !this.presence.isAvailable()) {</span>
            // The client is no longer available
<span class="nc" id="L843">            sessionManager.sessionUnavailable(this);</span>
            // Mark that the session is no longer initialized. This means that if the user sends
            // an available presence again the session will be initialized again thus receiving
            // offline messages and offline presence subscription requests
<span class="nc" id="L847">            setInitialized(false);</span>
            // Notify listeners that the session is no longer available
<span class="nc" id="L849">            PresenceEventDispatcher.unavailableSession(this, presence);</span>
        }
<span class="nc bnc" id="L851" title="All 4 branches missed.">        else if (!oldPresence.isAvailable() &amp;&amp; this.presence.isAvailable()) {</span>
            // The client is available
<span class="nc" id="L853">            sessionManager.sessionAvailable(this, presence);</span>
<span class="nc" id="L854">            wasAvailable = true;</span>
            // Notify listeners that the session is now available
<span class="nc" id="L856">            PresenceEventDispatcher.availableSession(this, presence);</span>
        }
<span class="nc bnc" id="L858" title="All 4 branches missed.">        else if (this.presence.isAvailable() &amp;&amp; oldPresence.getPriority() != this.presence.getPriority())</span>
        {
            // The client has changed the priority of his presence
<span class="nc" id="L861">            sessionManager.changePriority(this, oldPresence.getPriority());</span>
            // Notify listeners that the priority of the session/resource has changed
<span class="nc" id="L863">            PresenceEventDispatcher.presenceChanged(this, presence);</span>
        }
<span class="nc bnc" id="L865" title="All 2 branches missed.">        else if (this.presence.isAvailable()) {</span>
            // Notify listeners that the show or status value of the presence has changed
<span class="nc" id="L867">            PresenceEventDispatcher.presenceChanged(this, presence);</span>
        }
<span class="nc bnc" id="L869" title="All 2 branches missed.">        if (ClusterManager.isClusteringStarted()) {</span>
            // Track information about the session and share it with other cluster nodes
<span class="nc" id="L871">            Cache&lt;String,ClientSessionInfo&gt; cache = SessionManager.getInstance().getSessionInfoCache();</span>
<span class="nc" id="L872">            cache.put(getAddress().toString(), new ClientSessionInfo(this));</span>
        }
<span class="nc" id="L874">    }</span>

    @Override
    public String getAvailableStreamFeatures() {
        // Offer authenticate and registration only if TLS was not required or if required
        // then the connection is already secured
<span class="nc bnc" id="L880" title="All 4 branches missed.">        if (conn.getTlsPolicy() == Connection.TLSPolicy.required &amp;&amp; !conn.isSecure()) {</span>
<span class="nc" id="L881">            return null;</span>
        }

<span class="nc" id="L884">        StringBuilder sb = new StringBuilder(200);</span>

        // Include Stream Compression Mechanism
<span class="nc bnc" id="L887" title="All 2 branches missed.">        if (conn.getCompressionPolicy() != Connection.CompressionPolicy.disabled &amp;&amp;</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">                !conn.isCompressed()) {</span>
<span class="nc" id="L889">            sb.append(</span>
                    &quot;&lt;compression xmlns=\&quot;http://jabber.org/features/compress\&quot;&gt;&lt;method&gt;zlib&lt;/method&gt;&lt;/compression&gt;&quot;);
        }

        // If a server supports roster versioning, 
        // then it MUST advertise the following stream feature during stream negotiation.
<span class="nc bnc" id="L895" title="All 2 branches missed.">        if (RosterManager.isRosterVersioningEnabled()) {</span>
<span class="nc" id="L896">            sb.append(&quot;&lt;ver xmlns=\&quot;urn:xmpp:features:rosterver\&quot;/&gt;&quot;);</span>
        }

<span class="nc bnc" id="L899" title="All 2 branches missed.">        if (getAuthToken() == null) {</span>
            // Advertise that the server supports Non-SASL Authentication
<span class="nc bnc" id="L901" title="All 2 branches missed.">            if ( XMPPServer.getInstance().getIQRouter().supports( &quot;jabber:iq:auth&quot; ) ) {</span>
<span class="nc" id="L902">                sb.append(&quot;&lt;auth xmlns=\&quot;http://jabber.org/features/iq-auth\&quot;/&gt;&quot;);</span>
            }
            // Advertise that the server supports In-Band Registration
<span class="nc bnc" id="L905" title="All 2 branches missed.">            if (XMPPServer.getInstance().getIQRegisterHandler().isInbandRegEnabled()) {</span>
<span class="nc" id="L906">                sb.append(&quot;&lt;register xmlns=\&quot;http://jabber.org/features/iq-register\&quot;/&gt;&quot;);</span>
            }
        }
        else {
            // If the session has been authenticated then offer resource binding,
            // and session establishment
<span class="nc" id="L912">            sb.append(&quot;&lt;bind xmlns=\&quot;urn:ietf:params:xml:ns:xmpp-bind\&quot;/&gt;&quot;);</span>
<span class="nc" id="L913">            sb.append(&quot;&lt;session xmlns=\&quot;urn:ietf:params:xml:ns:xmpp-session\&quot;&gt;&lt;optional/&gt;&lt;/session&gt;&quot;);</span>

            // Offer XEP-0198 stream management capabilities if enabled.
<span class="nc bnc" id="L916" title="All 2 branches missed.">            if(StreamManager.isStreamManagementActive()) {</span>
<span class="nc" id="L917">                sb.append(String.format(&quot;&lt;sm xmlns='%s'/&gt;&quot;, StreamManager.NAMESPACE_V2));</span>
<span class="nc" id="L918">                sb.append(String.format(&quot;&lt;sm xmlns='%s'/&gt;&quot;, StreamManager.NAMESPACE_V3));</span>
            }
        }

        // Add XEP-0115 entity capabilities for the server, so that peer can skip service discovery.
<span class="nc" id="L923">        final String ver = EntityCapabilitiesManager.getLocalDomainVerHash();</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">        if ( ver != null ) {</span>
<span class="nc" id="L925">            sb.append( String.format( &quot;&lt;c xmlns=\&quot;http://jabber.org/protocol/caps\&quot; hash=\&quot;sha-1\&quot; node=\&quot;%s\&quot; ver=\&quot;%s\&quot;/&gt;&quot;, EntityCapabilitiesManager.OPENFIRE_IDENTIFIER_NODE, ver ) );</span>
        }

<span class="nc" id="L928">        return sb.toString();</span>
    }

    /**
     * Increments the conflict by one.
     */
    @Override
    public int incrementConflictCount() {
<span class="nc" id="L936">        conflictCount++;</span>
<span class="nc" id="L937">        return conflictCount;</span>
    }

    @Override
    public boolean isMessageCarbonsEnabled() {
<span class="nc" id="L942">        return messageCarbonsEnabled;</span>
    }

    @Override
    public void setMessageCarbonsEnabled(boolean enabled) {
<span class="nc" id="L947">        messageCarbonsEnabled = enabled;</span>
<span class="nc" id="L948">    }</span>

    @Override
    public boolean hasRequestedBlocklist() {
<span class="nc" id="L952">        return hasRequestedBlocklist;</span>
    }

    @Override
    public void setHasRequestedBlocklist(boolean hasRequestedBlocklist) {
<span class="nc" id="L957">        this.hasRequestedBlocklist = hasRequestedBlocklist;</span>
<span class="nc" id="L958">    }</span>

    /**
     * Returns true if the specified packet must not be blocked based on the active or default
     * privacy list rules. The active list will be tried first. If none was found then the
     * default list is going to be used. If no default list was defined for this user then
     * allow the packet to flow.
     *
     * @param packet the packet to analyze if it must be blocked.
     * @return true if the specified packet must be blocked.
     */
    @Override
    public boolean canProcess(Packet packet) {

<span class="nc" id="L972">        PrivacyList list = getActiveList();</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">        if (list != null) {</span>
            // If a privacy list is active then make sure that the packet is not blocked
<span class="nc bnc" id="L975" title="All 2 branches missed.">            return !list.shouldBlockPacket(packet);</span>
        }
        else {
<span class="nc" id="L978">            list = getDefaultList();</span>
            // There is no active list so check if there exists a default list and make
            // sure that the packet is not blocked
<span class="nc bnc" id="L981" title="All 4 branches missed.">            return list == null || !list.shouldBlockPacket(packet);</span>
        }
    }

    @Override
    public void deliver(Packet packet) throws UnauthorizedException {
<span class="nc bnc" id="L987" title="All 2 branches missed.">        if (conn != null) {</span>
<span class="nc" id="L988">            conn.deliver(packet);</span>
        }
<span class="nc" id="L990">        streamManager.sentStanza(packet);</span>
<span class="nc" id="L991">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L995">        return super.toString() + &quot; presence: &quot; + presence;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>