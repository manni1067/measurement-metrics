<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DbConnectionManager.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Core XMPP Server</a> &gt; <a href="index.source.html" class="el_package">org.jivesoftware.database</a> &gt; <span class="el_source">DbConnectionManager.java</span></div><h1>DbConnectionManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2004-2008 Jive Software. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jivesoftware.database;

import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;
import java.util.HashSet;
import java.util.MissingResourceException;

import org.jivesoftware.util.ClassUtils;
import org.jivesoftware.util.JiveGlobals;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Central manager of database connections. All methods are static so that they
 * can be easily accessed throughout the classes in the database package.&lt;p&gt;
 *
 * This class also provides a set of utility methods that abstract out
 * operations that may not work on all databases such as setting the max number
 * or rows that a query should return.
 *
 * @author Jive Software
 * @see ConnectionProvider
 */
<span class="nc" id="L48">public class DbConnectionManager {</span>

<span class="fc" id="L50">    private static final Logger Log = LoggerFactory.getLogger(DbConnectionManager.class);</span>

    private static ConnectionProvider connectionProvider;
<span class="fc" id="L53">    private static final Object providerLock = new Object();</span>

    // True if connection profiling is turned on. Always false by default.
<span class="fc" id="L56">    private static boolean profilingEnabled = false;</span>

    // True if the database support transactions.
    private static boolean transactionsSupported;
    // True if the database requires large text fields to be streamed.
    private static boolean streamTextRequired;
    /** True if the database supports the Statement.setMaxRows() method. */
    private static boolean maxRowsSupported;
    /** True if the database supports the rs.setFetchSize() method. */
    private static boolean fetchSizeSupported;
    // True if the database supports correlated subqueries.
    private static boolean subqueriesSupported;
    // True if the database supports scroll-insensitive results.
    private static boolean scrollResultsSupported;
    // True if the database supports batch updates.
    private static boolean batchUpdatesSupported;
    /** True if the database supports the Statement.setFetchSize()) method. */
<span class="fc" id="L73">    private static boolean pstmt_fetchSizeSupported = true;</span>
    /** The char used to quote identifiers */
    private static String identifierQuoteString;

    private static final String SETTING_DATABASE_MAX_RETRIES = &quot;database.maxRetries&quot;;
    private static final String SETTING_DATABASE_RETRY_DELAY = &quot;database.retryDelay&quot;;

<span class="fc" id="L80">    private static DatabaseType databaseType = DatabaseType.unknown;</span>

<span class="fc" id="L82">    private static SchemaManager schemaManager = new SchemaManager();</span>

    /**
     * Ensures that the connection provider exists and is set
     */
    private static void ensureConnectionProvider() {
<span class="fc bfc" id="L88" title="All 2 branches covered.">        if (connectionProvider != null) return;</span>
        
<span class="fc" id="L90">        synchronized (providerLock) {</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">            if (connectionProvider != null) return;</span>
            
            // Attempt to load the connection provider classname as a Jive property.
<span class="nc" id="L94">            String className = JiveGlobals.getXMLProperty(&quot;connectionProvider.className&quot;);</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">            if (className != null) {</span>
                // Attempt to load the class.
                try {
<span class="nc" id="L98">                    Class conClass = ClassUtils.forName(className);</span>
<span class="nc" id="L99">                    setConnectionProvider((ConnectionProvider)conClass.newInstance());</span>
<span class="nc" id="L100">                } catch (Exception e) {</span>
<span class="nc" id="L101">                    Log.warn(&quot;Failed to create the &quot; +</span>
                            &quot;connection provider specified by connection&quot; +
                            &quot;Provider.className. Using the default pool.&quot;, e);
<span class="nc" id="L104">                    setConnectionProvider(new DefaultConnectionProvider());</span>
<span class="nc" id="L105">                }</span>
            } else {
<span class="nc" id="L107">                setConnectionProvider(new DefaultConnectionProvider());</span>
            }
<span class="pc" id="L109">        }</span>
<span class="nc" id="L110">    }</span>

    /**
     * Returns a database connection from the currently active connection
     * provider. An exception will be thrown if no connection was found.
     * (auto commit is set to true).
     *
     * @return a connection.
     * @throws SQLException if a SQL exception occurs or no connection was found.
     */
    public static Connection getConnection() throws SQLException {
<span class="fc" id="L121">        ensureConnectionProvider();</span>

<span class="fc" id="L123">        Integer currentRetryCount = 0;</span>
<span class="fc" id="L124">        Integer maxRetries = JiveGlobals.getXMLProperty(SETTING_DATABASE_MAX_RETRIES, 10);</span>
<span class="fc" id="L125">        Integer retryWait = JiveGlobals.getXMLProperty(SETTING_DATABASE_RETRY_DELAY, 250); // milliseconds</span>
<span class="fc" id="L126">        SQLException lastException = null;</span>
<span class="fc" id="L127">        boolean loopIfNoConnection = false;</span>
        do {
            try {
<span class="nc" id="L130">                Connection con = connectionProvider.getConnection();</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">                if (con != null) {</span>
                    // Got one, lets hand it off.
                    // Usually profiling is not enabled. So we return a normal 
                    // connection unless profiling is enabled. If yes, wrap the
                    // connection with a profiled connection.
<span class="nc bnc" id="L136" title="All 2 branches missed.">                    if (!profilingEnabled) {</span>
<span class="nc" id="L137">                        return con;</span>
                    } else {
<span class="nc" id="L139">                        return new ProfiledConnection(con); </span>
                    }
                }
<span class="fc" id="L142">            } catch (SQLException e) {</span>
                // TODO distinguish recoverable from non-recoverable exceptions.
<span class="fc" id="L144">                lastException = e;</span>
<span class="fc" id="L145">                Log.info(&quot;Unable to get a connection from the database pool &quot; +</span>
                        &quot;(attempt &quot; + currentRetryCount + &quot; out of &quot; + maxRetries + &quot;).&quot;, e);
<span class="nc" id="L147">            }</span>
            
<span class="fc" id="L149">            currentRetryCount++;</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">            loopIfNoConnection = currentRetryCount &lt;= maxRetries;</span>
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">            if (loopIfNoConnection) {</span>
                try {
<span class="nc" id="L153">                    Thread.sleep(retryWait);</span>
<span class="nc" id="L154">                } catch (InterruptedException ex) {</span>
<span class="nc" id="L155">                    String msg = &quot;Interrupted waiting for DB connection&quot;;</span>
<span class="nc" id="L156">                    Log.info(msg,ex);</span>
<span class="nc" id="L157">                    Thread.currentThread().interrupt();</span>
<span class="nc" id="L158">                    throw new SQLException(msg,ex);</span>
<span class="nc" id="L159">                }</span>
            }
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        } while (loopIfNoConnection);</span>
        
<span class="fc" id="L163">        throw new SQLException(&quot;ConnectionManager.getConnection() &quot; +</span>
                &quot;failed to obtain a connection after &quot; + currentRetryCount + &quot; retries. &quot; +
                &quot;The exception from the last attempt is as follows: &quot; + lastException);
    }

    /**
     * Returns a Connection from the currently active connection provider that
     * is ready to participate in transactions (auto commit is set to false).
     *
     * @return a connection with transactions enabled.
     * @throws SQLException if a SQL exception occurs.
     */
    public static Connection getTransactionConnection() throws SQLException {
<span class="nc" id="L176">        Connection con = getConnection();</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (isTransactionsSupported()) {</span>
<span class="nc" id="L178">            con.setAutoCommit(false);</span>
        }
<span class="nc" id="L180">        return con;</span>
    }

    /**
     * Closes a PreparedStatement and Connection. However, it first rolls back the transaction or
     * commits it depending on the value of &lt;code&gt;abortTransaction&lt;/code&gt;.
     *
     * @param pstmt the prepared statement to close.
     * @param con the connection to close.
     * @param abortTransaction true if the transaction should be rolled back.
     */
    public static void closeTransactionConnection(PreparedStatement pstmt, Connection con,
            boolean abortTransaction)
    {
<span class="nc" id="L194">        closeStatement(pstmt);</span>
<span class="nc" id="L195">        closeTransactionConnection(con, abortTransaction);</span>
<span class="nc" id="L196">    }</span>

    /**
     * Closes a Connection. However, it first rolls back the transaction or
     * commits it depending on the value of &lt;code&gt;abortTransaction&lt;/code&gt;.
     *
     * @param con the connection to close.
     * @param abortTransaction true if the transaction should be rolled back.
     */
    public static void closeTransactionConnection(Connection con, boolean abortTransaction) {
        // Rollback or commit the transaction
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (isTransactionsSupported()) {</span>
            try {
<span class="nc bnc" id="L209" title="All 2 branches missed.">                if (abortTransaction) {</span>
<span class="nc" id="L210">                    con.rollback();</span>
                }
                else {
<span class="nc" id="L213">                    con.commit();</span>
                }
            }
<span class="nc" id="L216">            catch (Exception e) {</span>
<span class="nc" id="L217">                Log.error(e.getMessage(), e);</span>
<span class="nc" id="L218">            }</span>
            // Reset the connection to auto-commit mode.
            try {
<span class="nc" id="L221">                con.setAutoCommit(true);              </span>
            }
<span class="nc" id="L223">            catch (Exception e) {</span>
<span class="nc" id="L224">                Log.error(e.getMessage(), e);</span>
<span class="nc" id="L225">            }</span>
        }
<span class="nc" id="L227">        closeConnection(con);</span>
<span class="nc" id="L228">    }</span>

    /**
     * Closes a result set. This method should be called within the finally section of
     * your database logic, as in the following example:
     *
     * &lt;pre&gt;
     *  public void doSomething(Connection con) {
     *      ResultSet rs = null;
     *      PreparedStatement pstmt = null;
     *      try {
     *          pstmt = con.prepareStatement(&quot;select * from blah&quot;);
     *          rs = pstmt.executeQuery();
     *          ....
     *      }
     *      catch (SQLException sqle) {
     *          Log.error(sqle.getMessage(), sqle);
     *      }
     *      finally {
     *          ConnectionManager.closeResultSet(rs);
     *          ConnectionManager.closePreparedStatement(pstmt);
     *      }
     * } &lt;/pre&gt;
     *
     * @param rs the result set to close.
     */
    public static void closeResultSet(ResultSet rs) {
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        if (rs != null) {</span>
            try {
<span class="nc" id="L257">                    rs.close();</span>
                }
<span class="nc" id="L259">            catch (SQLException e) {</span>
<span class="nc" id="L260">                Log.error(e.getMessage(), e);</span>
<span class="nc" id="L261">            }</span>
        }
<span class="fc" id="L263">    }</span>

    /**
     * Closes a statement. This method should be called within the finally section of
     * your database logic, as in the following example:
     *
     * &lt;pre&gt;
     *  public void doSomething(Connection con) {
     *      PreparedStatement pstmt = null;
     *      try {
     *          pstmt = con.prepareStatement(&quot;select * from blah&quot;);
     *          ....
     *      }
     *      catch (SQLException sqle) {
     *          Log.error(sqle.getMessage(), sqle);
     *      }
     *      finally {
     *          ConnectionManager.closeStatement(pstmt);
     *      }
     * } &lt;/pre&gt;
     *
     * @param stmt the statement.
     */
    public static void closeStatement(Statement stmt) {
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">        if (stmt != null) {</span>
            try {
<span class="nc" id="L289">                stmt.close();</span>
            }       
<span class="nc" id="L291">            catch (Exception e) {</span>
<span class="nc" id="L292">                Log.error(e.getMessage(), e);</span>
<span class="nc" id="L293">            }</span>
        }
<span class="fc" id="L295">    }</span>
    
    /**
     * Closes a statement and a result set. This method should be called within the finally section of
     * your database logic, as in the following example:
     *
     * &lt;pre&gt;
     *  public void doSomething(Connection con) {
     *      PreparedStatement pstmt = null;
     *      ResultSet rs = null;
     *      try {
     *          pstmt = con.prepareStatement(&quot;select * from blah&quot;);
     *          rs = ...
     *          ....
     *      }
     *      catch (SQLException sqle) {
     *          Log.error(sqle.getMessage(), sqle);
     *      }
     *      finally {
     *          ConnectionManager.closeStatement(rs, pstmt);
     *      }
     * } &lt;/pre&gt;
     *
     * @param rs the result set to close
     * @param stmt the statement.
     */
    public static void closeStatement(ResultSet rs, Statement stmt) {
<span class="nc" id="L322">        closeResultSet(rs);</span>
<span class="nc" id="L323">        closeStatement(stmt);</span>
<span class="nc" id="L324">    }</span>
    /**
     * Closes a statement. This method should be called within the try section of
     * your database logic when you reuse a statement. It may throws an exception,
     * so don't place it in the finally section.&lt;br&gt;
     * Example:
     *
     * &lt;pre&gt;
     *  public void doSomething(Connection con) {
     *      PreparedStatement pstmt = null;
     *      try {
     *          pstmt = con.prepareStatement(&quot;select * from dual&quot;);
     *          pstmt.executeUpdate();
     *          ...
     *          &lt;b&gt;ConnectionManager.fastcloseStmt(pstmt);&lt;/b&gt;
     *          pstmt = con.prepareStatement(&quot;select * from blah&quot;);
     *          ...
     *      }
     *      ...
     * } &lt;/pre&gt;
     *
     * @param pstmt the statement to close.
     * @throws SQLException if an exception occurs closing the statement
     */
    public static void fastcloseStmt(PreparedStatement pstmt) throws SQLException
    {
<span class="nc" id="L350">        pstmt.close();</span>
<span class="nc" id="L351">    }</span>
        
    /**
     * Closes a statement and a result set. This method should be called within the try section of
     * your database logic when you reuse a statement. It may throw an exception,
     * so don't place it in the finally section.&lt;br&gt;
     * Example:
     *
     * &lt;pre&gt;
     *  public void doSomething(Connection con) {
     *      PreparedStatement pstmt = null;
     *      try {
     *          pstmt = con.prepareStatement(&quot;select * from blah&quot;);
     *          rs = pstmt.executeQuery();
     *          ...
     *          ConnectionManager.fastcloseStmt(rs, pstmt);
     *          pstmt = con.prepareStatement(&quot;select * from blah&quot;);
     *          ...
     *      }
     *      ...
     * } &lt;/pre&gt;
     *
     * @param rs The result set to close
     * @param pstmt the statement to close.
     * @throws SQLException if an exception occurs closing the result set or statement
     */
    public static void fastcloseStmt(ResultSet rs, PreparedStatement pstmt) throws SQLException
    {
<span class="nc" id="L379">        rs.close();</span>
<span class="nc" id="L380">        pstmt.close();</span>
<span class="nc" id="L381">    }</span>

    /**
     * Closes a result set, statement and database connection (returning the connection to
     * the connection pool). This method should be called within the finally section of
     * your database logic, as in the following example:
     *
     * &lt;pre&gt;
     * Connection con = null;
     * PrepatedStatment pstmt = null;
     * ResultSet rs = null;
     * try {
     *     con = ConnectionManager.getConnection();
     *     pstmt = con.prepareStatement(&quot;select * from blah&quot;);
     *     rs = psmt.executeQuery();
     *     ....
     * }
     * catch (SQLException sqle) {
     *     Log.error(sqle.getMessage(), sqle);
     * }
     * finally {
     *     ConnectionManager.closeConnection(rs, pstmt, con);
     * }&lt;/pre&gt;
     *
     * @param rs the result set.
     * @param stmt the statement.
     * @param con the connection.
     */
    public static void closeConnection(ResultSet rs, Statement stmt, Connection con) {
<span class="fc" id="L410">        closeResultSet(rs);</span>
<span class="fc" id="L411">        closeStatement(stmt);</span>
<span class="fc" id="L412">        closeConnection(con);</span>
<span class="fc" id="L413">    }</span>

    /**
     * Closes a statement and database connection (returning the connection to
     * the connection pool). This method should be called within the finally section of
     * your database logic, as in the following example:
     * &lt;pre&gt;
     * Connection con = null;
     * PrepatedStatment pstmt = null;
     * try {
     *     con = ConnectionManager.getConnection();
     *     pstmt = con.prepareStatement(&quot;select * from blah&quot;);
     *     ....
     * }
     * catch (SQLException sqle) {
     *     Log.error(sqle.getMessage(), sqle);
     * }
     * finally {
     *     DbConnectionManager.closeConnection(pstmt, con);
     * }&lt;/pre&gt;
     *
     * @param stmt the statement.
     * @param con the connection.
     */
    public static void closeConnection(Statement stmt, Connection con) {
<span class="fc" id="L438">        closeStatement(stmt);</span>
<span class="fc" id="L439">        closeConnection(con);</span>
<span class="fc" id="L440">    }</span>

    /**
     * Closes a database connection (returning the connection to the connection pool). Any
     * statements associated with the connection should be closed before calling this method.
     * This method should be called within the finally section of your database logic, as
     * in the following example:
     * &lt;pre&gt;
     * Connection con = null;
     * try {
     *     con = ConnectionManager.getConnection();
     *     ....
     * }
     * catch (SQLException sqle) {
     *     Log.error(sqle.getMessage(), sqle);
     * }
     * finally {
     *     DbConnectionManager.closeConnection(con);
     * }&lt;/pre&gt;
     *
     * @param con the connection.
     */
    public static void closeConnection(Connection con) {
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">        if (con != null) {</span>
            try {
<span class="nc" id="L465">               con.close();</span>
            }
<span class="nc" id="L467">            catch (Exception e) {</span>
<span class="nc" id="L468">                Log.error(e.getMessage(), e);</span>
<span class="nc" id="L469">            }</span>
        }
<span class="fc" id="L471">    }</span>

    /**
     * Creates a scroll insensitive PreparedStatement if the JDBC driver supports it, or a normal
     * PreparedStatement otherwise.
     *
     * @param con the database connection.
     * @param sql the SQL to create the PreparedStatement with.
     * @return a PreparedStatement
     * @throws java.sql.SQLException if an error occurs.
     */
    public static PreparedStatement createScrollablePreparedStatement(Connection con, String sql)
            throws SQLException {
<span class="nc bnc" id="L484" title="All 2 branches missed.">        if (isScrollResultsSupported()) {</span>
<span class="nc" id="L485">            return con.prepareStatement(sql, ResultSet.TYPE_SCROLL_INSENSITIVE,</span>
                    ResultSet.CONCUR_READ_ONLY);
        }
        else {
<span class="nc" id="L489">            return con.prepareStatement(sql);</span>
        }
    }

    /**
     * Scrolls forward in a result set the specified number of rows. If the JDBC driver
     * supports the feature, the cursor will be moved directly. Otherwise, we scroll
     * through results one by one manually by calling {@code rs.next()}.
     *
     * @param rs the ResultSet object to scroll.
     * @param rowNumber the row number to scroll forward to.
     * @throws SQLException if an error occurs.
     */
    public static void scrollResultSet(ResultSet rs, int rowNumber) throws SQLException {
        // If the driver supports scrollable result sets, use that feature.
<span class="nc bnc" id="L504" title="All 2 branches missed.">        if (isScrollResultsSupported()) {</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">            if (rowNumber &gt; 0) {</span>
                // We will attempt to do a relative fetch. This may fail in SQL Server if
                // &lt;resultset-navigation-strategy&gt; is set to absolute. It would need to be
                // set to looping to work correctly.
                // If so, manually scroll to the correct row.
                try {
<span class="nc" id="L511">                    rs.setFetchDirection(ResultSet.FETCH_FORWARD);</span>
<span class="nc" id="L512">                    rs.relative(rowNumber);</span>
                }
<span class="nc" id="L514">                catch (SQLException e) {</span>
                    // TODO change &quot;Error ...&quot; to &quot;Disabling ...&quot;
<span class="nc" id="L516">                    Log.error(&quot;Error in JDBC method rs.relative(rowNumber).&quot;, e);</span>
                    //Log.error(&quot;Disabling JDBC method rs.relative(rowNumber).&quot;, e);
                    //scrollResultsSupported = false;
<span class="nc bnc" id="L519" title="All 2 branches missed.">                    for (int i = 0; i &lt; rowNumber; i++) {</span>
<span class="nc" id="L520">                        rs.next();</span>
                    }
<span class="nc" id="L522">                }</span>
            }
        }
        // Otherwise, manually scroll to the correct row.
        else {
<span class="nc bnc" id="L527" title="All 2 branches missed.">            for (int i = 0; i &lt; rowNumber; i++) {</span>
<span class="nc" id="L528">                rs.next();</span>
            }
        }
<span class="nc" id="L531">    }</span>

    /**
     * Limits the number of the results in a result set (to startIndex + numResults).
     * Sets the fetch size depending on the features of the JDBC driver and make
     * sure that the size is not bigger than 500. 
     * @param pstmt the PreparedStatement
     * @param startIndex the first row with interesting data
     * @param numResults the number of interesting results
     */
    public static void limitRowsAndFetchSize(PreparedStatement pstmt, int startIndex, int numResults) {
<span class="nc" id="L542">        final int MAX_FETCHRESULTS = 500;</span>
<span class="nc" id="L543">        final int maxRows = startIndex + numResults;</span>
<span class="nc" id="L544">        setMaxRows(pstmt, maxRows);</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">        if (pstmt_fetchSizeSupported)</span>
        {
<span class="nc bnc" id="L547" title="All 2 branches missed.">            if (scrollResultsSupported) {</span>
<span class="nc" id="L548">                setFetchSize(pstmt, Math.min(MAX_FETCHRESULTS, numResults));</span>
            }
            else {
<span class="nc" id="L551">                setFetchSize(pstmt, Math.min(MAX_FETCHRESULTS, maxRows));            </span>
            }
        }
<span class="nc" id="L554">    }</span>
    
    /**
     * Sets the number of rows that the JDBC driver should buffer at a time.
     * The operation is automatically bypassed if Openfire knows that the
     * the JDBC driver or database doesn't support it.
     *
     * @param pstmt the PreparedStatement to set the fetch size for.
     * @param fetchSize the fetchSize.
     */
    public static void setFetchSize(PreparedStatement pstmt, int fetchSize) {
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (pstmt_fetchSizeSupported) {</span>
            try {
<span class="nc" id="L567">                pstmt.setFetchSize(fetchSize);</span>
            }
<span class="nc" id="L569">            catch (Throwable t) {</span>
                // Ignore. Exception may happen if the driver doesn't support
                // this operation and we didn't set meta-data correctly.
                // However, it is a good idea to update the meta-data so that
                // we don't have to incur the cost of catching an exception
                // each time.
<span class="nc" id="L575">                Log.error(&quot;Disabling JDBC method pstmt.setFetchSize(fetchSize).&quot;, t);</span>
<span class="nc" id="L576">                pstmt_fetchSizeSupported = false;</span>
<span class="nc" id="L577">            }</span>
        }
<span class="nc" id="L579">    }</span>

    /**
     * Returns the current connection provider. The only case in which this
     * method should be called is if more information about the current
     * connection provider is needed. Database connections should always be
     * obtained by calling the getConnection method of this class.
     *
     * @return the connection provider.
     */
    public static ConnectionProvider getConnectionProvider() {
<span class="nc" id="L590">        return connectionProvider;</span>
    }

    /**
     * Sets the connection provider. The old provider (if it exists) is shut
     * down before the new one is started. A connection provider &lt;b&gt;should
     * not&lt;/b&gt; be started before being passed to the connection manager
     * because the manager will call the start() method automatically.
     *
     * @param provider the ConnectionProvider that the manager should obtain
     *                 connections from.
     */
    public static void setConnectionProvider(ConnectionProvider provider) {
<span class="fc" id="L603">        synchronized (providerLock) {</span>
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">            if (connectionProvider != null) {</span>
<span class="nc" id="L605">                connectionProvider.destroy();</span>
<span class="nc" id="L606">                connectionProvider = null;</span>
            }
<span class="fc" id="L608">            connectionProvider = provider;</span>
<span class="nc" id="L609">            connectionProvider.start();</span>
            // Now, get a connection to determine meta data.
<span class="nc" id="L611">            Connection con = null;</span>
            try {
<span class="nc" id="L613">                con = connectionProvider.getConnection();</span>
<span class="nc" id="L614">                setMetaData(con);</span>

                // Check to see if the database schema needs to be upgraded.
<span class="nc" id="L617">                schemaManager.checkOpenfireSchema(con);</span>
            }
<span class="nc" id="L619">            catch (MissingResourceException mre) {</span>
<span class="nc" id="L620">                Log.error(mre.getMessage());</span>
            }
<span class="nc" id="L622">            catch (Exception e) {</span>
<span class="nc" id="L623">                Log.error(e.getMessage(), e);</span>
            }
            finally {
<span class="nc" id="L626">                closeConnection(con);</span>
<span class="nc" id="L627">            }</span>
<span class="pc" id="L628">        }</span>
        // Remember what connection provider we want to use for restarts.
<span class="nc" id="L630">        JiveGlobals.setXMLProperty(&quot;connectionProvider.className&quot;, provider.getClass().getName());</span>
<span class="nc" id="L631">    }</span>

    /**
     * Destroys the currennt connection provider. Future calls to
     * {@link #getConnectionProvider()} will return {@code null} until a new
     * ConnectionProvider is set, or one is automatically loaded by a call to
     * {@link #getConnection()}.
     */
    public static void destroyConnectionProvider() {
<span class="nc" id="L640">        synchronized (providerLock) {</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">            if (connectionProvider != null) {</span>
<span class="nc" id="L642">                connectionProvider.destroy();</span>
<span class="nc" id="L643">                connectionProvider = null;</span>
            }
<span class="nc" id="L645">        }</span>
<span class="nc" id="L646">    }</span>

    /**
     * Retrives a large text column from a result set, automatically performing
     * streaming if the JDBC driver requires it. This is necessary because
     * different JDBC drivers have different capabilities and methods for
     * retrieving large text values.
     *
     * @param rs the ResultSet to retrieve the text field from.
     * @param columnIndex the column in the ResultSet of the text field.
     * @return the String value of the text field.
     * @throws SQLException if an SQL exception occurs.
     */
    public static String getLargeTextField(ResultSet rs, int columnIndex) throws SQLException {
<span class="nc bnc" id="L660" title="All 2 branches missed.">        if (isStreamTextRequired()) {</span>
            String value;
<span class="nc" id="L662">            try (Reader bodyReader = rs.getCharacterStream(columnIndex)) {</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">                if (bodyReader == null) {</span>
<span class="nc" id="L664">                    return null;</span>
                }
<span class="nc" id="L666">                char[] buf = new char[256];</span>
                int len;
<span class="nc" id="L668">                StringWriter out = new StringWriter(256);</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">                while ((len = bodyReader.read(buf)) &gt;= 0) {</span>
<span class="nc" id="L670">                    out.write(buf, 0, len);</span>
                }
<span class="nc" id="L672">                value = out.toString();</span>
<span class="nc" id="L673">                out.close();</span>
<span class="nc bnc" id="L674" title="All 12 branches missed.">            }</span>
<span class="nc" id="L675">            catch (Exception e) {</span>
<span class="nc" id="L676">                Log.error(e.getMessage(), e);</span>
<span class="nc" id="L677">                throw new SQLException(&quot;Failed to load text field&quot;);</span>
<span class="nc" id="L678">            }</span>
<span class="nc" id="L679">            return value;</span>
        }
        else {
<span class="nc" id="L682">            return rs.getString(columnIndex);</span>
        }
    }

    /**
     * Sets a large text column in a result set, automatically performing
     * streaming if the JDBC driver requires it. This is necessary because
     * different JDBC drivers have different capabilities and methods for
     * setting large text values.
     *
     * @param pstmt the PreparedStatement to set the text field in.
     * @param parameterIndex the index corresponding to the text field.
     * @param value the String to set.
     * @throws SQLException if an SQL exception occurs.
     */
    public static void setLargeTextField(PreparedStatement pstmt, int parameterIndex,
                                         String value) throws SQLException {
<span class="nc bnc" id="L699" title="All 2 branches missed.">        if (isStreamTextRequired()) {</span>
            Reader bodyReader;
            try {
<span class="nc" id="L702">                bodyReader = new StringReader(value);</span>
<span class="nc" id="L703">                pstmt.setCharacterStream(parameterIndex, bodyReader, value.length());</span>
            }
<span class="nc" id="L705">            catch (Exception e) {</span>
<span class="nc" id="L706">                Log.error(e.getMessage(), e);</span>
<span class="nc" id="L707">                throw new SQLException(&quot;Failed to set text field.&quot;);</span>
<span class="nc" id="L708">            }</span>
            // Leave bodyReader open so that the db can read from it. It *should*
            // be garbage collected after it's done without needing to call close.
        }
        else {
<span class="nc" id="L713">            pstmt.setString(parameterIndex, value);</span>
        }
<span class="nc" id="L715">    }</span>

    /**
     * Sets the max number of rows that should be returned from executing a
     * statement. The operation is automatically bypassed if Jive knows that the
     * the JDBC driver or database doesn't support it.
     *
     * @param stmt    the Statement to set the max number of rows for.
     * @param maxRows the max number of rows to return.
     */
    public static void setMaxRows(Statement stmt, int maxRows) {
<span class="nc bnc" id="L726" title="All 2 branches missed.">        if (isMaxRowsSupported()) {</span>
            try {
<span class="nc" id="L728">                stmt.setMaxRows(maxRows);</span>
            }
<span class="nc" id="L730">            catch (Throwable t) {</span>
                // Ignore. Exception may happen if the driver doesn't support
                // this operation and we didn't set meta-data correctly.
                // However, it is a good idea to update the meta-data so that
                // we don't have to incur the cost of catching an exception
                // each time.
<span class="nc" id="L736">                Log.error(&quot;Disabling JDBC method stmt.setMaxRows(maxRows).&quot;, t);</span>
<span class="nc" id="L737">                maxRowsSupported = false;</span>
<span class="nc" id="L738">            }</span>
        }
<span class="nc" id="L740">    }</span>

    /**
     * Sets the number of rows that the JDBC driver should buffer at a time.
     * The operation is automatically bypassed if Jive knows that the
     * the JDBC driver or database doesn't support it.
     *
     * @param rs the ResultSet to set the fetch size for.
     * @param fetchSize the fetchSize.
     */
    public static void setFetchSize(ResultSet rs, int fetchSize) {
<span class="nc bnc" id="L751" title="All 2 branches missed.">        if (isFetchSizeSupported()) {</span>
            try {
<span class="nc" id="L753">                rs.setFetchSize(fetchSize);</span>
            }
<span class="nc" id="L755">            catch (Throwable t) {</span>
                // Ignore. Exception may happen if the driver doesn't support
                // this operation and we didn't set meta-data correctly.
                // However, it is a good idea to update the meta-data so that
                // we don't have to incur the cost of catching an exception
                // each time.
<span class="nc" id="L761">                Log.error(&quot;Disabling JDBC method rs.setFetchSize(fetchSize).&quot;, t);</span>
<span class="nc" id="L762">                fetchSizeSupported = false;</span>
<span class="nc" id="L763">            }</span>
        }
<span class="nc" id="L765">    }</span>

    /**
     * Returns a SchemaManager instance, which can be used to manage the database
     * schema information for Openfire and plugins.
     *
     * @return a SchemaManager instance.
     */
    public static SchemaManager getSchemaManager() {
<span class="nc" id="L774">        return schemaManager;</span>
    }

    /**
     * Uses a connection from the database to set meta data information about
     * what different JDBC drivers and databases support.
     *
     * @param con the connection.
     * @throws SQLException if an SQL exception occurs.
     */
    private static void setMetaData(Connection con) throws SQLException {
<span class="nc" id="L785">        DatabaseMetaData metaData = con.getMetaData();</span>
        // Supports transactions?
<span class="nc" id="L787">        transactionsSupported = metaData.supportsTransactions();</span>
        // Supports subqueries?
<span class="nc" id="L789">        subqueriesSupported = metaData.supportsCorrelatedSubqueries();</span>
        // Supports scroll insensitive result sets? Try/catch block is a
        // workaround for DB2 JDBC driver, which throws an exception on
        // the method call.
        try {
<span class="nc" id="L794">            scrollResultsSupported = metaData.supportsResultSetType(</span>
                    ResultSet.TYPE_SCROLL_INSENSITIVE);
        }
<span class="nc" id="L797">        catch (Exception e) {</span>
<span class="nc" id="L798">            scrollResultsSupported = false;</span>
<span class="nc" id="L799">        }</span>
        // Supports batch updates
<span class="nc" id="L801">        batchUpdatesSupported = metaData.supportsBatchUpdates();</span>

        // Set defaults for other meta properties
<span class="nc" id="L804">        streamTextRequired = false;</span>
<span class="nc" id="L805">        maxRowsSupported = true;</span>
<span class="nc" id="L806">        fetchSizeSupported = true;</span>
<span class="nc" id="L807">        identifierQuoteString = metaData.getIdentifierQuoteString();</span>

        // Get the database name so that we can perform meta data settings.
<span class="nc" id="L810">        String dbName = metaData.getDatabaseProductName().toLowerCase();</span>
<span class="nc" id="L811">        String driverName = metaData.getDriverName().toLowerCase();</span>

        // Oracle properties.
<span class="nc bnc" id="L814" title="All 2 branches missed.">        if (dbName.indexOf(&quot;oracle&quot;) != -1) {</span>
<span class="nc" id="L815">            databaseType = DatabaseType.oracle;</span>
<span class="nc" id="L816">            streamTextRequired = true;</span>
<span class="nc" id="L817">            scrollResultsSupported = false; /* TODO comment and test this, it should be supported since 10g */</span>
            // The i-net AUGURO JDBC driver
<span class="nc bnc" id="L819" title="All 2 branches missed.">            if (driverName.indexOf(&quot;auguro&quot;) != -1) {</span>
<span class="nc" id="L820">                streamTextRequired = false;</span>
<span class="nc" id="L821">                fetchSizeSupported = true;</span>
<span class="nc" id="L822">                maxRowsSupported = false;</span>
            }
        }
        // Postgres properties
<span class="nc bnc" id="L826" title="All 2 branches missed.">        else if (dbName.indexOf(&quot;postgres&quot;) != -1) {</span>
<span class="nc" id="L827">            databaseType = DatabaseType.postgresql;</span>
            // Postgres blows, so disable scrolling result sets.
<span class="nc" id="L829">            scrollResultsSupported = false;</span>
<span class="nc" id="L830">            fetchSizeSupported = false;</span>
        }
        // Interbase properties
<span class="nc bnc" id="L833" title="All 2 branches missed.">        else if (dbName.indexOf(&quot;interbase&quot;) != -1) {</span>
<span class="nc" id="L834">            databaseType = DatabaseType.interbase;</span>
<span class="nc" id="L835">            fetchSizeSupported = false;</span>
<span class="nc" id="L836">            maxRowsSupported = false;</span>
        }
        // SQLServer
<span class="nc bnc" id="L839" title="All 2 branches missed.">        else if (dbName.indexOf(&quot;sql server&quot;) != -1) {</span>
<span class="nc" id="L840">            databaseType = DatabaseType.sqlserver;</span>
            // JDBC driver i-net UNA properties
<span class="nc bnc" id="L842" title="All 2 branches missed.">            if (driverName.indexOf(&quot;una&quot;) != -1) {</span>
<span class="nc" id="L843">                fetchSizeSupported = true;</span>
<span class="nc" id="L844">                maxRowsSupported = false;</span>
            }
        }
        // MySQL properties
<span class="nc bnc" id="L848" title="All 2 branches missed.">        else if (dbName.indexOf(&quot;mysql&quot;) != -1) {</span>
<span class="nc" id="L849">            databaseType = DatabaseType.mysql;</span>
<span class="nc" id="L850">            transactionsSupported = false; /* TODO comment and test this, it should be supported since 5.0 */</span>
        }
        // HSQL properties
<span class="nc bnc" id="L853" title="All 2 branches missed.">        else if (dbName.indexOf(&quot;hsql&quot;) != -1) {</span>
<span class="nc" id="L854">            databaseType = DatabaseType.hsqldb;</span>
            // scrollResultsSupported = false; /* comment and test this, it should be supported since 1.7.2 */
        }
        // DB2 properties.
<span class="nc bnc" id="L858" title="All 2 branches missed.">        else if (dbName.indexOf(&quot;db2&quot;) != 1) {</span>
<span class="nc" id="L859">            databaseType = DatabaseType.db2;</span>
        }
<span class="nc" id="L861">    }</span>

    /**
     * Returns the database type. The possible types are constants of the
     * DatabaseType class. Any database that doesn't have its own constant
     * falls into the &quot;Other&quot; category.
     *
     * @return the database type.
     */
    public static DatabaseType getDatabaseType() {
<span class="nc" id="L871">        return databaseType;</span>
    }

    /**
     * Returns true if connection profiling is turned on. You can collect
     * profiling statistics by using the static methods of the ProfiledConnection
     * class.
     *
     * @return true if connection profiling is enabled.
     */
    public static boolean isProfilingEnabled() {
<span class="nc" id="L882">        return profilingEnabled;</span>
    }

    /**
     * Turns connection profiling on or off. You can collect profiling
     * statistics by using the static methods of the ProfiledConnection
     * class.
     *
     * @param enable true to enable profiling; false to disable.
     */
    public static void setProfilingEnabled(boolean enable) {
        // If enabling profiling, call the start method on ProfiledConnection
<span class="nc bnc" id="L894" title="All 4 branches missed.">        if (!profilingEnabled &amp;&amp; enable) {</span>
<span class="nc" id="L895">            ProfiledConnection.start();</span>
        }
        // Otherwise, if turning off, call stop method.
<span class="nc bnc" id="L898" title="All 4 branches missed.">        else if (profilingEnabled &amp;&amp; !enable) {</span>
<span class="nc" id="L899">            ProfiledConnection.stop();</span>
        }
<span class="nc" id="L901">        profilingEnabled = enable;</span>
<span class="nc" id="L902">    }</span>

    public static boolean isTransactionsSupported() {
<span class="nc" id="L905">        return transactionsSupported;</span>
    }

    public static boolean isStreamTextRequired() {
<span class="nc" id="L909">        return streamTextRequired;</span>
    }

    public static boolean isMaxRowsSupported() {
<span class="nc" id="L913">        return maxRowsSupported;</span>
    }

    public static boolean isFetchSizeSupported() {
<span class="nc" id="L917">        return fetchSizeSupported;</span>
    }
    
    public static boolean isPstmtFetchSizeSupported() {
<span class="nc" id="L921">        return pstmt_fetchSizeSupported;</span>
    }

    public static boolean isSubqueriesSupported() {
<span class="nc" id="L925">        return subqueriesSupported;</span>
    }

    public static boolean isScrollResultsSupported() {
<span class="nc" id="L929">        return scrollResultsSupported;</span>
    }

    public static boolean isBatchUpdatesSupported() {
<span class="nc" id="L933">        return batchUpdatesSupported;</span>
    }

    public static boolean isEmbeddedDB() {
<span class="nc bnc" id="L937" title="All 4 branches missed.">        return connectionProvider != null &amp;&amp; connectionProvider instanceof EmbeddedConnectionProvider;</span>
    }

    public static String getIdentifierQuoteString() {
<span class="nc" id="L941">        return identifierQuoteString;</span>
    }

    public static String getTestSQL(String driver) {
<span class="pc bpc" id="L945" title="1 of 2 branches missed.">        if (driver == null) {</span>
<span class="fc" id="L946">            return &quot;select 1&quot;;</span>
        }
<span class="nc bnc" id="L948" title="All 2 branches missed.">        else if (driver.contains(&quot;db2&quot;)) {</span>
<span class="nc" id="L949">            return &quot;select 1 from sysibm.sysdummy1&quot;;</span>
        }
<span class="nc bnc" id="L951" title="All 2 branches missed.">        else if (driver.contains(&quot;oracle&quot;)) {</span>
<span class="nc" id="L952">            return &quot;select 1 from dual&quot;;</span>
        }
        else {
<span class="nc" id="L955">            return &quot;select 1&quot;;</span>
        }
    }

    /**
     * A class that identifies the type of the database that Jive is connected
     * to. In most cases, we don't want to make any database specific calls
     * and have no need to know the type of database we're using. However,
     * there are certain cases where it's critical to know the database for
     * performance reasons.
     */
<span class="pc" id="L966">    public enum DatabaseType {</span>

<span class="fc" id="L968">        oracle,</span>

<span class="fc" id="L970">        postgresql,</span>

<span class="fc" id="L972">        mysql(&quot;rank&quot;),</span>

<span class="fc" id="L974">        hsqldb,</span>

<span class="fc" id="L976">        db2,</span>

<span class="fc" id="L978">        sqlserver,</span>

<span class="fc" id="L980">        interbase,</span>

<span class="fc" id="L982">        unknown;</span>

        private final HashSet&lt;String&gt; identifiers;

<span class="fc" id="L986">        DatabaseType(final String ... identifiers) {</span>
<span class="fc" id="L987">            this.identifiers = new HashSet&lt;&gt;(Arrays.asList(identifiers));</span>
<span class="fc" id="L988">        }</span>

        public String escapeIdentifier(final String keyword) {
<span class="nc bnc" id="L991" title="All 2 branches missed.">            if (identifiers.contains(keyword)) {</span>
<span class="nc" id="L992">                return String.format(&quot;%1$s%2$s%1$s&quot;, DbConnectionManager.getIdentifierQuoteString(), keyword);</span>
            } else {
<span class="nc" id="L994">                return keyword;</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>