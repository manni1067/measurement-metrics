<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PresenceUpdateHandler.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Core XMPP Server</a> &gt; <a href="index.source.html" class="el_package">org.jivesoftware.openfire.handler</a> &gt; <span class="el_source">PresenceUpdateHandler.java</span></div><h1>PresenceUpdateHandler.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2005-2008 Jive Software. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jivesoftware.openfire.handler;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.locks.Lock;

import org.jivesoftware.openfire.ChannelHandler;
import org.jivesoftware.openfire.OfflineMessage;
import org.jivesoftware.openfire.OfflineMessageStore;
import org.jivesoftware.openfire.PacketDeliverer;
import org.jivesoftware.openfire.PacketException;
import org.jivesoftware.openfire.PresenceManager;
import org.jivesoftware.openfire.RoutingTable;
import org.jivesoftware.openfire.SessionManager;
import org.jivesoftware.openfire.XMPPServer;
import org.jivesoftware.openfire.auth.UnauthorizedException;
import org.jivesoftware.openfire.cluster.ClusterEventListener;
import org.jivesoftware.openfire.cluster.ClusterManager;
import org.jivesoftware.openfire.container.BasicModule;
import org.jivesoftware.openfire.roster.Roster;
import org.jivesoftware.openfire.roster.RosterItem;
import org.jivesoftware.openfire.roster.RosterManager;
import org.jivesoftware.openfire.session.ClientSession;
import org.jivesoftware.openfire.session.LocalSession;
import org.jivesoftware.openfire.session.Session;
import org.jivesoftware.openfire.user.UserManager;
import org.jivesoftware.openfire.user.UserNotFoundException;
import org.jivesoftware.util.LocaleUtils;
import org.jivesoftware.util.cache.Cache;
import org.jivesoftware.util.cache.CacheFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xmpp.packet.JID;
import org.xmpp.packet.Message;
import org.xmpp.packet.Packet;
import org.xmpp.packet.PacketError;
import org.xmpp.packet.Presence;

/**
 * Implements the presence protocol. Clients use this protocol to
 * update presence and roster information.
 * &lt;p&gt;
 * The handler must properly detect the presence type, update the user's roster,
 * and inform presence subscribers of the session's updated presence
 * status. Presence serves many purposes in Jabber so this handler will
 * likely be the most complex of all handlers in the server.
 * &lt;/p&gt;
 * &lt;p&gt;
 * There are four basic types of presence updates:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Simple presence updates - addressed to the server (or to address), these updates
 * are properly addressed by the server, and multicast to
 * interested subscribers on the user's roster. An empty, missing,
 * or &quot;unavailable&quot; type attribute indicates a simple update (there
 * is no &quot;available&quot; type although it should be accepted by the server.
 * &lt;li&gt;Directed presence updates - addressed to particular jabber entities,
 * these presence updates are properly addressed and directly delivered
 * to the entity without broadcast to roster subscribers. Any update type
 * is possible except those reserved for subscription requests.
 * &lt;li&gt;Subscription requests - these updates request presence subscription
 * status changes. Such requests always affect the roster.  The server must:
 * &lt;ul&gt;
 * &lt;li&gt;update the roster with the proper subscriber info
 * &lt;li&gt;push the roster changes to the user
 * &lt;li&gt;forward the update to the correct parties.
 * &lt;/ul&gt;
 * The valid types include &quot;subscribe&quot;, &quot;subscribed&quot;, &quot;unsubscribed&quot;,
 * and &quot;unsubscribe&quot;.
 * &lt;li&gt;XMPPServer probes - Provides a mechanism for servers to query the presence
 * status of users on another server. This allows users to immediately
 * know the presence status of users when they come online rather than way
 * for a presence update broadcast from the other server or tracking them
 * as they are received.  Requires S2S capabilities.
 * &lt;/ul&gt;
 *
 * @author Iain Shigeoka
 */
public class PresenceUpdateHandler extends BasicModule implements ChannelHandler, ClusterEventListener {

<span class="nc" id="L100">    private static final Logger Log = LoggerFactory.getLogger(PresenceUpdateHandler.class);</span>

    public static final String PRESENCE_CACHE_NAME = &quot;Directed Presences&quot;;

    /**
     * Keeps track of entities that sent directed presences to other entities. In this map
     * we keep track of every directed presence no matter if the recipient was hosted in
     * this JVM or another cluster node.
     *
     * Key: sender, Value: list of DirectedPresences
     */
    private Cache&lt;String, ConcurrentLinkedQueue&lt;DirectedPresence&gt;&gt; directedPresencesCache;
    /**
     * Same as the directedPresencesCache but only keeps directed presences sent from
     * users connected to this JVM.
     */
    private Map&lt;String, ConcurrentLinkedQueue&lt;DirectedPresence&gt;&gt; localDirectedPresences;

    private RoutingTable routingTable;
    private RosterManager rosterManager;
    private XMPPServer localServer;
    private PresenceManager presenceManager;
    private PacketDeliverer deliverer;
    private OfflineMessageStore messageStore;
    private SessionManager sessionManager;
    private UserManager userManager;

    public PresenceUpdateHandler() {
<span class="nc" id="L128">        super(&quot;Presence update handler&quot;);</span>
<span class="nc" id="L129">        localDirectedPresences = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L130">    }</span>

    @Override
    public void process(Packet packet) throws UnauthorizedException, PacketException {
<span class="nc" id="L134">        process((Presence) packet, sessionManager.getSession(packet.getFrom()));</span>
<span class="nc" id="L135">    }</span>

    private void process(Presence presence, ClientSession session) throws UnauthorizedException, PacketException {
        try {
<span class="nc" id="L139">            Presence.Type type = presence.getType();</span>
            // Available
<span class="nc bnc" id="L141" title="All 2 branches missed.">            if (type == null) {</span>
<span class="nc bnc" id="L142" title="All 4 branches missed.">                if (session != null &amp;&amp; session.getStatus() == Session.STATUS_CLOSED) {</span>
<span class="nc" id="L143">                    Log.warn(&quot;Rejected available presence: &quot; + presence + &quot; - &quot; + session);</span>
<span class="nc" id="L144">                    return;</span>
                }

<span class="nc bnc" id="L147" title="All 2 branches missed.">                if (session != null) {</span>
<span class="nc" id="L148">                    session.setPresence(presence);</span>
                }

<span class="nc" id="L151">                broadcastUpdate(presence.createCopy());</span>

<span class="nc bnc" id="L153" title="All 4 branches missed.">                if (session != null &amp;&amp; !session.isInitialized()) {</span>
<span class="nc" id="L154">                    initSession(session);</span>
<span class="nc" id="L155">                    session.setInitialized(true);</span>
                }

                // Notify the presence manager that the user is now available. The manager may
                // remove the last presence status sent by the user when he went offline.
<span class="nc" id="L160">                presenceManager.userAvailable(presence);</span>
            }
<span class="nc bnc" id="L162" title="All 2 branches missed.">            else if (Presence.Type.unavailable == type) {</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">                if (session != null) {</span>
<span class="nc" id="L164">                    session.setPresence(presence);</span>
                }
<span class="nc" id="L166">                broadcastUpdate(presence.createCopy());</span>
<span class="nc" id="L167">                broadcastUnavailableForDirectedPresences(presence);</span>
                // Notify the presence manager that the user is now unavailable. The manager may
                // save the last presence status sent by the user and keep track when the user
                // went offline.
<span class="nc" id="L171">                presenceManager.userUnavailable(presence);</span>
            }
            else {
<span class="nc" id="L174">                presence = presence.createCopy();</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                if (session != null) {</span>
<span class="nc" id="L176">                    presence.setFrom(new JID(null, session.getServerName(), null, true));</span>
<span class="nc" id="L177">                    presence.setTo(session.getAddress());</span>
                }
                else {
<span class="nc" id="L180">                    JID sender = presence.getFrom();</span>
<span class="nc" id="L181">                    presence.setFrom(presence.getTo());</span>
<span class="nc" id="L182">                    presence.setTo(sender);</span>
                }
<span class="nc" id="L184">                presence.setError(PacketError.Condition.bad_request);</span>
<span class="nc" id="L185">                deliverer.deliver(presence);</span>
            }

        }
<span class="nc" id="L189">        catch (Exception e) {</span>
<span class="nc" id="L190">            Log.error(LocaleUtils.getLocalizedString(&quot;admin.error&quot;) + &quot;. Triggered by packet: &quot; + presence, e);</span>
<span class="nc" id="L191">        }</span>
<span class="nc" id="L192">    }</span>

    /**
     * Handle presence updates that affect roster subscriptions.
     *
     * @param presence The presence presence to handle
     * @throws PacketException if the packet is null or the packet could not be routed.
     */
    public void process(Presence presence) throws PacketException {
        try {
<span class="nc" id="L202">            process((Packet)presence);</span>
        }
<span class="nc" id="L204">        catch (UnauthorizedException e) {</span>
            try {
<span class="nc" id="L206">                LocalSession session = (LocalSession) sessionManager.getSession(presence.getFrom());</span>
<span class="nc" id="L207">                presence = presence.createCopy();</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">                if (session != null) {</span>
<span class="nc" id="L209">                    presence.setFrom(new JID(null, session.getServerName(), null, true));</span>
<span class="nc" id="L210">                    presence.setTo(session.getAddress());</span>
                }
                else {
<span class="nc" id="L213">                    JID sender = presence.getFrom();</span>
<span class="nc" id="L214">                    presence.setFrom(presence.getTo());</span>
<span class="nc" id="L215">                    presence.setTo(sender);</span>
                }
<span class="nc" id="L217">                presence.setError(PacketError.Condition.not_authorized);</span>
<span class="nc" id="L218">                deliverer.deliver(presence);</span>
            }
<span class="nc" id="L220">            catch (Exception err) {</span>
<span class="nc" id="L221">                Log.error(LocaleUtils.getLocalizedString(&quot;admin.error&quot;), err);</span>
<span class="nc" id="L222">            }</span>
<span class="nc" id="L223">        }</span>
<span class="nc" id="L224">    }</span>

    /**
     * A session that has transitioned to available status must be initialized.
     * This includes:
     * &lt;ul&gt;
     * &lt;li&gt;Sending all offline presence subscription requests&lt;/li&gt;
     * &lt;li&gt;Sending offline messages&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param session The session being updated
     * @throws UserNotFoundException If the user being updated does not exist
     */
    private void initSession(ClientSession session) throws UserNotFoundException {

        // Only user sessions need to be authenticated
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (userManager.isRegisteredUser(session.getAddress().getNode())) {</span>
<span class="nc" id="L241">            String username = session.getAddress().getNode();</span>

            // Send pending subscription requests to user if roster service is enabled
<span class="nc bnc" id="L244" title="All 2 branches missed.">            if (RosterManager.isRosterServiceEnabled()) {</span>
<span class="nc" id="L245">                Roster roster = rosterManager.getRoster(username);</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">                for (RosterItem item : roster.getRosterItems()) {</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">                    if (item.getRecvStatus() == RosterItem.RECV_SUBSCRIBE) {</span>
<span class="nc" id="L248">                        session.process(createSubscribePresence(item.getJid(),</span>
<span class="nc" id="L249">                                session.getAddress().asBareJID(), true));</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">                    } else if (item.getRecvStatus() == RosterItem.RECV_UNSUBSCRIBE) {</span>
<span class="nc" id="L251">                        session.process(createSubscribePresence(item.getJid(),</span>
<span class="nc" id="L252">                                session.getAddress().asBareJID(), false));</span>
                    }
<span class="nc bnc" id="L254" title="All 2 branches missed.">                    if (item.getSubStatus() == RosterItem.SUB_TO</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">                            || item.getSubStatus() == RosterItem.SUB_BOTH) {</span>
<span class="nc" id="L256">                        presenceManager.probePresence(session.getAddress(), item.getJid());</span>
                    }
<span class="nc" id="L258">                }</span>
            }
<span class="nc bnc" id="L260" title="All 2 branches missed.">            if (session.canFloodOfflineMessages()) {</span>
                // deliver offline messages if any
<span class="nc" id="L262">                Collection&lt;OfflineMessage&gt; messages = messageStore.getMessages(username, true);</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">                for (Message message : messages) {</span>
<span class="nc" id="L264">                    session.process(message);</span>
<span class="nc" id="L265">                }</span>
            }
        }
<span class="nc" id="L268">    }</span>

    public Presence createSubscribePresence(JID senderAddress, JID targetJID, boolean isSubscribe) {
<span class="nc" id="L271">        Presence presence = new Presence();</span>
<span class="nc" id="L272">        presence.setFrom(senderAddress);</span>
<span class="nc" id="L273">        presence.setTo(targetJID);</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">        if (isSubscribe) {</span>
<span class="nc" id="L275">            presence.setType(Presence.Type.subscribe);</span>
        }
        else {
<span class="nc" id="L278">            presence.setType(Presence.Type.unsubscribe);</span>
        }
<span class="nc" id="L280">        return presence;</span>
    }

    /**
     * Broadcast the given update to all subscribers. We need to:
     * &lt;ul&gt;
     * &lt;li&gt;Query the roster table for subscribers&lt;/li&gt;
     * &lt;li&gt;Iterate through the list and send the update to each subscriber&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p/&gt;
     * Is there a safe way to cache the query results while maintaining
     * integrity with roster changes?
     *
     * @param update The update to broadcast
     */
    private void broadcastUpdate(Presence update) {
<span class="nc bnc" id="L296" title="All 2 branches missed.">        if (update.getFrom() == null) {</span>
<span class="nc" id="L297">            return;</span>
        }
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (localServer.isLocal(update.getFrom())) {</span>
            // Do nothing if roster service is disabled
<span class="nc bnc" id="L301" title="All 2 branches missed.">            if (!RosterManager.isRosterServiceEnabled()) {</span>
<span class="nc" id="L302">                return;</span>
            }
            // Local updates can simply run through the roster of the local user
<span class="nc" id="L305">            String name = update.getFrom().getNode();</span>
            try {
<span class="nc bnc" id="L307" title="All 4 branches missed.">                if (name != null &amp;&amp; !&quot;&quot;.equals(name)) {</span>
<span class="nc" id="L308">                    Roster roster = rosterManager.getRoster(name);</span>
<span class="nc" id="L309">                    roster.broadcastPresence(update);</span>
                }
            }
<span class="nc" id="L312">            catch (UserNotFoundException e) {</span>
<span class="nc" id="L313">                Log.warn(&quot;Presence being sent from unknown user &quot; + name, e);</span>
            }
<span class="nc" id="L315">            catch (PacketException e) {</span>
<span class="nc" id="L316">                Log.error(LocaleUtils.getLocalizedString(&quot;admin.error&quot;), e);</span>
<span class="nc" id="L317">            }</span>
<span class="nc" id="L318">        }</span>
        else {
            // Foreign updates will do a reverse lookup of entries in rosters
            // on the server
<span class="nc" id="L322">            Log.warn(&quot;Presence requested from server &quot;</span>
<span class="nc" id="L323">                    + localServer.getServerInfo().getXMPPDomain()</span>
<span class="nc" id="L324">                    + &quot; by unknown user: &quot; + update.getFrom());</span>
        }
<span class="nc" id="L326">    }</span>

    /**
     * Notification method sent to this handler when a user has sent a directed
     * presence to an entity. If the sender of the presence is local (to this server)
     * and the target entity does not belong to the user's roster then update the
     * registry of sent directed presences by the user.
     *
     * @param update  the directed Presence sent by the user to an entity.
     * @param handlerJID the JID of the handler that will receive/handle/process the sent packet.
     * @param jid     the receipient specified in the packet to handle.
     */
    public void directedPresenceSent(Presence update, JID handlerJID, String jid) {
<span class="nc bnc" id="L339" title="All 2 branches missed.">        if (update.getFrom() == null) {</span>
<span class="nc" id="L340">            return;</span>
        }
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (localServer.isLocal(update.getFrom())) {</span>
<span class="nc" id="L343">            boolean keepTrack = false;</span>
<span class="nc" id="L344">            String name = update.getFrom().getNode();</span>
<span class="nc bnc" id="L345" title="All 4 branches missed.">            if (name != null &amp;&amp; !&quot;&quot;.equals(name)) {</span>
                // Keep track of all directed presences if roster service is disabled
<span class="nc bnc" id="L347" title="All 2 branches missed.">                if (!RosterManager.isRosterServiceEnabled()) {</span>
<span class="nc" id="L348">                    keepTrack = true;</span>
                }
                else {
                    try {
<span class="nc" id="L352">                        Roster roster = rosterManager.getRoster(name);</span>
                        // If the directed presence was sent to an entity that is not in the user's
                        // roster, keep a registry of this so that when the user goes offline we
                        // will be able to send the unavailable presence to the entity
<span class="nc" id="L356">                        RosterItem rosterItem = null;</span>
                        try {
<span class="nc" id="L358">                            rosterItem = roster.getRosterItem(update.getTo());</span>
                        }
<span class="nc" id="L360">                        catch (UserNotFoundException e) {</span>
                            // Ignore
<span class="nc" id="L362">                        }</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">                        if (rosterItem == null ||</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">                                RosterItem.SUB_NONE == rosterItem.getSubStatus() ||</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">                                RosterItem.SUB_TO == rosterItem.getSubStatus()) {</span>
<span class="nc" id="L366">                            keepTrack = true;</span>
                        }
                    }
<span class="nc" id="L369">                    catch (UserNotFoundException e) {</span>
<span class="nc" id="L370">                        Log.warn(&quot;Presence being sent from unknown user &quot; + name, e);</span>
                    }
<span class="nc" id="L372">                    catch (PacketException e) {</span>
<span class="nc" id="L373">                        Log.error(LocaleUtils.getLocalizedString(&quot;admin.error&quot;), e);</span>
<span class="nc" id="L374">                    }</span>
                }
            }
<span class="nc bnc" id="L377" title="All 2 branches missed.">            else if (update.getFrom().getResource() != null){</span>
                // Keep always track of anonymous users directed presences
<span class="nc" id="L379">                keepTrack = true;</span>
            }
<span class="nc bnc" id="L381" title="All 2 branches missed.">            if (keepTrack) {</span>
<span class="nc" id="L382">                String sender = update.getFrom().toString();</span>
<span class="nc" id="L383">                Lock lock = CacheFactory.getLock(sender, directedPresencesCache);</span>
                try {
<span class="nc" id="L385">                    lock.lock();</span>
<span class="nc" id="L386">                    ConcurrentLinkedQueue&lt;DirectedPresence&gt; directedPresences = directedPresencesCache.get(sender);</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">                    if (Presence.Type.unavailable.equals(update.getType())) {</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">                        if (directedPresences != null) {</span>
                            // It's a directed unavailable presence
<span class="nc bnc" id="L390" title="All 2 branches missed.">                            if (routingTable.hasClientRoute(handlerJID)) {</span>
                                // Client sessions will receive only presences to the same JID (the
                                // address of the session) so remove the handler from the map
<span class="nc bnc" id="L393" title="All 2 branches missed.">                                for (DirectedPresence directedPresence : directedPresences) {</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">                                    if (directedPresence.getHandler().equals(handlerJID)) {</span>
<span class="nc" id="L395">                                        directedPresences.remove(directedPresence);</span>
<span class="nc" id="L396">                                        break;</span>
                                    }
<span class="nc" id="L398">                                }</span>
                            }
                            else {
                                // A service may receive presences for many JIDs so in this case we
                                // just need to remove the jid that has received a directed
                                // unavailable presence
<span class="nc bnc" id="L404" title="All 2 branches missed.">                                for (DirectedPresence directedPresence : directedPresences) {</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">                                    if (directedPresence.getHandler().equals(handlerJID)) {</span>
<span class="nc" id="L406">                                        directedPresence.removeReceiver(jid);</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">                                        if (directedPresence.isEmpty()) {</span>
<span class="nc" id="L408">                                            directedPresences.remove(directedPresence);</span>
                                        }
                                        break;
                                    }
<span class="nc" id="L412">                                }</span>
                            }
<span class="nc bnc" id="L414" title="All 2 branches missed.">                            if (directedPresences.isEmpty()) {</span>
                                // Remove the user from the registry since the list of directed
                                // presences is empty
<span class="nc" id="L417">                                directedPresencesCache.remove(sender);</span>
<span class="nc" id="L418">                                localDirectedPresences.remove(sender);</span>
                            }
                            else {
<span class="nc" id="L421">                                directedPresencesCache.put(sender, directedPresences);</span>
<span class="nc" id="L422">                                localDirectedPresences.put(sender, directedPresences);</span>
                            }
                        }
                    }
                    else {
<span class="nc bnc" id="L427" title="All 2 branches missed.">                        if (directedPresences == null) {</span>
                            // We are using a set to avoid duplicate jids in case the user
                            // sends several directed presences to the same handler. The Map also
                            // ensures that if the user sends several presences to the same handler
                            // we will have only one entry in the Map
<span class="nc" id="L432">                            directedPresences = new ConcurrentLinkedQueue&lt;&gt;();</span>
                        }
                        // Add the handler to the list of handler that processed the directed
                        // presence sent by the user. This handler will be used to send
                        // the unavailable presence when the user goes offline
<span class="nc" id="L437">                        DirectedPresence affectedDirectedPresence = null;</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">                        for (DirectedPresence directedPresence : directedPresences) {</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">                            if (directedPresence.getHandler().equals(handlerJID)) {</span>
<span class="nc" id="L440">                                affectedDirectedPresence = directedPresence;</span>
<span class="nc" id="L441">                                break;</span>
                            }
<span class="nc" id="L443">                        }</span>

<span class="nc bnc" id="L445" title="All 2 branches missed.">                        if (affectedDirectedPresence == null) {</span>
<span class="nc" id="L446">                            affectedDirectedPresence = new DirectedPresence(handlerJID);</span>
<span class="nc" id="L447">                            directedPresences.add(affectedDirectedPresence);</span>
                        }
<span class="nc" id="L449">                        affectedDirectedPresence.addReceiver(jid);</span>

<span class="nc" id="L451">                        directedPresencesCache.put(sender, directedPresences);</span>
<span class="nc" id="L452">                        localDirectedPresences.put(sender, directedPresences);</span>
                    }
                } finally {
<span class="nc" id="L455">                    lock.unlock();</span>
<span class="nc" id="L456">                }</span>
            }
        }
<span class="nc" id="L459">    }</span>

    /**
     * Sends an unavailable presence to the entities that sent a directed (available) presence
     * to other entities.
     *
     * @param update the unavailable presence sent by the user.
     */
    private void broadcastUnavailableForDirectedPresences(Presence update) {
<span class="nc" id="L468">        JID from = update.getFrom();</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">        if (from == null) {</span>
<span class="nc" id="L470">            return;</span>
        }
<span class="nc bnc" id="L472" title="All 2 branches missed.">        if (localServer.isLocal(from)) {</span>
            // Remove the registry of directed presences of this user
<span class="nc" id="L474">            Collection&lt;DirectedPresence&gt; directedPresences = null;</span>
            
<span class="nc" id="L476">            Lock lock = CacheFactory.getLock(from.toString(), directedPresencesCache);</span>
            try {
<span class="nc" id="L478">                lock.lock();</span>
<span class="nc" id="L479">                directedPresences = directedPresencesCache.remove(from.toString());</span>
            } finally {
<span class="nc" id="L481">                lock.unlock();</span>
<span class="nc" id="L482">            }</span>
            
<span class="nc bnc" id="L484" title="All 2 branches missed.">            if (directedPresences != null) {</span>
                // Iterate over all the entities that the user sent a directed presence
<span class="nc bnc" id="L486" title="All 2 branches missed.">                for (DirectedPresence directedPresence : directedPresences) {</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">                    for (String receiver : directedPresence.getReceivers()) {</span>
<span class="nc" id="L488">                        Presence presence = update.createCopy();</span>
<span class="nc" id="L489">                        presence.setTo(receiver);</span>
<span class="nc" id="L490">                        localServer.getPresenceRouter().route(presence);</span>
<span class="nc" id="L491">                    }</span>
<span class="nc" id="L492">                }</span>
<span class="nc" id="L493">                localDirectedPresences.remove(from.toString());</span>
            }
        }
<span class="nc" id="L496">    }</span>

    public boolean hasDirectPresence(JID ownerJID, JID recipientJID) {
<span class="nc bnc" id="L499" title="All 2 branches missed.">        if (recipientJID == null) {</span>
<span class="nc" id="L500">            return false;</span>
        }
<span class="nc" id="L502">        Collection&lt;DirectedPresence&gt; directedPresences = directedPresencesCache.get(ownerJID.toString());</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">        if (directedPresences != null) {</span>
<span class="nc" id="L504">            String recipient = recipientJID.toBareJID();</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">            for (DirectedPresence directedPresence : directedPresences) {</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">                for (String receiver : directedPresence.getReceivers()) {</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">                    if (receiver.contains(recipient)) {</span>
<span class="nc" id="L508">                        return true;</span>
                    }
<span class="nc" id="L510">                }</span>
<span class="nc" id="L511">            }</span>
        }
<span class="nc" id="L513">        return false;</span>
    }

    /**
     * Removes directed presences sent to entities that are no longer available.
     */
    public void removedExpiredPresences() {
<span class="nc" id="L520">        Map&lt;String, Collection&lt;DirectedPresence&gt;&gt; copy =</span>
                new HashMap&lt;&gt;(localDirectedPresences);
<span class="nc bnc" id="L522" title="All 2 branches missed.">        for (Map.Entry&lt;String, Collection&lt;DirectedPresence&gt;&gt; entry : copy.entrySet()) {</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">            for (DirectedPresence directedPresence : entry.getValue()) {</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">                if (!routingTable.hasClientRoute(directedPresence.getHandler()) &amp;&amp;</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">                        !routingTable.hasComponentRoute(directedPresence.getHandler())) {</span>
<span class="nc" id="L526">                    Collection&lt;DirectedPresence&gt; presences = localDirectedPresences.get(entry.getKey());</span>
<span class="nc" id="L527">                    presences.remove(directedPresence);</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">                    if (presences.isEmpty()) {</span>
<span class="nc" id="L529">                        localDirectedPresences.remove(entry.getKey());</span>
                    }
                }
<span class="nc" id="L532">            }</span>
<span class="nc" id="L533">        }</span>
<span class="nc" id="L534">    }</span>

    @Override
    public void initialize(XMPPServer server) {
<span class="nc" id="L538">        super.initialize(server);</span>
<span class="nc" id="L539">        localServer = server;</span>
<span class="nc" id="L540">        rosterManager = server.getRosterManager();</span>
<span class="nc" id="L541">        presenceManager = server.getPresenceManager();</span>
<span class="nc" id="L542">        deliverer = server.getPacketDeliverer();</span>
<span class="nc" id="L543">        messageStore = server.getOfflineMessageStore();</span>
<span class="nc" id="L544">        sessionManager = server.getSessionManager();</span>
<span class="nc" id="L545">        userManager = server.getUserManager();</span>
<span class="nc" id="L546">        routingTable = server.getRoutingTable();</span>
<span class="nc" id="L547">        directedPresencesCache = CacheFactory.createCache(PRESENCE_CACHE_NAME);</span>
        // TODO Add as route listener (to remove direct presences info for removed routes). Mainly for c2s sessions which is uncommon.
        // Listen to cluster events
<span class="nc" id="L550">        ClusterManager.addListener(this);</span>
<span class="nc" id="L551">    }</span>

    @Override
    public void joinedCluster() {
        // Populate directedPresencesCache with local content since when not in a cluster
        // we could still send directed presences to entities that when connected to a cluster
        // they will be replicated. An example would be MUC rooms.
<span class="nc bnc" id="L558" title="All 2 branches missed.">        for (Map.Entry&lt;String, ConcurrentLinkedQueue&lt;DirectedPresence&gt;&gt; entry : localDirectedPresences.entrySet()) {</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">            if (entry.getValue().isEmpty()) {</span>
<span class="nc" id="L560">                Log.warn(&quot;PresenceUpdateHandler - Skipping empty directed presences when joining cluster for sender: &quot; +</span>
<span class="nc" id="L561">                        entry.getKey());</span>
<span class="nc" id="L562">                continue;</span>
            }

            // TODO perhaps we should not lock for every entry. Instead, lock it
            // once (using a LOCK_ALL global key), and handle iterations in
            // one go. We should first make sure that this doesn't lead to
            // deadlocks though! The tryLock() mechanism could be used to first
            // try one approach, but fall back on the other approach.
<span class="nc" id="L570">            Lock lock = CacheFactory.getLock(entry.getKey(), directedPresencesCache);</span>
            try {
<span class="nc" id="L572">                lock.lock();</span>
<span class="nc" id="L573">                directedPresencesCache.put(entry.getKey(), entry.getValue());</span>
            } finally {
<span class="nc" id="L575">                lock.unlock();</span>
<span class="nc" id="L576">            }</span>
<span class="nc" id="L577">        }</span>
<span class="nc" id="L578">    }</span>

    @Override
    public void joinedCluster(byte[] nodeID) {
        // Do nothing
<span class="nc" id="L583">    }</span>

    @Override
    public void leftCluster() {
<span class="nc bnc" id="L587" title="All 2 branches missed.">        if (!XMPPServer.getInstance().isShuttingDown()) {</span>
            // Populate directedPresencesCache with local content
<span class="nc bnc" id="L589" title="All 2 branches missed.">            for (Map.Entry&lt;String, ConcurrentLinkedQueue&lt;DirectedPresence&gt;&gt; entry : localDirectedPresences.entrySet()) {</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">                if (entry.getValue().isEmpty()) {</span>
<span class="nc" id="L591">                    Log.warn(</span>
                            &quot;PresenceUpdateHandler - Skipping empty directed presences when leaving cluster for sender: &quot; +
<span class="nc" id="L593">                                    entry.getKey());</span>
<span class="nc" id="L594">                    continue;</span>
                }    

                
                // TODO perhaps we should not lock for every entry. Instead, lock it
                // once (using a LOCK_ALL global key), and handle iterations in
                // one go. We should first make sure that this doesn't lead to
                // deadlocks though! The tryLock() mechanism could be used to first
                // try one approach, but fall back on the other approach.
<span class="nc" id="L603">                Lock lock = CacheFactory.getLock(entry.getKey(), directedPresencesCache);</span>
                try {
<span class="nc" id="L605">                    lock.lock();</span>
<span class="nc" id="L606">                    directedPresencesCache.put(entry.getKey(), entry.getValue());</span>
                } finally {
<span class="nc" id="L608">                    lock.unlock();</span>
<span class="nc" id="L609">                }</span>
<span class="nc" id="L610">            }</span>
        }
<span class="nc" id="L612">    }</span>

    @Override
    public void leftCluster(byte[] nodeID) {
        // Do nothing
<span class="nc" id="L617">    }</span>

    @Override
    public void markedAsSeniorClusterMember() {
        // Do nothing
<span class="nc" id="L622">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>