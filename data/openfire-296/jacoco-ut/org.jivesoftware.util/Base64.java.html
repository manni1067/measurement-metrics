<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Base64.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Core XMPP Server</a> &gt; <a href="index.source.html" class="el_package">org.jivesoftware.util</a> &gt; <span class="el_source">Base64.java</span></div><h1>Base64.java</h1><pre class="source lang-java linenums">package org.jivesoftware.util;

/**
 * &lt;p&gt;Encodes and decodes to and from Base64 notation.&lt;/p&gt;
 * &lt;p&gt;Homepage: &lt;a href=&quot;http://iharder.net/base64&quot;&gt;http://iharder.net/base64&lt;/a&gt;.&lt;/p&gt;
 *
 * &lt;p&gt;
 * Change Log:
 * &lt;/p&gt;
 * &lt;ul&gt;
 *  &lt;li&gt;v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug
 *   when using very small files (~&amp;lt; 40 bytes).&lt;/li&gt;
 *  &lt;li&gt;v2.2 - Added some helper methods for encoding/decoding directly from
 *   one file to the next. Also added a main() method to support command line
 *   encoding/decoding from one file to the next. Also added these Base64 dialects:
 *   &lt;ol&gt;
 *   &lt;li&gt;The default is RFC3548 format.&lt;/li&gt;
 *   &lt;li&gt;Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates
 *   URL and file name friendly format as described in Section 4 of RFC3548.
 *   http://www.faqs.org/rfcs/rfc3548.html&lt;/li&gt;
 *   &lt;li&gt;Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates
 *   URL and file name friendly format that preserves lexical ordering as described
 *   in http://www.faqs.org/qa/rfcc-1940.html&lt;/li&gt;
 *   &lt;/ol&gt;
 *   Special thanks to Jim Kellerman at &lt;a href=&quot;http://www.powerset.com/&quot;&gt;http://www.powerset.com/&lt;/a&gt;
 *   for contributing the new Base64 dialects.
 *  &lt;/li&gt;
 *
 *  &lt;li&gt;v2.1 - Cleaned up javadoc comments and unused variables and methods. Added
 *   some convenience methods for reading and writing to and from files.&lt;/li&gt;
 *  &lt;li&gt;v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems
 *   with other encodings (like EBCDIC).&lt;/li&gt;
 *  &lt;li&gt;v2.0.1 - Fixed an error when decoding a single byte, that is, when the
 *   encoded data was a single byte.&lt;/li&gt;
 *  &lt;li&gt;v2.0 - I got rid of methods that used booleans to set options.
 *   Now everything is more consolidated and cleaner. The code now detects
 *   when data that's being decoded is gzip-compressed and will decompress it
 *   automatically. Generally things are cleaner. You'll probably have to
 *   change some method calls that you were making to support the new
 *   options format ({@code int}s that you &quot;OR&quot; together).&lt;/li&gt;
 *  &lt;li&gt;v1.5.1 - Fixed bug when decompressing and decoding to a
 *   byte[] using {@code decode( String s, boolean gzipCompressed )}.
 *   Added the ability to &quot;suspend&quot; encoding in the Output Stream so
 *   you can turn on and off the encoding if you need to embed base64
 *   data in an otherwise &quot;normal&quot; stream (like an XML file).&lt;/li&gt;
 *  &lt;li&gt;v1.5 - Output stream pases on flush() command but doesn't do anything itself.
 *      This helps when using GZIP streams.
 *      Added the ability to GZip-compress objects before encoding them.&lt;/li&gt;
 *  &lt;li&gt;v1.4 - Added helper methods to read/write files.&lt;/li&gt;
 *  &lt;li&gt;v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.&lt;/li&gt;
 *  &lt;li&gt;v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream
 *      where last buffer being read, if not completely full, was not returned.&lt;/li&gt;
 *  &lt;li&gt;v1.3.4 - Fixed when &quot;improperly padded stream&quot; error was thrown at the wrong time.&lt;/li&gt;
 *  &lt;li&gt;v1.3.3 - Fixed I/O streams which were totally messed up.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * I am placing this code in the Public Domain. Do with it as you will.
 * This software comes with no guarantees or warranties but with
 * plenty of well-wishing instead!
 * Please visit &lt;a href=&quot;http://iharder.net/base64&quot;&gt;http://iharder.net/base64&lt;/a&gt;
 * periodically to check for updates or to contribute improvements.
 * &lt;/p&gt;
 *
 * @author Robert Harder
 * @author rob@iharder.net
 * @version 2.2.1
 */
public class Base64
{

/* ********  P U B L I C   F I E L D S  ******** */


    /** No options specified. Value is zero. */
    public final static int NO_OPTIONS = 0;

    /** Specify encoding. */
    public final static int ENCODE = 1;


    /** Specify decoding. */
    public final static int DECODE = 0;


    /** Specify that data should be gzip-compressed. */
    public final static int GZIP = 2;


    /** Don't break lines when encoding (violates strict Base64 specification) */
    public final static int DONT_BREAK_LINES = 8;

    /**
     * Encode using Base64-like encoding that is URL- and Filename-safe as described
     * in Section 4 of RFC3548:
     * &lt;a href=&quot;http://www.faqs.org/rfcs/rfc3548.html&quot;&gt;http://www.faqs.org/rfcs/rfc3548.html&lt;/a&gt;.
     * It is important to note that data encoded this way is &lt;em&gt;not&lt;/em&gt; officially valid Base64,
     * or at the very least should not be called Base64 without also specifying that is
     * was encoded using the URL- and Filename-safe dialect.
     */
     public final static int URL_SAFE = 16;


     /**
      * Encode using the special &quot;ordered&quot; dialect of Base64 described here:
      * &lt;a href=&quot;http://www.faqs.org/qa/rfcc-1940.html&quot;&gt;http://www.faqs.org/qa/rfcc-1940.html&lt;/a&gt;.
      */
     public final static int ORDERED = 32;


/* ********  P R I V A T E   F I E L D S  ******** */


    /** Maximum line length (76) of Base64 output. */
    private final static int MAX_LINE_LENGTH = 76;


    /** The equals sign (=) as a byte. */
    private final static byte EQUALS_SIGN = (byte)'=';


    /** The new line character (\n) as a byte. */
    private final static byte NEW_LINE = (byte)'\n';


    /** Preferred encoding. */
    private final static String PREFERRED_ENCODING = &quot;UTF-8&quot;;


    // I think I end up not using the BAD_ENCODING indicator.
    //private final static byte BAD_ENCODING    = -9; // Indicates error in encoding
    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding
    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding


/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */

    /** The 64 valid Base64 values. */
    //private final static byte[] ALPHABET;
    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */
<span class="fc" id="L141">    private final static byte[] _STANDARD_ALPHABET =</span>
    {
        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',
        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',
        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',
        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',
        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',
        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',
        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',
        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',
        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5',
        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'
    };


    /**
     * Translates a Base64 value to either its 6-bit reconstruction value
     * or a negative number indicating some other meaning.
     **/
<span class="fc" id="L160">    private final static byte[] _STANDARD_DECODABET =</span>
    {
        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8
        -5,-5,                                      // Whitespace: Tab and Linefeed
        -9,-9,                                      // Decimal 11 - 12
        -5,                                         // Whitespace: Carriage Return
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26
        -9,-9,-9,-9,-9,                             // Decimal 27 - 31
        -5,                                         // Whitespace: Space
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42
        62,                                         // Plus sign at decimal 43
        -9,-9,-9,                                   // Decimal 44 - 46
        63,                                         // Slash at decimal 47
        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine
        -9,-9,-9,                                   // Decimal 58 - 60
        -1,                                         // Equals sign at decimal 61
        -9,-9,-9,                                      // Decimal 62 - 64
        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'
        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'
        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96
        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'
        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'
        -9,-9,-9,-9                                 // Decimal 123 - 126
        /*,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 127 - 139
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
    };


/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */

    /**
     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548:
     * &lt;a href=&quot;http://www.faqs.org/rfcs/rfc3548.html&quot;&gt;http://www.faqs.org/rfcs/rfc3548.html&lt;/a&gt;.
     * Notice that the last two bytes become &quot;hyphen&quot; and &quot;underscore&quot; instead of &quot;plus&quot; and &quot;slash.&quot;
     */
<span class="fc" id="L203">    private final static byte[] _URL_SAFE_ALPHABET =</span>
    {
      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',
      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',
      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',
      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',
      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',
      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',
      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',
      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',
      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5',
      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'
    };

    /**
     * Used in decoding URL- and Filename-safe dialects of Base64.
     */
<span class="fc" id="L220">    private final static byte[] _URL_SAFE_DECODABET =</span>
    {
      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8
      -5,-5,                                      // Whitespace: Tab and Linefeed
      -9,-9,                                      // Decimal 11 - 12
      -5,                                         // Whitespace: Carriage Return
      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26
      -9,-9,-9,-9,-9,                             // Decimal 27 - 31
      -5,                                         // Whitespace: Space
      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42
      -9,                                         // Plus sign at decimal 43
      -9,                                         // Decimal 44
      62,                                         // Minus sign at decimal 45
      -9,                                         // Decimal 46
      -9,                                         // Slash at decimal 47
      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine
      -9,-9,-9,                                   // Decimal 58 - 60
      -1,                                         // Equals sign at decimal 61
      -9,-9,-9,                                   // Decimal 62 - 64
      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'
      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'
      -9,-9,-9,-9,                                // Decimal 91 - 94
      63,                                         // Underscore at decimal 95
      -9,                                         // Decimal 96
      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'
      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'
      -9,-9,-9,-9                                 // Decimal 123 - 126
      /*,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 127 - 139
      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
    };



/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */

    /**
     * I don't get the point of this technique, but it is described here:
     * &lt;a href=&quot;http://www.faqs.org/qa/rfcc-1940.html&quot;&gt;http://www.faqs.org/qa/rfcc-1940.html&lt;/a&gt;.
     */
<span class="fc" id="L267">    private final static byte[] _ORDERED_ALPHABET =</span>
    {
      (byte)'-',
      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',
      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',
      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',
      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',
      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',
      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',
      (byte)'_',
      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',
      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',
      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',
      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'
    };

    /**
     * Used in decoding the &quot;ordered&quot; dialect of Base64.
     */
<span class="fc" id="L286">    private final static byte[] _ORDERED_DECODABET =</span>
    {
      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8
      -5,-5,                                      // Whitespace: Tab and Linefeed
      -9,-9,                                      // Decimal 11 - 12
      -5,                                         // Whitespace: Carriage Return
      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26
      -9,-9,-9,-9,-9,                             // Decimal 27 - 31
      -5,                                         // Whitespace: Space
      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42
      -9,                                         // Plus sign at decimal 43
      -9,                                         // Decimal 44
      0,                                          // Minus sign at decimal 45
      -9,                                         // Decimal 46
      -9,                                         // Slash at decimal 47
      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine
      -9,-9,-9,                                   // Decimal 58 - 60
      -1,                                         // Equals sign at decimal 61
      -9,-9,-9,                                   // Decimal 62 - 64
      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'
      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'
      -9,-9,-9,-9,                                // Decimal 91 - 94
      37,                                         // Underscore at decimal 95
      -9,                                         // Decimal 96
      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'
      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'
      -9,-9,-9,-9                                 // Decimal 123 - 126
      /*,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 127 - 139
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
    };


/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */


    /**
     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on
     * the options specified.
     * It's possible, though silly, to specify ORDERED and URLSAFE
     * in which case one of them will be picked, though there is
     * no guarantee as to which one will be picked.
     */
    private final static byte[] getAlphabet( int options )
    {
<span class="fc bfc" id="L338" title="All 2 branches covered.">        if( (options &amp; URL_SAFE) == URL_SAFE ) return _URL_SAFE_ALPHABET;</span>
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">        else if( (options &amp; ORDERED) == ORDERED ) return _ORDERED_ALPHABET;</span>
<span class="fc" id="L340">        else return _STANDARD_ALPHABET;</span>

    }	// end getAlphabet


    /**
     * Returns one of the _SOMETHING_DECODABET byte arrays depending on
     * the options specified.
     * It's possible, though silly, to specify ORDERED and URL_SAFE
     * in which case one of them will be picked, though there is
     * no guarantee as to which one will be picked.
     */
    private final static byte[] getDecodabet( int options )
    {
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">        if( (options &amp; URL_SAFE) == URL_SAFE ) return _URL_SAFE_DECODABET;</span>
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">        else if( (options &amp; ORDERED) == ORDERED ) return _ORDERED_DECODABET;</span>
<span class="fc" id="L356">        else return _STANDARD_DECODABET;</span>

    }	// end getAlphabet



    /** Defeats instantiation. */
<span class="nc" id="L363">    private Base64(){}</span>


    /**
     * Prints command line usage.
     *
     * @param msg A message to include with usage info.
     */
    private final static void usage( String msg )
    {
<span class="nc" id="L373">        System.err.println( msg );</span>
<span class="nc" id="L374">        System.err.println( &quot;Usage: java Base64 -e|-d inputfile outputfile&quot; );</span>
<span class="nc" id="L375">    }   // end usage</span>


/* ********  E N C O D I N G   M E T H O D S  ******** */


    /**
     * Encodes up to the first three bytes of array &lt;var&gt;threeBytes&lt;/var&gt;
     * and returns a four-byte array in Base64 notation.
     * The actual number of significant bytes in your array is
     * given by &lt;var&gt;numSigBytes&lt;/var&gt;.
     * The array &lt;var&gt;threeBytes&lt;/var&gt; needs only be as big as
     * &lt;var&gt;numSigBytes&lt;/var&gt;.
     * Code can reuse a byte array by passing a four-byte array as &lt;var&gt;b4&lt;/var&gt;.
     *
     * @param b4 A reusable byte array to reduce array instantiation
     * @param threeBytes the array to convert
     * @param numSigBytes the number of significant bytes in your array
     * @return four byte array in Base64 notation.
     * @since 1.5.1
     */
    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options )
    {
<span class="nc" id="L398">        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );</span>
<span class="nc" id="L399">        return b4;</span>
    }   // end encode3to4


    /**
     * &lt;p&gt;Encodes up to three bytes of the array &lt;var&gt;source&lt;/var&gt;
     * and writes the resulting four Base64 bytes to &lt;var&gt;destination&lt;/var&gt;.
     * The source and destination arrays can be manipulated
     * anywhere along their length by specifying
     * &lt;var&gt;srcOffset&lt;/var&gt; and &lt;var&gt;destOffset&lt;/var&gt;.
     * This method does not check to make sure your arrays
     * are large enough to accomodate &lt;var&gt;srcOffset&lt;/var&gt; + 3 for
     * the &lt;var&gt;source&lt;/var&gt; array or &lt;var&gt;destOffset&lt;/var&gt; + 4 for
     * the &lt;var&gt;destination&lt;/var&gt; array.
     * The actual number of significant bytes in your array is
     * given by &lt;var&gt;numSigBytes&lt;/var&gt;.&lt;/p&gt;
     * &lt;p&gt;This is the lowest level of the encoding methods with
     * all possible parameters.&lt;/p&gt;
     *
     * @param source the array to convert
     * @param srcOffset the index where conversion begins
     * @param numSigBytes the number of significant bytes in your array
     * @param destination the array to hold the conversion
     * @param destOffset the index where output will be put
     * @return the &lt;var&gt;destination&lt;/var&gt; array
     * @since 1.3
     */
    private static byte[] encode3to4(
     byte[] source, int srcOffset, int numSigBytes,
     byte[] destination, int destOffset, int options )
    {
<span class="fc" id="L430">        byte[] ALPHABET = getAlphabet( options );</span>

        //           1         2         3
        // 01234567890123456789012345678901 Bit position
        // --------000000001111111122222222 Array position from threeBytes
        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET
        //          &gt;&gt;18  &gt;&gt;12  &gt;&gt; 6  &gt;&gt; 0  Right shift necessary
        //                0x3f  0x3f  0x3f  Additional AND

        // Create buffer with zero-padding if there are only one or two
        // significant bytes passed in the array.
        // We have to shift left 24 in order to flush out the 1's that appear
        // when Java treats a value as negative that is cast from a byte to an int.
<span class="pc bpc" id="L443" title="1 of 6 branches missed.">        int inBuff =   ( numSigBytes &gt; 0 ? ((source[ srcOffset     ] &lt;&lt; 24) &gt;&gt;&gt;  8) : 0 )</span>
                     | ( numSigBytes &gt; 1 ? ((source[ srcOffset + 1 ] &lt;&lt; 24) &gt;&gt;&gt; 16) : 0 )
                     | ( numSigBytes &gt; 2 ? ((source[ srcOffset + 2 ] &lt;&lt; 24) &gt;&gt;&gt; 24) : 0 );

<span class="pc bpc" id="L447" title="1 of 4 branches missed.">        switch( numSigBytes )</span>
        {
            case 3:
<span class="fc" id="L450">                destination[ destOffset     ] = ALPHABET[ (inBuff &gt;&gt;&gt; 18)        ];</span>
<span class="fc" id="L451">                destination[ destOffset + 1 ] = ALPHABET[ (inBuff &gt;&gt;&gt; 12) &amp; 0x3f ];</span>
<span class="fc" id="L452">                destination[ destOffset + 2 ] = ALPHABET[ (inBuff &gt;&gt;&gt;  6) &amp; 0x3f ];</span>
<span class="fc" id="L453">                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) &amp; 0x3f ];</span>
<span class="fc" id="L454">                return destination;</span>

            case 2:
<span class="fc" id="L457">                destination[ destOffset     ] = ALPHABET[ (inBuff &gt;&gt;&gt; 18)        ];</span>
<span class="fc" id="L458">                destination[ destOffset + 1 ] = ALPHABET[ (inBuff &gt;&gt;&gt; 12) &amp; 0x3f ];</span>
<span class="fc" id="L459">                destination[ destOffset + 2 ] = ALPHABET[ (inBuff &gt;&gt;&gt;  6) &amp; 0x3f ];</span>
<span class="fc" id="L460">                destination[ destOffset + 3 ] = EQUALS_SIGN;</span>
<span class="fc" id="L461">                return destination;</span>

            case 1:
<span class="fc" id="L464">                destination[ destOffset     ] = ALPHABET[ (inBuff &gt;&gt;&gt; 18)        ];</span>
<span class="fc" id="L465">                destination[ destOffset + 1 ] = ALPHABET[ (inBuff &gt;&gt;&gt; 12) &amp; 0x3f ];</span>
<span class="fc" id="L466">                destination[ destOffset + 2 ] = EQUALS_SIGN;</span>
<span class="fc" id="L467">                destination[ destOffset + 3 ] = EQUALS_SIGN;</span>
<span class="fc" id="L468">                return destination;</span>

            default:
<span class="nc" id="L471">                return destination;</span>
        }   // end switch
    }   // end encode3to4



    /**
     * Serializes an object and returns the Base64-encoded
     * version of that serialized object. If the object
     * cannot be serialized or there is another error,
     * the method will return {@code null}.
     * The object is not GZip-compressed before being encoded.
     *
     * @param serializableObject The object to encode
     * @return The Base64-encoded object
     * @since 1.4
     */
    public static String encodeObject( java.io.Serializable serializableObject )
    {
<span class="nc" id="L490">        return encodeObject( serializableObject, NO_OPTIONS );</span>
    }   // end encodeObject



    /**
     * Serializes an object and returns the Base64-encoded
     * version of that serialized object. If the object
     * cannot be serialized or there is another error,
     * the method will return {@code null}.
     * &lt;p&gt;
     * Valid options:&lt;pre&gt;
     *   GZIP: gzip-compresses object before encoding it.
     *   DONT_BREAK_LINES: don't break lines at 76 characters
     *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example: &lt;code&gt;encodeObject( myObj, Base64.GZIP )&lt;/code&gt; or
     * &lt;p&gt;
     * Example: &lt;code&gt;encodeObject( myObj, Base64.GZIP | Base64.DONT_BREAK_LINES )&lt;/code&gt;
     *
     * @param serializableObject The object to encode
     * @param options Specified options
     * @return The Base64-encoded object
     * @see Base64#GZIP
     * @see Base64#DONT_BREAK_LINES
     * @since 2.0
     */
    public static String encodeObject( java.io.Serializable serializableObject, int options )
    {
        // Streams
<span class="nc" id="L521">        java.io.ByteArrayOutputStream  baos  = null;</span>
<span class="nc" id="L522">        java.io.OutputStream           b64os = null;</span>
<span class="nc" id="L523">        java.io.ObjectOutputStream     oos   = null;</span>
<span class="nc" id="L524">        java.util.zip.GZIPOutputStream gzos  = null;</span>

        // Isolate options
<span class="nc" id="L527">        int gzip           = (options &amp; GZIP);</span>
        //int dontBreakLines = (options &amp; DONT_BREAK_LINES);

        try
        {
            // ObjectOutputStream -&gt; (GZIP) -&gt; Base64 -&gt; ByteArrayOutputStream
<span class="nc" id="L533">            baos  = new java.io.ByteArrayOutputStream();</span>
<span class="nc" id="L534">            b64os = new Base64.OutputStream( baos, ENCODE | options );</span>

            // GZip?
<span class="nc bnc" id="L537" title="All 2 branches missed.">            if( gzip == GZIP )</span>
            {
<span class="nc" id="L539">                gzos = new java.util.zip.GZIPOutputStream( b64os );</span>
<span class="nc" id="L540">                oos  = new java.io.ObjectOutputStream( gzos );</span>
            }   // end if: gzip
            else
<span class="nc" id="L543">                oos   = new java.io.ObjectOutputStream( b64os );</span>

<span class="nc" id="L545">            oos.writeObject( serializableObject );</span>
        }   // end try
<span class="nc" id="L547">        catch( java.io.IOException e )</span>
        {
<span class="nc" id="L549">            e.printStackTrace();</span>
<span class="nc" id="L550">            return null;</span>
        }   // end catch
        finally
        {
<span class="nc" id="L554">            try{ oos.close();   } catch( Exception e ){}</span>
<span class="nc" id="L555">            try{ gzos.close();  } catch( Exception e ){}</span>
<span class="nc" id="L556">            try{ b64os.close(); } catch( Exception e ){}</span>
<span class="nc" id="L557">            try{ baos.close();  } catch( Exception e ){}</span>
<span class="nc" id="L558">        }   // end finally</span>

        // Return value according to relevant encoding.
        try
        {
<span class="nc" id="L563">            return new String( baos.toByteArray(), PREFERRED_ENCODING );</span>
        }   // end try
<span class="nc" id="L565">        catch (java.io.UnsupportedEncodingException uue)</span>
        {
<span class="nc" id="L567">            return new String( baos.toByteArray() );</span>
        }   // end catch

    }   // end encode



    /**
     * Encodes a byte array into Base64 notation.
     * Does not GZip-compress data.
     *
     * @param source The data to convert
     * @return the encoded string
     * @since 1.4
     */
    public static String encodeBytes( byte[] source )
    {
<span class="fc" id="L584">        return encodeBytes( source, 0, source.length, NO_OPTIONS );</span>
    }   // end encodeBytes



    /**
     * Encodes a byte array into Base64 notation.
     * &lt;p&gt;
     * Valid options:&lt;pre&gt;
     *   GZIP: gzip-compresses object before encoding it.
     *   DONT_BREAK_LINES: don't break lines at 76 characters
     *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example: &lt;code&gt;encodeBytes( myData, Base64.GZIP )&lt;/code&gt; or
     * &lt;p&gt;
     * Example: &lt;code&gt;encodeBytes( myData, Base64.GZIP | Base64.DONT_BREAK_LINES )&lt;/code&gt;
     *
     *
     * @param source The data to convert
     * @param options Specified options
     * @return the encoded string
     * @see Base64#GZIP
     * @see Base64#DONT_BREAK_LINES
     * @since 2.0
     */
    public static String encodeBytes( byte[] source, int options )
    {
<span class="fc" id="L612">        return encodeBytes( source, 0, source.length, options );</span>
    }   // end encodeBytes


    /**
     * Encodes a byte array into Base64 notation.
     * Does not GZip-compress data.
     *
     * @param source The data to convert
     * @param off Offset in array where conversion should begin
     * @param len Length of data to convert
     * @return the encoded string
     * @since 1.4
     */
    public static String encodeBytes( byte[] source, int off, int len )
    {
<span class="nc" id="L628">        return encodeBytes( source, off, len, NO_OPTIONS );</span>
    }   // end encodeBytes



    /**
     * Encodes a byte array into Base64 notation.
     * &lt;p&gt;
     * Valid options:&lt;pre&gt;
     *   GZIP: gzip-compresses object before encoding it.
     *   DONT_BREAK_LINES: don't break lines at 76 characters
     *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example: &lt;code&gt;encodeBytes( myData, Base64.GZIP )&lt;/code&gt; or
     * &lt;p&gt;
     * Example: &lt;code&gt;encodeBytes( myData, Base64.GZIP | Base64.DONT_BREAK_LINES )&lt;/code&gt;
     *
     *
     * @param source The data to convert
     * @param off Offset in array where conversion should begin
     * @param len Length of data to convert
     * @param options Specified options; alphabet type is pulled from this (standard, url-safe, ordered)
     * @return the encoded string
     * @see Base64#GZIP
     * @see Base64#DONT_BREAK_LINES
     * @since 2.0
     */
    public static String encodeBytes( byte[] source, int off, int len, int options )
    {
        // Isolate options
<span class="fc" id="L659">        int dontBreakLines = ( options &amp; DONT_BREAK_LINES );</span>
<span class="fc" id="L660">        int gzip           = ( options &amp; GZIP   );</span>

        // Compress?
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">        if( gzip == GZIP )</span>
        {
<span class="nc" id="L665">            java.io.ByteArrayOutputStream  baos  = null;</span>
<span class="nc" id="L666">            java.util.zip.GZIPOutputStream gzos  = null;</span>
<span class="nc" id="L667">            Base64.OutputStream            b64os = null;</span>


            try
            {
                // GZip -&gt; Base64 -&gt; ByteArray
<span class="nc" id="L673">                baos = new java.io.ByteArrayOutputStream();</span>
<span class="nc" id="L674">                b64os = new Base64.OutputStream( baos, ENCODE | options );</span>
<span class="nc" id="L675">                gzos  = new java.util.zip.GZIPOutputStream( b64os );</span>

<span class="nc" id="L677">                gzos.write( source, off, len );</span>
<span class="nc" id="L678">                gzos.close();</span>
            }   // end try
<span class="nc" id="L680">            catch( java.io.IOException e )</span>
            {
<span class="nc" id="L682">                e.printStackTrace();</span>
<span class="nc" id="L683">                return null;</span>
            }   // end catch
            finally
            {
<span class="nc" id="L687">                try{ gzos.close();  } catch( Exception e ){}</span>
<span class="nc" id="L688">                try{ b64os.close(); } catch( Exception e ){}</span>
<span class="nc" id="L689">                try{ baos.close();  } catch( Exception e ){}</span>
<span class="nc" id="L690">            }   // end finally</span>

            // Return value according to relevant encoding.
            try
            {
<span class="nc" id="L695">                return new String( baos.toByteArray(), PREFERRED_ENCODING );</span>
            }   // end try
<span class="nc" id="L697">            catch (java.io.UnsupportedEncodingException uue)</span>
            {
<span class="nc" id="L699">                return new String( baos.toByteArray() );</span>
            }   // end catch
        }   // end if: compress

        // Else, don't compress. Better not to use streams at all then.
        else
        {
            // Convert option to boolean in way that code likes it.
<span class="fc bfc" id="L707" title="All 2 branches covered.">            boolean breakLines = dontBreakLines == 0;</span>

<span class="fc" id="L709">            int    len43   = len * 4 / 3;</span>
<span class="fc bfc" id="L710" title="All 4 branches covered.">            byte[] outBuff = new byte[   ( len43 )                      // Main 4:3</span>
                                       + ( (len % 3) &gt; 0 ? 4 : 0 )      // Account for padding
                                       + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines
<span class="fc" id="L713">            int d = 0;</span>
<span class="fc" id="L714">            int e = 0;</span>
<span class="fc" id="L715">            int len2 = len - 2;</span>
<span class="fc" id="L716">            int lineLength = 0;</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">            for( ; d &lt; len2; d+=3, e+=4 )</span>
            {
<span class="fc" id="L719">                encode3to4( source, d+off, 3, outBuff, e, options );</span>

<span class="fc" id="L721">                lineLength += 4;</span>
<span class="fc bfc" id="L722" title="All 4 branches covered.">                if( breakLines &amp;&amp; lineLength == MAX_LINE_LENGTH )</span>
                {
<span class="fc" id="L724">                    outBuff[e+4] = NEW_LINE;</span>
<span class="fc" id="L725">                    e++;</span>
<span class="fc" id="L726">                    lineLength = 0;</span>
                }   // end if: end of line
            }   // en dfor: each piece of array

<span class="fc bfc" id="L730" title="All 2 branches covered.">            if( d &lt; len )</span>
            {
<span class="fc" id="L732">                encode3to4( source, d+off, len - d, outBuff, e, options );</span>
<span class="fc" id="L733">                e += 4;</span>
            }   // end if: some padding needed


            // Return value according to relevant encoding.
            try
            {
<span class="fc" id="L740">                return new String( outBuff, 0, e, PREFERRED_ENCODING );</span>
            }   // end try
<span class="nc" id="L742">            catch (java.io.UnsupportedEncodingException uue)</span>
            {
<span class="nc" id="L744">                return new String( outBuff, 0, e );</span>
            }   // end catch

        }   // end else: don't compress

    }   // end encodeBytes





/* ********  D E C O D I N G   M E T H O D S  ******** */


    /**
     * Decodes four bytes from array &lt;var&gt;source&lt;/var&gt;
     * and writes the resulting bytes (up to three of them)
     * to &lt;var&gt;destination&lt;/var&gt;.
     * The source and destination arrays can be manipulated
     * anywhere along their length by specifying
     * &lt;var&gt;srcOffset&lt;/var&gt; and &lt;var&gt;destOffset&lt;/var&gt;.
     * This method does not check to make sure your arrays
     * are large enough to accomodate &lt;var&gt;srcOffset&lt;/var&gt; + 4 for
     * the &lt;var&gt;source&lt;/var&gt; array or &lt;var&gt;destOffset&lt;/var&gt; + 3 for
     * the &lt;var&gt;destination&lt;/var&gt; array.
     * This method returns the actual number of bytes that
     * were converted from the Base64 encoding.
     * &lt;p&gt;This is the lowest level of the decoding methods with
     * all possible parameters.&lt;/p&gt;
     *
     *
     * @param source the array to convert
     * @param srcOffset the index where conversion begins
     * @param destination the array to hold the conversion
     * @param destOffset the index where output will be put
     * @param options alphabet type is pulled from this (standard, url-safe, ordered)
     * @return the number of decoded bytes converted
     * @since 1.3
     */
    private static int decode4to3( byte[] source, int srcOffset, byte[] destination, int destOffset, int options )
    {
<span class="fc" id="L785">        byte[] DECODABET = getDecodabet( options );</span>

        // Example: Dk==
<span class="fc bfc" id="L788" title="All 2 branches covered.">        if( source[ srcOffset + 2] == EQUALS_SIGN )</span>
        {
            // Two ways to do the same thing. Don't know which way I like best.
            //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] &lt;&lt; 24 ) &gt;&gt;&gt;  6 )
            //              | ( ( DECODABET[ source[ srcOffset + 1] ] &lt;&lt; 24 ) &gt;&gt;&gt; 12 );
<span class="fc" id="L793">            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] &amp; 0xFF ) &lt;&lt; 18 )</span>
                          | ( ( DECODABET[ source[ srcOffset + 1] ] &amp; 0xFF ) &lt;&lt; 12 );

<span class="fc" id="L796">            destination[ destOffset ] = (byte)( outBuff &gt;&gt;&gt; 16 );</span>
<span class="fc" id="L797">            return 1;</span>
        }

        // Example: DkL=
<span class="pc bpc" id="L801" title="1 of 2 branches missed.">        else if( source[ srcOffset + 3 ] == EQUALS_SIGN )</span>
        {
            // Two ways to do the same thing. Don't know which way I like best.
            //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] &lt;&lt; 24 ) &gt;&gt;&gt;  6 )
            //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 12 )
            //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 18 );
<span class="nc" id="L807">            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] &amp; 0xFF ) &lt;&lt; 18 )</span>
                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] &amp; 0xFF ) &lt;&lt; 12 )
                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] &amp; 0xFF ) &lt;&lt;  6 );

<span class="nc" id="L811">            destination[ destOffset     ] = (byte)( outBuff &gt;&gt;&gt; 16 );</span>
<span class="nc" id="L812">            destination[ destOffset + 1 ] = (byte)( outBuff &gt;&gt;&gt;  8 );</span>
<span class="nc" id="L813">            return 2;</span>
        }

        // Example: DkLE
        else
        {
            try{
            // Two ways to do the same thing. Don't know which way I like best.
            //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] &lt;&lt; 24 ) &gt;&gt;&gt;  6 )
            //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 12 )
            //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 18 )
            //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 24 );
<span class="fc" id="L825">            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] &amp; 0xFF ) &lt;&lt; 18 )</span>
                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] &amp; 0xFF ) &lt;&lt; 12 )
                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] &amp; 0xFF ) &lt;&lt;  6)
                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] &amp; 0xFF )      );


<span class="fc" id="L831">            destination[ destOffset     ] = (byte)( outBuff &gt;&gt; 16 );</span>
<span class="fc" id="L832">            destination[ destOffset + 1 ] = (byte)( outBuff &gt;&gt;  8 );</span>
<span class="fc" id="L833">            destination[ destOffset + 2 ] = (byte)( outBuff       );</span>

<span class="fc" id="L835">            return 3;</span>
<span class="nc" id="L836">            }catch( Exception e){</span>
<span class="nc" id="L837">                System.out.println(&quot;&quot;+source[srcOffset]+ &quot;: &quot; + ( DECODABET[ source[ srcOffset     ] ]  ) );</span>
<span class="nc" id="L838">                System.out.println(&quot;&quot;+source[srcOffset+1]+  &quot;: &quot; + ( DECODABET[ source[ srcOffset + 1 ] ]  ) );</span>
<span class="nc" id="L839">                System.out.println(&quot;&quot;+source[srcOffset+2]+  &quot;: &quot; + ( DECODABET[ source[ srcOffset + 2 ] ]  ) );</span>
<span class="nc" id="L840">                System.out.println(&quot;&quot;+source[srcOffset+3]+  &quot;: &quot; + ( DECODABET[ source[ srcOffset + 3 ] ]  ) );</span>
<span class="nc" id="L841">                return -1;</span>
            }   // end catch
        }
    }   // end decodeToBytes




    /**
     * Very low-level access to decoding ASCII characters in
     * the form of a byte array. Does not support automatically
     * gunzipping or any other &quot;fancy&quot; features.
     *
     * @param source The Base64 encoded data
     * @param off    The offset of where to begin decoding
     * @param len    The length of characters to decode
     * @param options alphabet type is pulled from this (standard, url-safe, ordered)
     * @return decoded data
     * @since 1.3
     */
    public static byte[] decode( byte[] source, int off, int len, int options )
    {
<span class="fc" id="L863">        byte[] DECODABET = getDecodabet( options );</span>

<span class="fc" id="L865">        int    len34   = len * 3 / 4;</span>
<span class="fc" id="L866">        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output</span>
<span class="fc" id="L867">        int    outBuffPosn = 0;</span>

<span class="fc" id="L869">        byte[] b4        = new byte[4];</span>
<span class="fc" id="L870">        int    b4Posn    = 0;</span>
<span class="fc" id="L871">        int    i         = 0;</span>
<span class="fc" id="L872">        byte   sbiCrop   = 0;</span>
<span class="fc" id="L873">        byte   sbiDecode = 0;</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">        for( i = off; i &lt; off+len; i++ )</span>
        {
<span class="fc" id="L876">            sbiCrop = (byte)(source[i] &amp; 0x7f); // Only the low seven bits</span>
<span class="fc" id="L877">            sbiDecode = DECODABET[ sbiCrop ];</span>

<span class="pc bpc" id="L879" title="1 of 2 branches missed.">            if( sbiDecode &gt;= WHITE_SPACE_ENC ) // White space, Equals sign or better</span>
            {
<span class="pc bpc" id="L881" title="1 of 2 branches missed.">                if( sbiDecode &gt;= EQUALS_SIGN_ENC )</span>
                {
<span class="fc" id="L883">                    b4[ b4Posn++ ] = sbiCrop;</span>
<span class="fc bfc" id="L884" title="All 2 branches covered.">                    if( b4Posn &gt; 3 )</span>
                    {
<span class="fc" id="L886">                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );</span>
<span class="fc" id="L887">                        b4Posn = 0;</span>

                        // If that was the equals sign, break out of 'for' loop
<span class="fc bfc" id="L890" title="All 2 branches covered.">                        if( sbiCrop == EQUALS_SIGN )</span>
<span class="fc" id="L891">                            break;</span>
                    }   // end if: quartet built

                }   // end if: equals sign or better

            }   // end if: white space, equals sign or better
            else
            {
<span class="nc" id="L899">                System.err.println( &quot;Bad Base64 input character at &quot; + i + &quot;: &quot; + source[i] + &quot;(decimal)&quot; );</span>
<span class="nc" id="L900">                return null;</span>
            }   // end else:
        }   // each input character

<span class="fc" id="L904">        byte[] out = new byte[ outBuffPosn ];</span>
<span class="fc" id="L905">        System.arraycopy( outBuff, 0, out, 0, outBuffPosn );</span>
<span class="fc" id="L906">        return out;</span>
    }   // end decode




    /**
     * Decodes data from Base64 notation, automatically
     * detecting gzip-compressed data and decompressing it.
     *
     * @param s the string to decode
     * @return the decoded data
     * @since 1.4
     */
    public static byte[] decode( String s )
    {
<span class="fc" id="L922">        return decode( s, NO_OPTIONS );</span>
    }


    /**
     * Decodes data from Base64 notation, automatically
     * detecting gzip-compressed data and decompressing it.
     *
     * @param s the string to decode
     * @param options encode options such as URL_SAFE
     * @return the decoded data
     * @since 1.4
     */
    public static byte[] decode( String s, int options )
    {
        byte[] bytes;
        try
        {
<span class="fc" id="L940">            bytes = s.getBytes( PREFERRED_ENCODING );</span>
        }   // end try
<span class="nc" id="L942">        catch( java.io.UnsupportedEncodingException uee )</span>
        {
<span class="nc" id="L944">            bytes = s.getBytes();</span>
<span class="fc" id="L945">        }   // end catch</span>
        //&lt;/change&gt;

        // Decode
<span class="fc" id="L949">        bytes = decode( bytes, 0, bytes.length, options );</span>


        // Check to see if it's gzip-compressed
        // GZIP Magic Two-Byte Number: 0x8b1f (35615)
<span class="pc bpc" id="L954" title="2 of 4 branches missed.">        if( bytes != null &amp;&amp; bytes.length &gt;= 4 )</span>
        {

<span class="fc" id="L957">            int head = ((int)bytes[0] &amp; 0xff) | ((bytes[1] &lt;&lt; 8) &amp; 0xff00);</span>
<span class="pc bpc" id="L958" title="1 of 2 branches missed.">            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )</span>
            {
<span class="nc" id="L960">                java.io.ByteArrayInputStream  bais = null;</span>
<span class="nc" id="L961">                java.util.zip.GZIPInputStream gzis = null;</span>
<span class="nc" id="L962">                java.io.ByteArrayOutputStream baos = null;</span>
<span class="nc" id="L963">                byte[] buffer = new byte[2048];</span>
<span class="nc" id="L964">                int    length = 0;</span>

                try
                {
<span class="nc" id="L968">                    baos = new java.io.ByteArrayOutputStream();</span>
<span class="nc" id="L969">                    bais = new java.io.ByteArrayInputStream( bytes );</span>
<span class="nc" id="L970">                    gzis = new java.util.zip.GZIPInputStream( bais );</span>

<span class="nc bnc" id="L972" title="All 2 branches missed.">                    while( ( length = gzis.read( buffer ) ) &gt;= 0 )</span>
                    {
<span class="nc" id="L974">                        baos.write(buffer,0,length);</span>
                    }   // end while: reading input

                    // No error? Get new bytes.
<span class="nc" id="L978">                    bytes = baos.toByteArray();</span>

                }   // end try
<span class="nc" id="L981">                catch( java.io.IOException e )</span>
                {
                    // Just return originally-decoded bytes
                }   // end catch
                finally
                {
<span class="nc" id="L987">                    try{ baos.close(); } catch( Exception e ){}</span>
<span class="nc" id="L988">                    try{ gzis.close(); } catch( Exception e ){}</span>
<span class="nc" id="L989">                    try{ bais.close(); } catch( Exception e ){}</span>
<span class="nc" id="L990">                }   // end finally</span>

            }   // end if: gzipped
        }   // end if: bytes.length &gt;= 2

<span class="fc" id="L995">        return bytes;</span>
    }   // end decode




    /**
     * Attempts to decode Base64 data and deserialize a Java
     * Object within. Returns {@code null} if there was an error.
     *
     * @param encodedObject The Base64 data to decode
     * @return The decoded and deserialized object
     * @since 1.5
     */
    public static Object decodeToObject( String encodedObject )
    {
        // Decode and gunzip if necessary
<span class="nc" id="L1012">        byte[] objBytes = decode( encodedObject );</span>

<span class="nc" id="L1014">        java.io.ByteArrayInputStream  bais = null;</span>
<span class="nc" id="L1015">        java.io.ObjectInputStream     ois  = null;</span>
<span class="nc" id="L1016">        Object obj = null;</span>

        try
        {
<span class="nc" id="L1020">            bais = new java.io.ByteArrayInputStream( objBytes );</span>
<span class="nc" id="L1021">            ois  = new java.io.ObjectInputStream( bais );</span>

<span class="nc" id="L1023">            obj = ois.readObject();</span>
        }   // end try
<span class="nc" id="L1025">        catch( java.io.IOException e )</span>
        {
<span class="nc" id="L1027">            e.printStackTrace();</span>
<span class="nc" id="L1028">            obj = null;</span>
        }   // end catch
<span class="nc" id="L1030">        catch( java.lang.ClassNotFoundException e )</span>
        {
<span class="nc" id="L1032">            e.printStackTrace();</span>
<span class="nc" id="L1033">            obj = null;</span>
        }   // end catch
        finally
        {
<span class="nc" id="L1037">            try{ bais.close(); } catch( Exception e ){}</span>
<span class="nc" id="L1038">            try{ ois.close();  } catch( Exception e ){}</span>
<span class="nc" id="L1039">        }   // end finally</span>

<span class="nc" id="L1041">        return obj;</span>
    }   // end decodeObject



    /**
     * Convenience method for encoding data to a file.
     *
     * @param dataToEncode byte array of data to encode in base64 form
     * @param filename Filename for saving encoded data
     * @return {@code true} if successful, {@code false} otherwise
     *
     * @since 2.1
     */
    public static boolean encodeToFile( byte[] dataToEncode, String filename )
    {
<span class="nc" id="L1057">        boolean success = false;</span>
<span class="nc" id="L1058">        Base64.OutputStream bos = null;</span>
        try
        {
<span class="nc" id="L1061">            bos = new Base64.OutputStream(</span>
                      new java.io.FileOutputStream( filename ), Base64.ENCODE );
<span class="nc" id="L1063">            bos.write( dataToEncode );</span>
<span class="nc" id="L1064">            success = true;</span>
        }   // end try
<span class="nc" id="L1066">        catch( java.io.IOException e )</span>
        {

<span class="nc" id="L1069">            success = false;</span>
        }   // end catch: IOException
        finally
        {
<span class="nc" id="L1073">            try{ bos.close(); } catch( Exception e ){}</span>
<span class="nc" id="L1074">        }   // end finally</span>

<span class="nc" id="L1076">        return success;</span>
    }   // end encodeToFile


    /**
     * Convenience method for decoding data to a file.
     *
     * @param dataToDecode Base64-encoded data as a string
     * @param filename Filename for saving decoded data
     * @return {@code true} if successful, {@code false} otherwise
     *
     * @since 2.1
     */
    public static boolean decodeToFile( String dataToDecode, String filename )
    {
<span class="nc" id="L1091">        boolean success = false;</span>
<span class="nc" id="L1092">        Base64.OutputStream bos = null;</span>
        try
        {
<span class="nc" id="L1095">                bos = new Base64.OutputStream(</span>
                          new java.io.FileOutputStream( filename ), Base64.DECODE );
<span class="nc" id="L1097">                bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );</span>
<span class="nc" id="L1098">                success = true;</span>
        }   // end try
<span class="nc" id="L1100">        catch( java.io.IOException e )</span>
        {
<span class="nc" id="L1102">            success = false;</span>
        }   // end catch: IOException
        finally
        {
<span class="nc" id="L1106">                try{ bos.close(); } catch( Exception e ){}</span>
<span class="nc" id="L1107">        }   // end finally</span>

<span class="nc" id="L1109">        return success;</span>
    }   // end decodeToFile




    /**
     * Convenience method for reading a base64-encoded
     * file and decoding it.
     *
     * @param filename Filename for reading encoded data
     * @return decoded byte array or null if unsuccessful
     *
     * @since 2.1
     */
    public static byte[] decodeFromFile( String filename )
    {
<span class="nc" id="L1126">        byte[] decodedData = null;</span>
<span class="nc" id="L1127">        Base64.InputStream bis = null;</span>
        try
        {
            // Set up some useful variables
<span class="nc" id="L1131">            java.io.File file = new java.io.File( filename );</span>
<span class="nc" id="L1132">            byte[] buffer = null;</span>
<span class="nc" id="L1133">            int length   = 0;</span>
<span class="nc" id="L1134">            int numBytes = 0;</span>

            // Check for size of file
<span class="nc bnc" id="L1137" title="All 2 branches missed.">            if( file.length() &gt; Integer.MAX_VALUE )</span>
            {
<span class="nc" id="L1139">                System.err.println( &quot;File is too big for this convenience method (&quot; + file.length() + &quot; bytes).&quot; );</span>
<span class="nc" id="L1140">                return null;</span>
            }   // end if: file too big for int index
<span class="nc" id="L1142">            buffer = new byte[ (int)file.length() ];</span>

            // Open a stream
<span class="nc" id="L1145">            bis = new Base64.InputStream(</span>
                      new java.io.BufferedInputStream(
                      new java.io.FileInputStream( file ) ), Base64.DECODE );

            // Read until done
<span class="nc bnc" id="L1150" title="All 2 branches missed.">            while( ( numBytes = bis.read( buffer, length, 4096 ) ) &gt;= 0 )</span>
<span class="nc" id="L1151">                length += numBytes;</span>

            // Save in a variable to return
<span class="nc" id="L1154">            decodedData = new byte[ length ];</span>
<span class="nc" id="L1155">            System.arraycopy( buffer, 0, decodedData, 0, length );</span>

        }   // end try
<span class="nc" id="L1158">        catch( java.io.IOException e )</span>
        {
<span class="nc" id="L1160">            System.err.println( &quot;Error decoding from file &quot; + filename );</span>
        }   // end catch: IOException
        finally
        {
<span class="nc" id="L1164">            try{ bis.close(); } catch( Exception e) {}</span>
<span class="nc" id="L1165">        }   // end finally</span>

<span class="nc" id="L1167">        return decodedData;</span>
    }   // end decodeFromFile



    /**
     * Convenience method for reading a binary file
     * and base64-encoding it.
     *
     * @param filename Filename for reading binary data
     * @return base64-encoded string or null if unsuccessful
     *
     * @since 2.1
     */
    public static String encodeFromFile( String filename )
    {
<span class="nc" id="L1183">        String encodedData = null;</span>
<span class="nc" id="L1184">        Base64.InputStream bis = null;</span>
        try
        {
            // Set up some useful variables
<span class="nc" id="L1188">            java.io.File file = new java.io.File( filename );</span>
<span class="nc" id="L1189">            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4),40) ]; // Need max() for math on small files (v2.2.1)</span>
<span class="nc" id="L1190">            int length   = 0;</span>
<span class="nc" id="L1191">            int numBytes = 0;</span>

            // Open a stream
<span class="nc" id="L1194">            bis = new Base64.InputStream(</span>
                      new java.io.BufferedInputStream(
                      new java.io.FileInputStream( file ) ), Base64.ENCODE );

            // Read until done
<span class="nc bnc" id="L1199" title="All 2 branches missed.">            while( ( numBytes = bis.read( buffer, length, 4096 ) ) &gt;= 0 )</span>
<span class="nc" id="L1200">                length += numBytes;</span>

            // Save in a variable to return
<span class="nc" id="L1203">            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );</span>

        }   // end try
<span class="nc" id="L1206">        catch( java.io.IOException e )</span>
        {
<span class="nc" id="L1208">            System.err.println( &quot;Error encoding from file &quot; + filename );</span>
        }   // end catch: IOException
        finally
        {
<span class="nc" id="L1212">            try{ bis.close(); } catch( Exception e) {}</span>
<span class="nc" id="L1213">        }   // end finally</span>

<span class="nc" id="L1215">        return encodedData;</span>
        }   // end encodeFromFile

    /**
     * Reads {@code infile} and encodes it to {@code outfile}.
     *
     * @param infile Input file
     * @param outfile Output file
     * @since 2.2
     */
    public static void encodeFileToFile( String infile, String outfile )
    {
<span class="nc" id="L1227">        String encoded = Base64.encodeFromFile( infile );</span>
<span class="nc" id="L1228">        java.io.OutputStream out = null;</span>
        try{
<span class="nc" id="L1230">            out = new java.io.BufferedOutputStream(</span>
                  new java.io.FileOutputStream( outfile ) );
<span class="nc" id="L1232">            out.write( encoded.getBytes(&quot;US-ASCII&quot;) ); // Strict, 7-bit output.</span>
        }   // end try
<span class="nc" id="L1234">        catch( java.io.IOException ex ) {</span>
<span class="nc" id="L1235">            ex.printStackTrace();</span>
        }   // end catch
        finally {
<span class="nc" id="L1238">            try { out.close(); }</span>
<span class="nc" id="L1239">            catch( Exception ex ){}</span>
<span class="nc" id="L1240">        }   // end finally</span>
<span class="nc" id="L1241">    }   // end encodeFileToFile</span>


    /**
     * Reads {@code infile} and decodes it to {@code outfile}.
     *
     * @param infile Input file
     * @param outfile Output file
     * @since 2.2
     */
    public static void decodeFileToFile( String infile, String outfile )
    {
<span class="nc" id="L1253">        byte[] decoded = Base64.decodeFromFile( infile );</span>
<span class="nc" id="L1254">        java.io.OutputStream out = null;</span>
        try{
<span class="nc" id="L1256">            out = new java.io.BufferedOutputStream(</span>
                  new java.io.FileOutputStream( outfile ) );
<span class="nc" id="L1258">            out.write( decoded );</span>
        }   // end try
<span class="nc" id="L1260">        catch( java.io.IOException ex ) {</span>
<span class="nc" id="L1261">            ex.printStackTrace();</span>
        }   // end catch
        finally {
<span class="nc" id="L1264">            try { out.close(); }</span>
<span class="nc" id="L1265">            catch( Exception ex ){}</span>
<span class="nc" id="L1266">        }   // end finally</span>
<span class="nc" id="L1267">    }   // end decodeFileToFile</span>


    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */



    /**
     * A {@link Base64.InputStream} will read data from another
     * {@code java.io.InputStream}, given in the constructor,
     * and encode/decode to/from Base64 notation on the fly.
     *
     * @see Base64
     * @since 1.3
     */
    public static class InputStream extends java.io.FilterInputStream
    {
        private boolean encode;         // Encoding or decoding
        private int     position;       // Current position in the buffer
        private byte[]  buffer;         // Small buffer holding converted data
        private int     bufferLength;   // Length of buffer (3 or 4)
        private int     numSigBytes;    // Number of meaningful bytes in the buffer
        private int     lineLength;
        private boolean breakLines;     // Break lines at less than 80 characters
        private int     options;        // Record options used to create the stream.
        private byte[]  alphabet;	    // Local copies to avoid extra method calls
        private byte[]  decodabet;		// Local copies to avoid extra method calls


        /**
         * Constructs a {@link Base64.InputStream} in DECODE mode.
         *
         * @param in the {@code java.io.InputStream} from which to read data.
         * @since 1.3
         */
        public InputStream( java.io.InputStream in )
        {
<span class="nc" id="L1304">            this( in, DECODE );</span>
<span class="nc" id="L1305">        }   // end constructor</span>


        /**
         * Constructs a {@link Base64.InputStream} in
         * either ENCODE or DECODE mode.
         * &lt;p&gt;
         * Valid options:&lt;pre&gt;
         *   ENCODE or DECODE: Encode or Decode as data is read.
         *   DONT_BREAK_LINES: don't break lines at 76 characters
         *     (only meaningful when encoding)
         *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
         * &lt;/pre&gt;
         * &lt;p&gt;
         * Example: &lt;code&gt;new Base64.InputStream( in, Base64.DECODE )&lt;/code&gt;
         *
         *
         * @param in the {@code java.io.InputStream} from which to read data.
         * @param options Specified options
         * @see Base64#ENCODE
         * @see Base64#DECODE
         * @see Base64#DONT_BREAK_LINES
         * @since 2.0
         */
        public InputStream( java.io.InputStream in, int options )
        {
<span class="nc" id="L1331">            super( in );</span>
<span class="nc bnc" id="L1332" title="All 2 branches missed.">            this.breakLines   = (options &amp; DONT_BREAK_LINES) != DONT_BREAK_LINES;</span>
<span class="nc bnc" id="L1333" title="All 2 branches missed.">            this.encode       = (options &amp; ENCODE) == ENCODE;</span>
<span class="nc bnc" id="L1334" title="All 2 branches missed.">            this.bufferLength = encode ? 4 : 3;</span>
<span class="nc" id="L1335">            this.buffer       = new byte[ bufferLength ];</span>
<span class="nc" id="L1336">            this.position     = -1;</span>
<span class="nc" id="L1337">            this.lineLength   = 0;</span>
<span class="nc" id="L1338">            this.options      = options; // Record for later, mostly to determine which alphabet to use</span>
<span class="nc" id="L1339">            this.alphabet     = getAlphabet(options);</span>
<span class="nc" id="L1340">            this.decodabet    = getDecodabet(options);</span>
<span class="nc" id="L1341">        }   // end constructor</span>

        /**
         * Reads enough of the input stream to convert
         * to/from Base64 and returns the next byte.
         *
         * @return next byte
         * @since 1.3
         */
        @Override
        public int read() throws java.io.IOException
        {
            // Do we need to get data?
<span class="nc bnc" id="L1354" title="All 2 branches missed.">            if( position &lt; 0 )</span>
            {
<span class="nc bnc" id="L1356" title="All 2 branches missed.">                if( encode )</span>
                {
<span class="nc" id="L1358">                    byte[] b3 = new byte[3];</span>
<span class="nc" id="L1359">                    int numBinaryBytes = 0;</span>
<span class="nc bnc" id="L1360" title="All 2 branches missed.">                    for( int i = 0; i &lt; 3; i++ )</span>
                    {
                        try
                        {
<span class="nc" id="L1364">                            int b = in.read();</span>

                            // If end of stream, b is -1.
<span class="nc bnc" id="L1367" title="All 2 branches missed.">                            if( b &gt;= 0 )</span>
                            {
<span class="nc" id="L1369">                                b3[i] = (byte)b;</span>
<span class="nc" id="L1370">                                numBinaryBytes++;</span>
                            }   // end if: not end of stream

                        }   // end try: read
<span class="nc" id="L1374">                        catch( java.io.IOException e )</span>
                        {
                            // Only a problem if we got no data at all.
<span class="nc bnc" id="L1377" title="All 2 branches missed.">                            if( i == 0 )</span>
<span class="nc" id="L1378">                                throw e;</span>

<span class="nc" id="L1380">                        }   // end catch</span>
                    }   // end for: each needed input byte

<span class="nc bnc" id="L1383" title="All 2 branches missed.">                    if( numBinaryBytes &gt; 0 )</span>
                    {
<span class="nc" id="L1385">                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );</span>
<span class="nc" id="L1386">                        position = 0;</span>
<span class="nc" id="L1387">                        numSigBytes = 4;</span>
                    }   // end if: got data
                    else
                    {
<span class="nc" id="L1391">                        return -1;</span>
                    }   // end else
<span class="nc" id="L1393">                }   // end if: encoding</span>

                // Else decoding
                else
                {
<span class="nc" id="L1398">                    byte[] b4 = new byte[4];</span>
<span class="nc" id="L1399">                    int i = 0;</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">                    for( i = 0; i &lt; 4; i++ )</span>
                    {
                        // Read four &quot;meaningful&quot; bytes:
<span class="nc" id="L1403">                        int b = 0;</span>
<span class="nc" id="L1404">                        do{ b = in.read(); }</span>
<span class="nc bnc" id="L1405" title="All 4 branches missed.">                        while( b &gt;= 0 &amp;&amp; decodabet[ b &amp; 0x7f ] &lt;= WHITE_SPACE_ENC );</span>

<span class="nc bnc" id="L1407" title="All 2 branches missed.">                        if( b &lt; 0 )</span>
<span class="nc" id="L1408">                            break; // Reads a -1 if end of stream</span>

<span class="nc" id="L1410">                        b4[i] = (byte)b;</span>
                    }   // end for: each needed input byte

<span class="nc bnc" id="L1413" title="All 2 branches missed.">                    if( i == 4 )</span>
                    {
<span class="nc" id="L1415">                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );</span>
<span class="nc" id="L1416">                        position = 0;</span>
                    }   // end if: got four characters
<span class="nc bnc" id="L1418" title="All 2 branches missed.">                    else if( i == 0 ){</span>
<span class="nc" id="L1419">                        return -1;</span>
                    }   // end else if: also padded correctly
                    else
                    {
                        // Must have broken out from above.
<span class="nc" id="L1424">                        throw new java.io.IOException( &quot;Improperly padded Base64 input.&quot; );</span>
                    }   // end

                }   // end else: decode
            }   // end else: get data

            // Got data?
<span class="nc bnc" id="L1431" title="All 2 branches missed.">            if( position &gt;= 0 )</span>
            {
                // End of relevant data?
<span class="nc bnc" id="L1434" title="All 2 branches missed.">                if( /*!encode &amp;&amp;*/ position &gt;= numSigBytes )</span>
<span class="nc" id="L1435">                    return -1;</span>

<span class="nc bnc" id="L1437" title="All 6 branches missed.">                if( encode &amp;&amp; breakLines &amp;&amp; lineLength &gt;= MAX_LINE_LENGTH )</span>
                {
<span class="nc" id="L1439">                    lineLength = 0;</span>
<span class="nc" id="L1440">                    return '\n';</span>
                }   // end if
                else
                {
<span class="nc" id="L1444">                    lineLength++;   // This isn't important when decoding</span>
                                    // but throwing an extra &quot;if&quot; seems
                                    // just as wasteful.

<span class="nc" id="L1448">                    int b = buffer[ position++ ];</span>

<span class="nc bnc" id="L1450" title="All 2 branches missed.">                    if( position &gt;= bufferLength )</span>
<span class="nc" id="L1451">                        position = -1;</span>

<span class="nc" id="L1453">                    return b &amp; 0xFF; // This is how you &quot;cast&quot; a byte that's</span>
                                     // intended to be unsigned.
                }   // end else
            }   // end if: position &gt;= 0

            // Else error
            else
            {
                // When JDK1.4 is more accepted, use an assertion here.
<span class="nc" id="L1462">                throw new java.io.IOException( &quot;Error in Base64 code reading stream.&quot; );</span>
            }   // end else
        }   // end read


        /**
         * Calls {@link #read()} repeatedly until the end of stream
         * is reached or &lt;var&gt;len&lt;/var&gt; bytes are read.
         * Returns number of bytes read into array or -1 if
         * end of stream is encountered.
         *
         * @param dest array to hold values
         * @param off offset for array
         * @param len max number of bytes to read into array
         * @return bytes read into array or -1 if end of stream is encountered.
         * @since 1.3
         */
        @Override
        public int read( byte[] dest, int off, int len ) throws java.io.IOException
        {
            int i;
            int b;
<span class="nc bnc" id="L1484" title="All 2 branches missed.">            for( i = 0; i &lt; len; i++ )</span>
            {
<span class="nc" id="L1486">                b = read();</span>

                //if( b &lt; 0 &amp;&amp; i == 0 )
                //    return -1;

<span class="nc bnc" id="L1491" title="All 2 branches missed.">                if( b &gt;= 0 )</span>
<span class="nc" id="L1492">                    dest[off + i] = (byte)b;</span>
<span class="nc bnc" id="L1493" title="All 2 branches missed.">                else if( i == 0 )</span>
<span class="nc" id="L1494">                    return -1;</span>
                else
                    break; // Out of 'for' loop
            }   // end for: each byte read
<span class="nc" id="L1498">            return i;</span>
        }   // end read

    }   // end inner class InputStream






    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */



    /**
     * A {@link Base64.OutputStream} will write data to another
     * {@code java.io.OutputStream}, given in the constructor,
     * and encode/decode to/from Base64 notation on the fly.
     *
     * @see Base64
     * @since 1.3
     */
    public static class OutputStream extends java.io.FilterOutputStream
    {
        private boolean encode;
        private int     position;
        private byte[]  buffer;
        private int     bufferLength;
        private int     lineLength;
        private boolean breakLines;
        private byte[]  b4; // Scratch used in a few places
        private boolean suspendEncoding;
        private int options; // Record for later
        private byte[]  alphabet;	    // Local copies to avoid extra method calls
        private byte[]  decodabet;		// Local copies to avoid extra method calls

        /**
         * Constructs a {@link Base64.OutputStream} in ENCODE mode.
         *
         * @param out the {@code java.io.OutputStream} to which data will be written.
         * @since 1.3
         */
        public OutputStream( java.io.OutputStream out )
        {
<span class="nc" id="L1542">            this( out, ENCODE );</span>
<span class="nc" id="L1543">        }   // end constructor</span>


        /**
         * Constructs a {@link Base64.OutputStream} in
         * either ENCODE or DECODE mode.
         * &lt;p&gt;
         * Valid options:&lt;pre&gt;
         *   ENCODE or DECODE: Encode or Decode as data is read.
         *   DONT_BREAK_LINES: don't break lines at 76 characters
         *     (only meaningful when encoding)
         *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
         * &lt;/pre&gt;
         * &lt;p&gt;
         * Example: &lt;code&gt;new Base64.OutputStream( out, Base64.ENCODE )&lt;/code&gt;
         *
         * @param out the {@code java.io.OutputStream} to which data will be written.
         * @param options Specified options.
         * @see Base64#ENCODE
         * @see Base64#DECODE
         * @see Base64#DONT_BREAK_LINES
         * @since 1.3
         */
        public OutputStream( java.io.OutputStream out, int options )
        {
<span class="nc" id="L1568">            super( out );</span>
<span class="nc bnc" id="L1569" title="All 2 branches missed.">            this.breakLines   = (options &amp; DONT_BREAK_LINES) != DONT_BREAK_LINES;</span>
<span class="nc bnc" id="L1570" title="All 2 branches missed.">            this.encode       = (options &amp; ENCODE) == ENCODE;</span>
<span class="nc bnc" id="L1571" title="All 2 branches missed.">            this.bufferLength = encode ? 3 : 4;</span>
<span class="nc" id="L1572">            this.buffer       = new byte[ bufferLength ];</span>
<span class="nc" id="L1573">            this.position     = 0;</span>
<span class="nc" id="L1574">            this.lineLength   = 0;</span>
<span class="nc" id="L1575">            this.suspendEncoding = false;</span>
<span class="nc" id="L1576">            this.b4           = new byte[4];</span>
<span class="nc" id="L1577">            this.options      = options;</span>
<span class="nc" id="L1578">            this.alphabet     = getAlphabet(options);</span>
<span class="nc" id="L1579">            this.decodabet    = getDecodabet(options);</span>
<span class="nc" id="L1580">        }   // end constructor</span>


        /**
         * Writes the byte to the output stream after
         * converting to/from Base64 notation.
         * When encoding, bytes are buffered three
         * at a time before the output stream actually
         * gets a write() call.
         * When decoding, bytes are buffered four
         * at a time.
         *
         * @param theByte the byte to write
         * @since 1.3
         */
        @Override
        public void write(int theByte) throws java.io.IOException
        {
            // Encoding suspended?
<span class="nc bnc" id="L1599" title="All 2 branches missed.">            if( suspendEncoding )</span>
            {
<span class="nc" id="L1601">                super.out.write( theByte );</span>
<span class="nc" id="L1602">                return;</span>
            }   // end if: supsended

            // Encode?
<span class="nc bnc" id="L1606" title="All 2 branches missed.">            if( encode )</span>
            {
<span class="nc" id="L1608">                buffer[ position++ ] = (byte)theByte;</span>
<span class="nc bnc" id="L1609" title="All 2 branches missed.">                if( position &gt;= bufferLength )  // Enough to encode.</span>
                {
<span class="nc" id="L1611">                    out.write( encode3to4( b4, buffer, bufferLength, options ) );</span>

<span class="nc" id="L1613">                    lineLength += 4;</span>
<span class="nc bnc" id="L1614" title="All 4 branches missed.">                    if( breakLines &amp;&amp; lineLength &gt;= MAX_LINE_LENGTH )</span>
                    {
<span class="nc" id="L1616">                        out.write( NEW_LINE );</span>
<span class="nc" id="L1617">                        lineLength = 0;</span>
                    }   // end if: end of line

<span class="nc" id="L1620">                    position = 0;</span>
                }   // end if: enough to output
            }   // end if: encoding

            // Else, Decoding
            else
            {
                // Meaningful Base64 character?
<span class="nc bnc" id="L1628" title="All 2 branches missed.">                if( decodabet[ theByte &amp; 0x7f ] &gt; WHITE_SPACE_ENC )</span>
                {
<span class="nc" id="L1630">                    buffer[ position++ ] = (byte)theByte;</span>
<span class="nc bnc" id="L1631" title="All 2 branches missed.">                    if( position &gt;= bufferLength )  // Enough to output.</span>
                    {
<span class="nc" id="L1633">                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );</span>
<span class="nc" id="L1634">                        out.write( b4, 0, len );</span>
                        //out.write( Base64.decode4to3( buffer ) );
<span class="nc" id="L1636">                        position = 0;</span>
<span class="nc" id="L1637">                    }   // end if: enough to output</span>
                }   // end if: meaningful base64 character
<span class="nc bnc" id="L1639" title="All 2 branches missed.">                else if( decodabet[ theByte &amp; 0x7f ] != WHITE_SPACE_ENC )</span>
                {
<span class="nc" id="L1641">                    throw new java.io.IOException( &quot;Invalid character in Base64 data.&quot; );</span>
                }   // end else: not white space either
            }   // end else: decoding
<span class="nc" id="L1644">        }   // end write</span>



        /**
         * Calls {@link #write(int)} repeatedly until &lt;var&gt;len&lt;/var&gt;
         * bytes are written.
         *
         * @param theBytes array from which to read bytes
         * @param off offset for array
         * @param len max number of bytes to read into array
         * @since 1.3
         */
        @Override
        public void write( byte[] theBytes, int off, int len ) throws java.io.IOException
        {
            // Encoding suspended?
<span class="nc bnc" id="L1661" title="All 2 branches missed.">            if( suspendEncoding )</span>
            {
<span class="nc" id="L1663">                super.out.write( theBytes, off, len );</span>
<span class="nc" id="L1664">                return;</span>
            }   // end if: supsended

<span class="nc bnc" id="L1667" title="All 2 branches missed.">            for( int i = 0; i &lt; len; i++ )</span>
            {
<span class="nc" id="L1669">                write( theBytes[ off + i ] );</span>
            }   // end for: each byte written

<span class="nc" id="L1672">        }   // end write</span>



        /**
         * Method added by PHIL. [Thanks, PHIL. -Rob]
         * This pads the buffer without closing the stream.
         * @throws java.io.IOException if there was an error flushing the stream
         */
        public void flushBase64() throws java.io.IOException
        {
<span class="nc bnc" id="L1683" title="All 2 branches missed.">            if( position &gt; 0 )</span>
            {
<span class="nc bnc" id="L1685" title="All 2 branches missed.">                if( encode )</span>
                {
<span class="nc" id="L1687">                    out.write( encode3to4( b4, buffer, position, options ) );</span>
<span class="nc" id="L1688">                    position = 0;</span>
                }   // end if: encoding
                else
                {
<span class="nc" id="L1692">                    throw new java.io.IOException( &quot;Base64 input not properly padded.&quot; );</span>
                }   // end else: decoding
            }   // end if: buffer partially full

<span class="nc" id="L1696">        }   // end flush</span>


        /**
         * Flushes and closes (I think, in the superclass) the stream.
         *
         * @since 1.3
         */
        @Override
        public void close() throws java.io.IOException
        {
            // 1. Ensure that pending characters are written
<span class="nc" id="L1708">            flushBase64();</span>

            // 2. Actually close the stream
            // Base class both flushes and closes.
<span class="nc" id="L1712">            super.close();</span>

<span class="nc" id="L1714">            buffer = null;</span>
<span class="nc" id="L1715">            out    = null;</span>
<span class="nc" id="L1716">        }   // end close</span>



        /**
         * Suspends encoding of the stream.
         * May be helpful if you need to embed a piece of
         * base640-encoded data in a stream.
         *
         * @throws java.io.IOException if there was an error flushing the stream
         * @since 1.5.1
         */
        public void suspendEncoding() throws java.io.IOException
        {
<span class="nc" id="L1730">            flushBase64();</span>
<span class="nc" id="L1731">            this.suspendEncoding = true;</span>
<span class="nc" id="L1732">        }   // end suspendEncoding</span>


        /**
         * Resumes encoding of the stream.
         * May be helpful if you need to embed a piece of
         * base640-encoded data in a stream.
         *
         * @since 1.5.1
         */
        public void resumeEncoding()
        {
<span class="nc" id="L1744">            this.suspendEncoding = false;</span>
<span class="nc" id="L1745">        }   // end resumeEncoding</span>



    }   // end inner class OutputStream


}   // end class Base64
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>