<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FastDateFormat.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Core XMPP Server</a> &gt; <a href="index.source.html" class="el_package">org.jivesoftware.util</a> &gt; <span class="el_source">FastDateFormat.java</span></div><h1>FastDateFormat.java</h1><pre class="source lang-java linenums">/* ====================================================================
 * Trove - Copyright (c) 1997-2001 Walt Disney Internet Group
 * ====================================================================
 * The Tea Software License, Version 1.1
 *
 * Copyright (c) 2000 Walt Disney Internet Group. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       &quot;This product includes software developed by the
 *        Walt Disney Internet Group (http://opensource.go.com/).&quot;
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names &quot;Tea&quot;, &quot;TeaServlet&quot;, &quot;Kettle&quot;, &quot;Trove&quot; and &quot;BeanDoc&quot; must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact opensource@dig.com.
 *
 * 5. Products derived from this software may not be called &quot;Tea&quot;,
 *    &quot;TeaServlet&quot;, &quot;Kettle&quot; or &quot;Trove&quot;, nor may &quot;Tea&quot;, &quot;TeaServlet&quot;,
 *    &quot;Kettle&quot;, &quot;Trove&quot; or &quot;BeanDoc&quot; appear in their name, without prior
 *    written permission of the Walt Disney Internet Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE WALT DISNEY INTERNET GROUP OR ITS
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * For more information about Tea, please see http://opensource.go.com/.
 */

package org.jivesoftware.util;

import java.util.Date;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.Locale;
import java.util.TimeZone;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.text.DateFormatSymbols;
import java.text.DateFormat;
import java.text.SimpleDateFormat;

/**
 * &lt;p&gt;Similar to {@link java.text.SimpleDateFormat}, but faster and thread-safe.
 * Only formatting is supported, but all patterns are compatible with
 * SimpleDateFormat.&lt;/p&gt;
 *
 * &lt;p&gt;Note, this class is from the open source Tea project (http://sourceforge.net/projects/teatrove/).&lt;/p&gt;
 *
 * @author Brian S O'Neill
 */
public class FastDateFormat {
    /** Style pattern */
    public static final Object
<span class="fc" id="L80">        FULL = new Integer(SimpleDateFormat.FULL),</span>
<span class="fc" id="L81">        LONG = new Integer(SimpleDateFormat.LONG),</span>
<span class="fc" id="L82">        MEDIUM = new Integer(SimpleDateFormat.MEDIUM),</span>
<span class="fc" id="L83">        SHORT = new Integer(SimpleDateFormat.SHORT);</span>

<span class="fc" id="L85">    private static final double LOG_10 = Math.log(10);</span>

    private static String cDefaultPattern;
<span class="fc" id="L88">    private static TimeZone cDefaultTimeZone = TimeZone.getDefault();</span>

<span class="fc" id="L90">    private static Map&lt;Object, String&gt; cTimeZoneDisplayCache = new HashMap&lt;&gt;();</span>

<span class="fc" id="L92">    private static Map&lt;Object, FastDateFormat&gt; cInstanceCache = new HashMap&lt;&gt;(7);</span>
<span class="fc" id="L93">    private static Map&lt;Object, FastDateFormat&gt; cDateInstanceCache = new HashMap&lt;&gt;(7);</span>
<span class="fc" id="L94">    private static Map&lt;Object, FastDateFormat&gt; cTimeInstanceCache = new HashMap&lt;&gt;(7);</span>
<span class="fc" id="L95">    private static Map&lt;Object, FastDateFormat&gt; cDateTimeInstanceCache = new HashMap&lt;&gt;(7);</span>

    public static FastDateFormat getInstance() {
<span class="nc" id="L98">        return getInstance(getDefaultPattern(), null, null, null);</span>
    }

    /**
     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern
     * @return the fast date format
     */
    public static FastDateFormat getInstance(String pattern)
        throws IllegalArgumentException
    {
<span class="nc" id="L108">        return getInstance(pattern, null, null, null);</span>
    }

    /**
     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern
     * @param timeZone optional time zone, overrides time zone of formatted
     * date
     * @return the fast date format
     */
    public static FastDateFormat getInstance
        (String pattern, TimeZone timeZone) throws IllegalArgumentException
    {
<span class="fc" id="L120">        return getInstance(pattern, timeZone, null, null);</span>
    }

    /**
     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern
     * @param locale optional locale, overrides system locale
     * @return the fast date format
     */
    public static FastDateFormat getInstance
        (String pattern, Locale locale) throws IllegalArgumentException
    {
<span class="nc" id="L131">        return getInstance(pattern, null, locale, null);</span>
    }

    /**
     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern
     * @param symbols optional date format symbols, overrides symbols for
     * system locale
     * @return the fast date format
     */
    public static FastDateFormat getInstance
        (String pattern, DateFormatSymbols symbols)
        throws IllegalArgumentException
    {
<span class="nc" id="L144">        return getInstance(pattern, null, null, symbols);</span>
    }

    /**
     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern
     * @param timeZone optional time zone, overrides time zone of formatted
     * date
     * @param locale optional locale, overrides system locale
     * @return the fast date format
     */
    public static FastDateFormat getInstance
        (String pattern, TimeZone timeZone, Locale locale)
        throws IllegalArgumentException
    {
<span class="nc" id="L158">        return getInstance(pattern, timeZone, locale, null);</span>
    }

    /**
     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern
     * @param timeZone optional time zone, overrides time zone of formatted
     * date
     * @param locale optional locale, overrides system locale
     * @param symbols optional date format symbols, overrides symbols for
     * provided locale
     * @return the fast date format
     */
    public static synchronized FastDateFormat getInstance
        (String pattern, TimeZone timeZone, Locale locale,
         DateFormatSymbols symbols)
        throws IllegalArgumentException
    {
<span class="fc" id="L175">        Object key = pattern;</span>

<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        if (timeZone != null) {</span>
<span class="fc" id="L178">            key = new Pair(key, timeZone);</span>
        }
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">        if (locale != null) {</span>
<span class="nc" id="L181">            key = new Pair(key, locale);</span>
        }
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        if (symbols != null) {</span>
<span class="nc" id="L184">            key = new Pair(key, symbols);</span>
        }

<span class="fc" id="L187">        FastDateFormat format = cInstanceCache.get(key);</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        if (format == null) {</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">            if (locale == null) {</span>
<span class="fc" id="L190">                locale = Locale.getDefault();</span>
            }
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">            if (symbols == null) {</span>
<span class="fc" id="L193">                symbols = new DateFormatSymbols(locale);</span>
            }
<span class="fc" id="L195">            format = new FastDateFormat(pattern, timeZone, locale, symbols);</span>
<span class="fc" id="L196">            cInstanceCache.put(key, format);</span>
        }
<span class="fc" id="L198">        return format;</span>
    }

    /**
     * @param style date style: FULL, LONG, MEDIUM, or SHORT
     * @param timeZone optional time zone, overrides time zone of formatted
     * date
     * @param locale optional locale, overrides system locale
     * @return the fast date format
     */
    public static synchronized FastDateFormat getDateInstance
        (Object style, TimeZone timeZone, Locale locale)
        throws IllegalArgumentException
    {
<span class="nc" id="L212">        Object key = style;</span>

<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (timeZone != null) {</span>
<span class="nc" id="L215">            key = new Pair(key, timeZone);</span>
        }
<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (locale == null) {</span>
<span class="nc" id="L218">            key = new Pair(key, locale);</span>
        }

<span class="nc" id="L221">        FastDateFormat format = cDateInstanceCache.get(key);</span>

<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (format == null) {</span>
            int ds;
            try {
<span class="nc" id="L226">                ds = ((Integer)style).intValue();</span>
            }
<span class="nc" id="L228">            catch (ClassCastException e) {</span>
<span class="nc" id="L229">                throw new IllegalArgumentException</span>
                    (&quot;Illegal date style: &quot; + style);
<span class="nc" id="L231">            }</span>

<span class="nc bnc" id="L233" title="All 2 branches missed.">            if (locale == null) {</span>
<span class="nc" id="L234">                locale = Locale.getDefault();</span>
            }

            try {
<span class="nc" id="L238">                String pattern = ((SimpleDateFormat)DateFormat.getDateInstance(ds, locale)).toPattern();</span>
<span class="nc" id="L239">                format = getInstance(pattern, timeZone, locale);</span>
<span class="nc" id="L240">                cDateInstanceCache.put(key, format);</span>
            }
<span class="nc" id="L242">            catch (ClassCastException e) {</span>
<span class="nc" id="L243">                throw new IllegalArgumentException</span>
                    (&quot;No date pattern for locale: &quot; + locale);
<span class="nc" id="L245">            }</span>
        }

<span class="nc" id="L248">        return format;</span>
    }

    /**
     * @param style time style: FULL, LONG, MEDIUM, or SHORT
     * @param timeZone optional time zone, overrides time zone of formatted
     * date
     * @param locale optional locale, overrides system locale
     * @return the fast date format
     */
    public static synchronized FastDateFormat getTimeInstance
        (Object style, TimeZone timeZone, Locale locale)
        throws IllegalArgumentException
    {
<span class="nc" id="L262">        Object key = style;</span>

<span class="nc bnc" id="L264" title="All 2 branches missed.">        if (timeZone != null) {</span>
<span class="nc" id="L265">            key = new Pair(key, timeZone);</span>
        }
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (locale != null) {</span>
<span class="nc" id="L268">            key = new Pair(key, locale);</span>
        }

<span class="nc" id="L271">        FastDateFormat format = cTimeInstanceCache.get(key);</span>

<span class="nc bnc" id="L273" title="All 2 branches missed.">        if (format == null) {</span>
            int ts;
            try {
<span class="nc" id="L276">                ts = ((Integer)style).intValue();</span>
            }
<span class="nc" id="L278">            catch (ClassCastException e) {</span>
<span class="nc" id="L279">                throw new IllegalArgumentException</span>
                    (&quot;Illegal time style: &quot; + style);
<span class="nc" id="L281">            }</span>

<span class="nc bnc" id="L283" title="All 2 branches missed.">            if (locale == null) {</span>
<span class="nc" id="L284">                locale = Locale.getDefault();</span>
            }

            try {
<span class="nc" id="L288">                String pattern = ((SimpleDateFormat)DateFormat.getTimeInstance(ts, locale)).toPattern();</span>
<span class="nc" id="L289">                format = getInstance(pattern, timeZone, locale);</span>
<span class="nc" id="L290">                cTimeInstanceCache.put(key, format);</span>
            }
<span class="nc" id="L292">            catch (ClassCastException e) {</span>
<span class="nc" id="L293">                throw new IllegalArgumentException</span>
                    (&quot;No date pattern for locale: &quot; + locale);
<span class="nc" id="L295">            }</span>
        }

<span class="nc" id="L298">        return format;</span>
    }

    /**
     * @param dateStyle date style: FULL, LONG, MEDIUM, or SHORT
     * @param timeStyle time style: FULL, LONG, MEDIUM, or SHORT
     * @param timeZone optional time zone, overrides time zone of formatted
     * date
     * @param locale optional locale, overrides system locale
     * @return the fast date format
     */
    public static synchronized FastDateFormat getDateTimeInstance
        (Object dateStyle, Object timeStyle, TimeZone timeZone, Locale locale)
        throws IllegalArgumentException
    {
<span class="nc" id="L313">        Object key = new Pair(dateStyle, timeStyle);</span>

<span class="nc bnc" id="L315" title="All 2 branches missed.">        if (timeZone != null) {</span>
<span class="nc" id="L316">            key = new Pair(key, timeZone);</span>
        }
<span class="nc bnc" id="L318" title="All 2 branches missed.">        if (locale != null) {</span>
<span class="nc" id="L319">            key = new Pair(key, locale);</span>
        }

<span class="nc" id="L322">        FastDateFormat format = cDateTimeInstanceCache.get(key);</span>

<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (format == null) {</span>
            int ds;
            try {
<span class="nc" id="L327">                ds = ((Integer)dateStyle).intValue();</span>
            }
<span class="nc" id="L329">            catch (ClassCastException e) {</span>
<span class="nc" id="L330">                throw new IllegalArgumentException</span>
                    (&quot;Illegal date style: &quot; + dateStyle);
<span class="nc" id="L332">            }</span>

            int ts;
            try {
<span class="nc" id="L336">                ts = ((Integer)timeStyle).intValue();</span>
            }
<span class="nc" id="L338">            catch (ClassCastException e) {</span>
<span class="nc" id="L339">                throw new IllegalArgumentException</span>
                    (&quot;Illegal time style: &quot; + timeStyle);
<span class="nc" id="L341">            }</span>

<span class="nc bnc" id="L343" title="All 2 branches missed.">            if (locale == null) {</span>
<span class="nc" id="L344">                locale = Locale.getDefault();</span>
            }

            try {
<span class="nc" id="L348">                String pattern = ((SimpleDateFormat)DateFormat.getDateTimeInstance(ds, ts, locale)).toPattern();</span>
<span class="nc" id="L349">                format = getInstance(pattern, timeZone, locale);</span>
<span class="nc" id="L350">                cDateTimeInstanceCache.put(key, format);</span>
            }
<span class="nc" id="L352">            catch (ClassCastException e) {</span>
<span class="nc" id="L353">                throw new IllegalArgumentException</span>
                    (&quot;No date time pattern for locale: &quot; + locale);
<span class="nc" id="L355">            }</span>
        }

<span class="nc" id="L358">        return format;</span>
    }

    static synchronized String getTimeZoneDisplay(TimeZone tz,
                                                  boolean daylight,
                                                  int style,
                                                  Locale locale) {
<span class="nc" id="L365">        Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);</span>
<span class="nc" id="L366">        String value = cTimeZoneDisplayCache.get(key);</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (value == null) {</span>
            // This is a very slow call, so cache the results.
<span class="nc" id="L369">            value = tz.getDisplayName(daylight, style, locale);</span>
<span class="nc" id="L370">            cTimeZoneDisplayCache.put(key, value);</span>
        }
<span class="nc" id="L372">        return value;</span>
    }

    private static synchronized String getDefaultPattern() {
<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (cDefaultPattern == null) {</span>
<span class="nc" id="L377">            cDefaultPattern = new SimpleDateFormat().toPattern();</span>
        }
<span class="nc" id="L379">        return cDefaultPattern;</span>
    }

    /**
     * Returns a list of Rules.
     */
    private static List parse(String pattern, TimeZone timeZone, Locale locale,
                              DateFormatSymbols symbols) {
<span class="fc" id="L387">        List&lt;Rule&gt; rules = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L389">        String[] ERAs = symbols.getEras();</span>
<span class="fc" id="L390">        String[] months = symbols.getMonths();</span>
<span class="fc" id="L391">        String[] shortMonths = symbols.getShortMonths();</span>
<span class="fc" id="L392">        String[] weekdays = symbols.getWeekdays();</span>
<span class="fc" id="L393">        String[] shortWeekdays = symbols.getShortWeekdays();</span>
<span class="fc" id="L394">        String[] AmPmStrings = symbols.getAmPmStrings();</span>

<span class="fc" id="L396">        int length = pattern.length();</span>
<span class="fc" id="L397">        int[] indexRef = new int[1];</span>

<span class="fc bfc" id="L399" title="All 2 branches covered.">        for (int i=0; i&lt;length; i++) {</span>
<span class="fc" id="L400">            indexRef[0] = i;</span>
<span class="fc" id="L401">            String token = parseToken(pattern, indexRef);</span>
<span class="fc" id="L402">            i = indexRef[0];</span>

<span class="fc" id="L404">            int tokenLen = token.length();</span>
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">            if (tokenLen == 0) {</span>
<span class="nc" id="L406">                break;</span>
            }

            Rule rule;
<span class="fc" id="L410">            char c = token.charAt(0);</span>

<span class="pc bpc" id="L412" title="12 of 20 branches missed.">            switch (c) {</span>
            case 'G': // era designator (text)
<span class="nc" id="L414">                rule = new TextField(Calendar.ERA, ERAs);</span>
<span class="nc" id="L415">                break;</span>
            case 'y': // year (number)
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">                if (tokenLen &gt;= 4) {</span>
<span class="fc" id="L418">                    rule = new UnpaddedNumberField(Calendar.YEAR);</span>
                }
                else {
<span class="nc" id="L421">                    rule = new TwoDigitYearField();</span>
                }
<span class="nc" id="L423">                break;</span>
            case 'M': // month in year (text and number)
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">                if (tokenLen &gt;= 4) {</span>
<span class="nc" id="L426">                    rule = new TextField(Calendar.MONTH, months);</span>
                }
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">                else if (tokenLen == 3) {</span>
<span class="nc" id="L429">                    rule = new TextField(Calendar.MONTH, shortMonths);</span>
                }
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">                else if (tokenLen == 2) {</span>
<span class="fc" id="L432">                    rule = new TwoDigitMonthField();</span>
                }
                else {
<span class="nc" id="L435">                    rule = new UnpaddedMonthField();</span>
                }
<span class="nc" id="L437">                break;</span>
            case 'd': // day in month (number)
<span class="fc" id="L439">                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);</span>
<span class="fc" id="L440">                break;</span>
            case 'h': // hour in am/pm (number, 1..12)
<span class="nc" id="L442">                rule = new TwelveHourField</span>
<span class="nc" id="L443">                    (selectNumberRule(Calendar.HOUR, tokenLen));</span>
<span class="nc" id="L444">                break;</span>
            case 'H': // hour in day (number, 0..23)
<span class="fc" id="L446">                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);</span>
<span class="fc" id="L447">                break;</span>
            case 'm': // minute in hour (number)
<span class="fc" id="L449">                rule = selectNumberRule(Calendar.MINUTE, tokenLen);</span>
<span class="fc" id="L450">                break;</span>
            case 's': // second in minute (number)
<span class="fc" id="L452">                rule = selectNumberRule(Calendar.SECOND, tokenLen);</span>
<span class="fc" id="L453">                break;</span>
            case 'S': // millisecond (number)
<span class="fc" id="L455">                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);</span>
<span class="fc" id="L456">                break;</span>
            case 'E': // day in week (text)
<span class="nc bnc" id="L458" title="All 2 branches missed.">                rule = new TextField</span>
                    (Calendar.DAY_OF_WEEK,
                     tokenLen &lt; 4 ? shortWeekdays : weekdays);
<span class="nc" id="L461">                break;</span>
            case 'D': // day in year (number)
<span class="nc" id="L463">                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);</span>
<span class="nc" id="L464">                break;</span>
            case 'F': // day of week in month (number)
<span class="nc" id="L466">                rule = selectNumberRule</span>
<span class="nc" id="L467">                    (Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);</span>
<span class="nc" id="L468">                break;</span>
            case 'w': // week in year (number)
<span class="nc" id="L470">                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);</span>
<span class="nc" id="L471">                break;</span>
            case 'W': // week in month (number)
<span class="nc" id="L473">                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);</span>
<span class="nc" id="L474">                break;</span>
            case 'a': // am/pm marker (text)
<span class="nc" id="L476">                rule = new TextField(Calendar.AM_PM, AmPmStrings);</span>
<span class="nc" id="L477">                break;</span>
            case 'k': // hour in day (1..24)
<span class="nc" id="L479">                rule = new TwentyFourHourField</span>
<span class="nc" id="L480">                    (selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));</span>
<span class="nc" id="L481">                break;</span>
            case 'K': // hour in am/pm (0..11)
<span class="nc" id="L483">                rule = selectNumberRule(Calendar.HOUR, tokenLen);</span>
<span class="nc" id="L484">                break;</span>
            case 'z': // time zone (text)
<span class="nc bnc" id="L486" title="All 2 branches missed.">                if (tokenLen &gt;= 4) {</span>
<span class="nc" id="L487">                    rule = new TimeZoneRule(timeZone, locale, TimeZone.LONG);</span>
                }
                else {
<span class="nc" id="L490">                    rule = new TimeZoneRule(timeZone, locale, TimeZone.SHORT);</span>
                }
<span class="nc" id="L492">                break;</span>
            case '\'': // literal text
<span class="fc" id="L494">                String sub = token.substring(1);</span>
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">                if (sub.length() == 1) {</span>
<span class="fc" id="L496">                    rule = new CharacterLiteral(sub.charAt(0));</span>
                }
                else {
<span class="nc" id="L499">                    rule = new StringLiteral(new String(sub));</span>
                }
<span class="nc" id="L501">                break;</span>
            default:
<span class="nc" id="L503">                throw new IllegalArgumentException</span>
                    (&quot;Illegal pattern component: &quot; + token);
            }

<span class="fc" id="L507">            rules.add(rule);</span>
        }

<span class="fc" id="L510">        return rules;</span>
    }

    private static String parseToken(String pattern, int[] indexRef) {
<span class="fc" id="L514">        StringBuilder buf = new StringBuilder();</span>

<span class="fc" id="L516">        int i = indexRef[0];</span>
<span class="fc" id="L517">        int length = pattern.length();</span>

<span class="fc" id="L519">        char c = pattern.charAt(i);</span>
<span class="pc bpc" id="L520" title="1 of 8 branches missed.">        if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z' || c &gt;= 'a' &amp;&amp; c &lt;= 'z') {</span>
            // Scan a run of the same character, which indicates a time
            // pattern.
<span class="fc" id="L523">            buf.append(c);</span>

<span class="fc bfc" id="L525" title="All 2 branches covered.">            while (i + 1 &lt; length) {</span>
<span class="fc" id="L526">                char peek = pattern.charAt(i + 1);</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">                if (peek == c) {</span>
<span class="fc" id="L528">                    buf.append(c);</span>
<span class="fc" id="L529">                    i++;</span>
                }
                else {
                    break;
                }
<span class="fc" id="L534">            }</span>
        }
        else {
            // This will identify token as text.
<span class="fc" id="L538">            buf.append('\'');</span>

<span class="fc" id="L540">            boolean inLiteral = false;</span>

<span class="fc bfc" id="L542" title="All 2 branches covered.">            for (; i &lt; length; i++) {</span>
<span class="fc" id="L543">                c = pattern.charAt(i);</span>

<span class="fc bfc" id="L545" title="All 2 branches covered.">                if (c == '\'') {</span>
<span class="pc bpc" id="L546" title="1 of 4 branches missed.">                    if (i + 1 &lt; length &amp;&amp; pattern.charAt(i + 1) == '\'') {</span>
                        // '' is treated as escaped '
<span class="nc" id="L548">                        i++;</span>
<span class="nc" id="L549">                        buf.append(c);</span>
                    }
                    else {
<span class="fc bfc" id="L552" title="All 2 branches covered.">                        inLiteral = !inLiteral;</span>
                    }
                }
<span class="pc bpc" id="L555" title="1 of 10 branches missed.">                else if (!inLiteral &amp;&amp;</span>
                         (c &gt;= 'A' &amp;&amp; c &lt;= 'Z' || c &gt;= 'a' &amp;&amp; c &lt;= 'z')) {
<span class="fc" id="L557">                    i--;</span>
<span class="fc" id="L558">                    break;</span>
                }
                else {
<span class="fc" id="L561">                    buf.append(c);</span>
                }
            }
        }

<span class="fc" id="L566">        indexRef[0] = i;</span>
<span class="fc" id="L567">        return buf.toString();</span>
    }

    private static NumberRule selectNumberRule(int field, int padding) {
<span class="pc bpc" id="L571" title="1 of 3 branches missed.">        switch (padding) {</span>
        case 1:
<span class="nc" id="L573">            return new UnpaddedNumberField(field);</span>
        case 2:
<span class="fc" id="L575">            return new TwoDigitNumberField(field);</span>
        default:
<span class="fc" id="L577">            return new PaddedNumberField(field, padding);</span>
        }
    }

    private final String mPattern;
    private final TimeZone mTimeZone;
    private final Locale mLocale;
    private final Rule[] mRules;
    private final int mMaxLengthEstimate;

    private FastDateFormat() {
<span class="nc" id="L588">        this(getDefaultPattern(), null, null, null);</span>
<span class="nc" id="L589">    }</span>

    /**
     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern
     */
    private FastDateFormat(String pattern) throws IllegalArgumentException {
<span class="nc" id="L595">        this(pattern, null, null, null);</span>
<span class="nc" id="L596">    }</span>

    /**
     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern
     * @param timeZone optional time zone, overrides time zone of formatted
     * date
     */
    private FastDateFormat(String pattern, TimeZone timeZone)
        throws IllegalArgumentException
    {
<span class="nc" id="L606">        this(pattern, timeZone, null, null);</span>
<span class="nc" id="L607">    }</span>

    /**
     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern
     * @param locale optional locale, overrides system locale
     */
    private FastDateFormat(String pattern, Locale locale)
        throws IllegalArgumentException
    {
<span class="nc" id="L616">        this(pattern, null, locale, null);</span>
<span class="nc" id="L617">    }</span>

    /**
     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern
     * @param symbols optional date format symbols, overrides symbols for
     * system locale
     */
    private FastDateFormat(String pattern, DateFormatSymbols symbols)
        throws IllegalArgumentException
    {
<span class="nc" id="L627">        this(pattern, null, null, symbols);</span>
<span class="nc" id="L628">    }</span>

    /**
     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern
     * @param timeZone optional time zone, overrides time zone of formatted
     * date
     * @param locale optional locale, overrides system locale
     */
    private FastDateFormat(String pattern, TimeZone timeZone, Locale locale)
        throws IllegalArgumentException
    {
<span class="nc" id="L639">        this(pattern, timeZone, locale, null);</span>
<span class="nc" id="L640">    }</span>

    /**
     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern
     * @param timeZone optional time zone, overrides time zone of formatted
     * date
     * @param locale optional locale, overrides system locale
     * @param symbols optional date format symbols, overrides symbols for
     * provided locale
     */
    private FastDateFormat(String pattern, TimeZone timeZone, Locale locale,
                           DateFormatSymbols symbols)
        throws IllegalArgumentException
<span class="fc" id="L653">    {</span>
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">        if (locale == null) {</span>
<span class="nc" id="L655">            locale = Locale.getDefault();</span>
        }

<span class="fc" id="L658">        mPattern = pattern;</span>
<span class="fc" id="L659">        mTimeZone = timeZone;</span>
<span class="fc" id="L660">        mLocale = locale;</span>

<span class="pc bpc" id="L662" title="1 of 2 branches missed.">        if (symbols == null) {</span>
<span class="nc" id="L663">            symbols = new DateFormatSymbols(locale);</span>
        }

<span class="fc" id="L666">        List rulesList = parse(pattern, timeZone, locale, symbols);</span>
<span class="fc" id="L667">        mRules = (Rule[])rulesList.toArray(new Rule[rulesList.size()]);</span>

<span class="fc" id="L669">        int len = 0;</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">        for (int i=mRules.length; --i &gt;= 0; ) {</span>
<span class="fc" id="L671">            len += mRules[i].estimateLength();</span>
        }

<span class="fc" id="L674">        mMaxLengthEstimate = len;</span>
<span class="fc" id="L675">    }</span>

    public String format(Date date) {
<span class="fc" id="L678">        Calendar c = new GregorianCalendar(cDefaultTimeZone);</span>
<span class="fc" id="L679">        c.setTime(date);</span>
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">        if (mTimeZone != null) {</span>
<span class="fc" id="L681">            c.setTimeZone(mTimeZone);</span>
        }
<span class="fc" id="L683">        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();</span>
    }

    public String format(Calendar calendar) {
<span class="nc" id="L687">        return format(calendar, new StringBuffer(mMaxLengthEstimate))</span>
<span class="nc" id="L688">            .toString();</span>
    }

    public StringBuffer format(Date date, StringBuffer buf) {
<span class="nc" id="L692">        Calendar c = new GregorianCalendar(cDefaultTimeZone);</span>
<span class="nc" id="L693">        c.setTime(date);</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">        if (mTimeZone != null) {</span>
<span class="nc" id="L695">            c.setTimeZone(mTimeZone);</span>
        }
<span class="nc" id="L697">        return applyRules(c, buf);</span>
    }

    public StringBuffer format(Calendar calendar, StringBuffer buf) {
<span class="nc bnc" id="L701" title="All 2 branches missed.">        if (mTimeZone != null) {</span>
<span class="nc" id="L702">            calendar = (Calendar)calendar.clone();</span>
<span class="nc" id="L703">            calendar.setTimeZone(mTimeZone);</span>
        }
<span class="nc" id="L705">        return applyRules(calendar, buf);</span>
    }

    private StringBuffer applyRules(Calendar calendar, StringBuffer buf) {
<span class="fc" id="L709">        Rule[] rules = mRules;</span>
<span class="fc" id="L710">        int len = mRules.length;</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">        for (int i=0; i&lt;len; i++) {</span>
<span class="fc" id="L712">            rules[i].appendTo(buf, calendar);</span>
        }
<span class="fc" id="L714">        return buf;</span>
    }

    public String getPattern() {
<span class="nc" id="L718">        return mPattern;</span>
    }

    /**
     * Returns the time zone used by this formatter, or null if time zone of
     * formatted dates is used instead.
     * @return the time zone
     */
    public TimeZone getTimeZone() {
<span class="nc" id="L727">        return mTimeZone;</span>
    }

    public Locale getLocale() {
<span class="nc" id="L731">        return mLocale;</span>
    }

    /**
     * Returns an estimate for the maximum length date that this date
     * formatter will produce. The actual formatted length will almost always
     * be less than or equal to this amount.
     * @return an estimate of the maximum length
     */
    public int getMaxLengthEstimate() {
<span class="nc" id="L741">        return mMaxLengthEstimate;</span>
    }

    private interface Rule {
        int estimateLength();

        void appendTo(StringBuffer buffer, Calendar calendar);
    }

    private interface NumberRule extends Rule {
        void appendTo(StringBuffer buffer, int value);
    }

    private static class CharacterLiteral implements Rule {
        private final char mValue;

<span class="fc" id="L757">        CharacterLiteral(char value) {</span>
<span class="fc" id="L758">            mValue = value;</span>
<span class="fc" id="L759">        }</span>

        @Override
        public int estimateLength() {
<span class="fc" id="L763">            return 1;</span>
        }

        @Override
        public void appendTo(StringBuffer buffer, Calendar calendar) {
<span class="fc" id="L768">            buffer.append(mValue);</span>
<span class="fc" id="L769">        }</span>
    }

    private static class StringLiteral implements Rule {
        private final String mValue;

<span class="nc" id="L775">        StringLiteral(String value) {</span>
<span class="nc" id="L776">            mValue = value;</span>
<span class="nc" id="L777">        }</span>

        @Override
        public int estimateLength() {
<span class="nc" id="L781">            return mValue.length();</span>
        }

        @Override
        public void appendTo(StringBuffer buffer, Calendar calendar) {
<span class="nc" id="L786">            buffer.append(mValue);</span>
<span class="nc" id="L787">        }</span>
    }

    private static class TextField implements Rule {
        private final int mField;
        private final String[] mValues;

<span class="nc" id="L794">        TextField(int field, String[] values) {</span>
<span class="nc" id="L795">            mField = field;</span>
<span class="nc" id="L796">            mValues = values;</span>
<span class="nc" id="L797">        }</span>

        @Override
        public int estimateLength() {
<span class="nc" id="L801">            int max = 0;</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">            for (int i=mValues.length; --i &gt;= 0; ) {</span>
<span class="nc" id="L803">                int len = mValues[i].length();</span>
<span class="nc bnc" id="L804" title="All 2 branches missed.">                if (len &gt; max) {</span>
<span class="nc" id="L805">                    max = len;</span>
                }
<span class="nc" id="L807">            }</span>
<span class="nc" id="L808">            return max;</span>
        }

        @Override
        public void appendTo(StringBuffer buffer, Calendar calendar) {
<span class="nc" id="L813">            buffer.append(mValues[calendar.get(mField)]);</span>
<span class="nc" id="L814">        }</span>
    }

    private static class UnpaddedNumberField implements NumberRule {
        private final int mField;

<span class="fc" id="L820">        UnpaddedNumberField(int field) {</span>
<span class="fc" id="L821">            mField = field;</span>
<span class="fc" id="L822">        }</span>

        @Override
        public int estimateLength() {
<span class="fc" id="L826">            return 4;</span>
        }

        @Override
        public void appendTo(StringBuffer buffer, Calendar calendar) {
<span class="fc" id="L831">            appendTo(buffer, calendar.get(mField));</span>
<span class="fc" id="L832">        }</span>

        @Override
        public final void appendTo(StringBuffer buffer, int value) {
<span class="pc bpc" id="L836" title="1 of 2 branches missed.">            if (value &lt; 10) {</span>
<span class="nc" id="L837">                buffer.append((char)(value + '0'));</span>
            }
<span class="pc bpc" id="L839" title="1 of 2 branches missed.">            else if (value &lt; 100) {</span>
<span class="nc" id="L840">                buffer.append((char)(value / 10 + '0'));</span>
<span class="nc" id="L841">                buffer.append((char)(value % 10 + '0'));</span>
            }
            else {
<span class="fc" id="L844">                buffer.append(Integer.toString(value));</span>
            }
<span class="fc" id="L846">        }</span>
    }

    private static class UnpaddedMonthField implements NumberRule {
<span class="nc" id="L850">        UnpaddedMonthField() {</span>
<span class="nc" id="L851">        }</span>

        @Override
        public int estimateLength() {
<span class="nc" id="L855">            return 2;</span>
        }

        @Override
        public void appendTo(StringBuffer buffer, Calendar calendar) {
<span class="nc" id="L860">            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);</span>
<span class="nc" id="L861">        }</span>

        @Override
        public final void appendTo(StringBuffer buffer, int value) {
<span class="nc bnc" id="L865" title="All 2 branches missed.">            if (value &lt; 10) {</span>
<span class="nc" id="L866">                buffer.append((char)(value + '0'));</span>
            }
            else {
<span class="nc" id="L869">                buffer.append((char)(value / 10 + '0'));</span>
<span class="nc" id="L870">                buffer.append((char)(value % 10 + '0'));</span>
            }
<span class="nc" id="L872">        }</span>
    }

    private static class PaddedNumberField implements NumberRule {
        private final int mField;
        private final int mSize;

<span class="fc" id="L879">        PaddedNumberField(int field, int size) {</span>
<span class="pc bpc" id="L880" title="1 of 2 branches missed.">            if (size &lt; 3) {</span>
                // Should use UnpaddedNumberField or TwoDigitNumberField.
<span class="nc" id="L882">                throw new IllegalArgumentException();</span>
            }
<span class="fc" id="L884">            mField = field;</span>
<span class="fc" id="L885">            mSize = size;</span>
<span class="fc" id="L886">        }</span>

        @Override
        public int estimateLength() {
<span class="fc" id="L890">            return 4;</span>
        }

        @Override
        public void appendTo(StringBuffer buffer, Calendar calendar) {
<span class="fc" id="L895">            appendTo(buffer, calendar.get(mField));</span>
<span class="fc" id="L896">        }</span>

        @Override
        public final void appendTo(StringBuffer buffer, int value) {
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">            if (value &lt; 100) {</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">                for (int i = mSize; --i &gt;= 2; ) {</span>
<span class="fc" id="L902">                    buffer.append('0');</span>
                }
<span class="fc" id="L904">                buffer.append((char)(value / 10 + '0'));</span>
<span class="fc" id="L905">                buffer.append((char)(value % 10 + '0'));</span>
            }
            else {
                int digits;
<span class="nc bnc" id="L909" title="All 2 branches missed.">                if (value &lt; 1000) {</span>
<span class="nc" id="L910">                    digits = 3;</span>
                }
                else {
<span class="nc" id="L913">                    digits = (int)(Math.log(value) / LOG_10) + 1;</span>
                }
<span class="nc bnc" id="L915" title="All 2 branches missed.">                for (int i = mSize; --i &gt;= digits; ) {</span>
<span class="nc" id="L916">                    buffer.append('0');</span>
                }
<span class="nc" id="L918">                buffer.append(Integer.toString(value));</span>
            }
<span class="fc" id="L920">        }</span>
    }

    private static class TwoDigitNumberField implements NumberRule {
        private final int mField;

<span class="fc" id="L926">        TwoDigitNumberField(int field) {</span>
<span class="fc" id="L927">            mField = field;</span>
<span class="fc" id="L928">        }</span>

        @Override
        public int estimateLength() {
<span class="fc" id="L932">            return 2;</span>
        }

        @Override
        public void appendTo(StringBuffer buffer, Calendar calendar) {
<span class="fc" id="L937">            appendTo(buffer, calendar.get(mField));</span>
<span class="fc" id="L938">        }</span>

        @Override
        public final void appendTo(StringBuffer buffer, int value) {
<span class="pc bpc" id="L942" title="1 of 2 branches missed.">            if (value &lt; 100) {</span>
<span class="fc" id="L943">                buffer.append((char)(value / 10 + '0'));</span>
<span class="fc" id="L944">                buffer.append((char)(value % 10 + '0'));</span>
            }
            else {
<span class="nc" id="L947">                buffer.append(Integer.toString(value));</span>
            }
<span class="fc" id="L949">        }</span>
    }

    private static class TwoDigitYearField implements NumberRule {
<span class="nc" id="L953">        TwoDigitYearField() {</span>
<span class="nc" id="L954">        }</span>

        @Override
        public int estimateLength() {
<span class="nc" id="L958">            return 2;</span>
        }

        @Override
        public void appendTo(StringBuffer buffer, Calendar calendar) {
<span class="nc" id="L963">            appendTo(buffer, calendar.get(Calendar.YEAR) % 100);</span>
<span class="nc" id="L964">        }</span>

        @Override
        public final void appendTo(StringBuffer buffer, int value) {
<span class="nc" id="L968">            buffer.append((char)(value / 10 + '0'));</span>
<span class="nc" id="L969">            buffer.append((char)(value % 10 + '0'));</span>
<span class="nc" id="L970">        }</span>
    }

    private static class TwoDigitMonthField implements NumberRule {
<span class="fc" id="L974">        TwoDigitMonthField() {</span>
<span class="fc" id="L975">        }</span>

        @Override
        public int estimateLength() {
<span class="fc" id="L979">            return 2;</span>
        }

        @Override
        public void appendTo(StringBuffer buffer, Calendar calendar) {
<span class="fc" id="L984">            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);</span>
<span class="fc" id="L985">        }</span>

        @Override
        public final void appendTo(StringBuffer buffer, int value) {
<span class="fc" id="L989">            buffer.append((char)(value / 10 + '0'));</span>
<span class="fc" id="L990">            buffer.append((char)(value % 10 + '0'));</span>
<span class="fc" id="L991">        }</span>
    }

    private static class TwelveHourField implements NumberRule {
        private final NumberRule mRule;

<span class="nc" id="L997">        TwelveHourField(NumberRule rule) {</span>
<span class="nc" id="L998">            mRule = rule;</span>
<span class="nc" id="L999">        }</span>

        @Override
        public int estimateLength() {
<span class="nc" id="L1003">            return mRule.estimateLength();</span>
        }

        @Override
        public void appendTo(StringBuffer buffer, Calendar calendar) {
<span class="nc" id="L1008">            int value = calendar.get(Calendar.HOUR);</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">            if (value == 0) {</span>
<span class="nc" id="L1010">                value = calendar.getLeastMaximum(Calendar.HOUR) + 1;</span>
            }
<span class="nc" id="L1012">            mRule.appendTo(buffer, value);</span>
<span class="nc" id="L1013">        }</span>

        @Override
        public void appendTo(StringBuffer buffer, int value) {
<span class="nc" id="L1017">            mRule.appendTo(buffer, value);</span>
<span class="nc" id="L1018">        }</span>
    }

    private static class TwentyFourHourField implements NumberRule {
        private final NumberRule mRule;

<span class="nc" id="L1024">        TwentyFourHourField(NumberRule rule) {</span>
<span class="nc" id="L1025">            mRule = rule;</span>
<span class="nc" id="L1026">        }</span>

        @Override
        public int estimateLength() {
<span class="nc" id="L1030">            return mRule.estimateLength();</span>
        }

        @Override
        public void appendTo(StringBuffer buffer, Calendar calendar) {
<span class="nc" id="L1035">            int value = calendar.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">            if (value == 0) {</span>
<span class="nc" id="L1037">                value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1;</span>
            }
<span class="nc" id="L1039">            mRule.appendTo(buffer, value);</span>
<span class="nc" id="L1040">        }</span>

        @Override
        public void appendTo(StringBuffer buffer, int value) {
<span class="nc" id="L1044">            mRule.appendTo(buffer, value);</span>
<span class="nc" id="L1045">        }</span>
    }

    private static class TimeZoneRule implements Rule {
        private final TimeZone mTimeZone;
        private final Locale mLocale;
        private final int mStyle;
        private final String mStandard;
        private final String mDaylight;

<span class="nc" id="L1055">        TimeZoneRule(TimeZone timeZone, Locale locale, int style) {</span>
<span class="nc" id="L1056">            mTimeZone = timeZone;</span>
<span class="nc" id="L1057">            mLocale = locale;</span>
<span class="nc" id="L1058">            mStyle = style;</span>

<span class="nc bnc" id="L1060" title="All 2 branches missed.">            if (timeZone != null) {</span>
<span class="nc" id="L1061">                mStandard = getTimeZoneDisplay(timeZone, false, style, locale);</span>
<span class="nc" id="L1062">                mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);</span>
            }
            else {
<span class="nc" id="L1065">                mStandard = null;</span>
<span class="nc" id="L1066">                mDaylight = null;</span>
            }
<span class="nc" id="L1068">        }</span>

        @Override
        public int estimateLength() {
<span class="nc bnc" id="L1072" title="All 2 branches missed.">            if (mTimeZone != null) {</span>
<span class="nc" id="L1073">                return Math.max(mStandard.length(), mDaylight.length());</span>
            }
<span class="nc bnc" id="L1075" title="All 2 branches missed.">            else if (mStyle == TimeZone.SHORT) {</span>
<span class="nc" id="L1076">                return 4;</span>
            }
            else {
<span class="nc" id="L1079">                return 40;</span>
            }
        }

        @Override
        public void appendTo(StringBuffer buffer, Calendar calendar) {
            TimeZone timeZone;
<span class="nc bnc" id="L1086" title="All 2 branches missed.">            if ((timeZone = mTimeZone) != null) {</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">                if (timeZone.useDaylightTime() &amp;&amp;</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">                    calendar.get(Calendar.DST_OFFSET) != 0) {</span>

<span class="nc" id="L1090">                    buffer.append(mDaylight);</span>
                }
                else {
<span class="nc" id="L1093">                    buffer.append(mStandard);</span>
                }
            }
            else {
<span class="nc" id="L1097">                timeZone = calendar.getTimeZone();</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">                if (timeZone.useDaylightTime() &amp;&amp;</span>
<span class="nc bnc" id="L1099" title="All 2 branches missed.">                    calendar.get(Calendar.DST_OFFSET) != 0) {</span>

<span class="nc" id="L1101">                    buffer.append(getTimeZoneDisplay</span>
<span class="nc" id="L1102">                                  (timeZone, true, mStyle, mLocale));</span>
                }
                else {
<span class="nc" id="L1105">                    buffer.append(getTimeZoneDisplay</span>
<span class="nc" id="L1106">                                  (timeZone, false, mStyle, mLocale));</span>
                }
            }
<span class="nc" id="L1109">        }</span>
    }

    private static class TimeZoneDisplayKey {
        private final TimeZone mTimeZone;
        private final int mStyle;
        private final Locale mLocale;

        TimeZoneDisplayKey(TimeZone timeZone,
<span class="nc" id="L1118">                           boolean daylight, int style, Locale locale) {</span>
<span class="nc" id="L1119">            mTimeZone = timeZone;</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">            if (daylight) {</span>
<span class="nc" id="L1121">                style |= 0x80000000;</span>
            }
<span class="nc" id="L1123">            mStyle = style;</span>
<span class="nc" id="L1124">            mLocale = locale;</span>
<span class="nc" id="L1125">        }</span>

        @Override
        public int hashCode() {
<span class="nc" id="L1129">            return mStyle * 31 + mLocale.hashCode();</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="nc bnc" id="L1134" title="All 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L1135">                return true;</span>
            }
<span class="nc bnc" id="L1137" title="All 2 branches missed.">            if (obj instanceof TimeZoneDisplayKey) {</span>
<span class="nc" id="L1138">                TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;</span>
<span class="nc" id="L1139">                return</span>
<span class="nc bnc" id="L1140" title="All 4 branches missed.">                    mTimeZone.equals(other.mTimeZone) &amp;&amp;</span>
                    mStyle == other.mStyle &amp;&amp;
<span class="nc bnc" id="L1142" title="All 2 branches missed.">                    mLocale.equals(other.mLocale);</span>
            }
<span class="nc" id="L1144">            return false;</span>
        }
    }

    private static class Pair implements Comparable, java.io.Serializable {
        private final Object mObj1;
        private final Object mObj2;

<span class="fc" id="L1152">        public Pair(Object obj1, Object obj2) {</span>
<span class="fc" id="L1153">            mObj1 = obj1;</span>
<span class="fc" id="L1154">            mObj2 = obj2;</span>
<span class="fc" id="L1155">        }</span>

        @Override
        public int compareTo(Object obj) {
<span class="nc bnc" id="L1159" title="All 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L1160">                return 0;</span>
            }

<span class="nc" id="L1163">            Pair other = (Pair)obj;</span>

<span class="nc" id="L1165">            Object a = mObj1;</span>
<span class="nc" id="L1166">            Object b = other.mObj1;</span>

            firstTest: {
<span class="nc bnc" id="L1169" title="All 2 branches missed.">                if (a == null) {</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">                    if (b != null) {</span>
<span class="nc" id="L1171">                        return 1;</span>
                    }
                    // Both a and b are null.
                    break firstTest;
                }
                else {
<span class="nc bnc" id="L1177" title="All 2 branches missed.">                    if (b == null) {</span>
<span class="nc" id="L1178">                        return -1;</span>
                    }
                }

<span class="nc" id="L1182">                int result = ((Comparable)a).compareTo(b);</span>

<span class="nc bnc" id="L1184" title="All 2 branches missed.">                if (result != 0) {</span>
<span class="nc" id="L1185">                    return result;</span>
                }
            }

<span class="nc" id="L1189">            a = mObj2;</span>
<span class="nc" id="L1190">            b = other.mObj2;</span>

<span class="nc bnc" id="L1192" title="All 2 branches missed.">            if (a == null) {</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">                if (b != null) {</span>
<span class="nc" id="L1194">                    return 1;</span>
                }
                // Both a and b are null.
<span class="nc" id="L1197">                return 0;</span>
            }
            else {
<span class="nc bnc" id="L1200" title="All 2 branches missed.">                if (b == null) {</span>
<span class="nc" id="L1201">                    return -1;</span>
                }
            }

<span class="nc" id="L1205">            return ((Comparable)a).compareTo(b);</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="nc bnc" id="L1210" title="All 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L1211">                return true;</span>
            }

<span class="nc bnc" id="L1214" title="All 2 branches missed.">            if (!(obj instanceof Pair)) {</span>
<span class="nc" id="L1215">                return false;</span>
            }

<span class="nc" id="L1218">            Pair key = (Pair)obj;</span>

<span class="nc bnc" id="L1220" title="All 4 branches missed.">            return</span>
                (mObj1 == null ?
<span class="nc bnc" id="L1222" title="All 6 branches missed.">                 key.mObj1 == null : mObj1.equals(key.mObj1)) &amp;&amp;</span>
                (mObj2 == null ?
<span class="nc bnc" id="L1224" title="All 2 branches missed.">                 key.mObj2 == null : mObj2.equals(key.mObj2));</span>
        }

        @Override
        public int hashCode() {
<span class="pc bpc" id="L1229" title="1 of 2 branches missed.">            return</span>
<span class="pc bpc" id="L1230" title="1 of 2 branches missed.">                (mObj1 == null ? 0 : mObj1.hashCode()) +</span>
<span class="fc" id="L1231">                (mObj2 == null ? 0 : mObj2.hashCode());</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L1236">            return &quot;[&quot; + mObj1 + ':' + mObj2 + ']';</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>