<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StringUtils.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Core XMPP Server</a> &gt; <a href="index.source.html" class="el_package">org.jivesoftware.util</a> &gt; <span class="el_source">StringUtils.java</span></div><h1>StringUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2004-2008 Jive Software. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jivesoftware.util;

import org.apache.commons.codec.binary.Base32;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.mail.internet.AddressException;
import javax.mail.internet.InternetAddress;
import javax.xml.bind.DatatypeConverter;
import java.net.IDN;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.text.BreakIterator;
import java.text.MessageFormat;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.Random;
import java.util.StringTokenizer;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Utility class to perform common String manipulation algorithms.
 */
public final class StringUtils {

<span class="fc" id="L51">    private static final Logger Log = LoggerFactory.getLogger(StringUtils.class);</span>

    // Constants used by escapeHTMLTags
<span class="fc" id="L54">    private static final char[] QUOTE_ENCODE = &quot;&amp;quot;&quot;.toCharArray();</span>
<span class="fc" id="L55">    private static final char[] AMP_ENCODE = &quot;&amp;amp;&quot;.toCharArray();</span>
<span class="fc" id="L56">    private static final char[] LT_ENCODE = &quot;&amp;lt;&quot;.toCharArray();</span>
<span class="fc" id="L57">    private static final char[] GT_ENCODE = &quot;&amp;gt;&quot;.toCharArray();</span>
    
    // docs indicate this class is thread safe
<span class="fc" id="L60">    private static Base32 Base32Hex = new Base32(true);</span>
    
<span class="nc" id="L62">    private StringUtils() {</span>
        // Not instantiable.
<span class="nc" id="L64">    }</span>

    /**
     * Replaces all instances of oldString with newString in string.
     *
     * @param string the String to search to perform replacements on.
     * @param oldString the String that should be replaced by newString.
     * @param newString the String that will replace all instances of oldString.
     * @return a String will all instances of oldString replaced by newString.
     * @deprecated Use {@link String#replaceAll(String, String)}}
     */
    @Deprecated
    public static String replace(String string, String oldString, String newString) {
<span class="fc" id="L77">        return replace(string, oldString, newString, new int[1]);</span>
    }

    /**
     * Replaces all instances of oldString with newString in line with the
     * added feature that matches of newString in oldString ignore case.
     *
     * @param line      the String to search to perform replacements on
     * @param oldString the String that should be replaced by newString
     * @param newString the String that will replace all instances of oldString
     * @return a String will all instances of oldString replaced by newString
     */
    public static String replaceIgnoreCase(String line, String oldString,
                                                 String newString) {
<span class="fc" id="L91">        return replaceIgnoreCase(line, oldString, newString, new int[1]);</span>
    }

    /**
     * Replaces all instances of oldString with newString in line with the
     * added feature that matches of newString in oldString ignore case.
     * The count paramater is set to the number of replaces performed.
     *
     * @param line      the String to search to perform replacements on
     * @param oldString the String that should be replaced by newString
     * @param newString the String that will replace all instances of oldString
     * @param count     a value that will be updated with the number of replaces
     *                  performed.
     * @return a String will all instances of oldString replaced by newString
     */
    public static String replaceIgnoreCase(String line, String oldString,
            String newString, int[] count) {
<span class="fc" id="L108">        return replace(line, oldString, newString, true, count);</span>
    }

    /**
     * Replaces all instances of oldString with newString in line.
     * The count Integer is updated with number of replaces.
     *
     * @param line the String to search to perform replacements on.
     * @param oldString the String that should be replaced by newString.
     * @param newString the String that will replace all instances of oldString.
     * @param count a single element array that, after running, will contain the number of matching items
     * @return a String will all instances of oldString replaced by newString.
     */
    public static String replace(String line, String oldString,
            String newString, int[] count) {
<span class="fc" id="L123">        return replace(line, oldString, newString, false, count);</span>
    }

    private static String replace(String line, String oldString,
                                 String newString, boolean ignoreCase, int[] count) {
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">        if (line == null) {</span>
<span class="nc" id="L129">            return null;</span>
        }
<span class="fc bfc" id="L131" title="All 2 branches covered.">        String lcLine = ignoreCase ? line.toLowerCase() : line;</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">        String lcOldString = ignoreCase ? oldString.toLowerCase() : oldString;</span>
<span class="fc" id="L133">        int i = 0;</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if ((i = lcLine.indexOf(lcOldString, i)) &gt;= 0) {</span>
<span class="fc" id="L135">            int counter = 1;</span>
<span class="fc" id="L136">            char[] line2 = line.toCharArray();</span>
<span class="fc" id="L137">            char[] newString2 = newString.toCharArray();</span>
<span class="fc" id="L138">            int oLength = oldString.length();</span>
<span class="fc" id="L139">            StringBuilder buf = new StringBuilder(line2.length);</span>
<span class="fc" id="L140">            buf.append(line2, 0, i).append(newString2);</span>
<span class="fc" id="L141">            i += oLength;</span>
<span class="fc" id="L142">            int j = i;</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">            while ((i = lcLine.indexOf(lcOldString, i)) &gt; 0) {</span>
<span class="fc" id="L144">                counter++;</span>
<span class="fc" id="L145">                buf.append(line2, j, i - j).append(newString2);</span>
<span class="fc" id="L146">                i += oLength;</span>
<span class="fc" id="L147">                j = i;</span>
            }
<span class="fc" id="L149">            buf.append(line2, j, line2.length - j);</span>
<span class="fc" id="L150">            count[0] = counter;</span>
<span class="fc" id="L151">            return buf.toString();</span>
        }
<span class="nc" id="L153">        return line;</span>
    }

    /**
     * This method takes a string and strips out all tags except &lt;br&gt; tags while still leaving
     * the tag body intact.
     *
     * @param in the text to be converted.
     * @return the input string with all tags removed.
     */
    public static String stripTags(String in) {
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (in == null) {</span>
<span class="nc" id="L165">            return null;</span>
        }
        char ch;
<span class="nc" id="L168">        int i = 0;</span>
<span class="nc" id="L169">        int last = 0;</span>
<span class="nc" id="L170">        char[] input = in.toCharArray();</span>
<span class="nc" id="L171">        int len = input.length;</span>
<span class="nc" id="L172">        StringBuilder out = new StringBuilder((int)(len * 1.3));</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        for (; i &lt; len; i++) {</span>
<span class="nc" id="L174">            ch = input[i];</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">            if (ch &gt; '&gt;') {</span>
            }
<span class="nc bnc" id="L177" title="All 2 branches missed.">            else if (ch == '&lt;') {</span>
<span class="nc bnc" id="L178" title="All 8 branches missed.">                if (i + 3 &lt; len &amp;&amp; input[i + 1] == 'b' &amp;&amp; input[i + 2] == 'r' &amp;&amp; input[i + 3] == '&gt;') {</span>
<span class="nc" id="L179">                    i += 3;</span>
<span class="nc" id="L180">                    continue;</span>
                }
<span class="nc bnc" id="L182" title="All 2 branches missed.">                if (i &gt; last) {</span>
<span class="nc" id="L183">                    out.append(input, last, i - last);</span>
                }
<span class="nc" id="L185">                last = i + 1;</span>
            }
<span class="nc bnc" id="L187" title="All 2 branches missed.">            else if (ch == '&gt;') {</span>
<span class="nc" id="L188">                last = i + 1;</span>
            }
        }
<span class="nc bnc" id="L191" title="All 2 branches missed.">        if (last == 0) {</span>
<span class="nc" id="L192">            return in;</span>
        }
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (i &gt; last) {</span>
<span class="nc" id="L195">            out.append(input, last, i - last);</span>
        }
<span class="nc" id="L197">        return out.toString();</span>
    }

    /**
     * This method takes a string which may contain HTML tags (ie, &amp;lt;b&amp;gt;,
     * &amp;lt;table&amp;gt;, etc) and converts the '&amp;lt;' and '&amp;gt;' characters to
     * their HTML escape sequences. It will also replace LF  with &amp;lt;br&amp;gt;.
     *
     * @param in the text to be converted.
     * @return the input string with the characters '&amp;lt;' and '&amp;gt;' replaced
     *         with their HTML escape sequences.
     */
    public static String escapeHTMLTags(String in) {
<span class="nc" id="L210">        return escapeHTMLTags(in, true);</span>
    }

    /**
     * This method takes a string which may contain HTML tags (ie, &amp;lt;b&amp;gt;,
     * &amp;lt;table&amp;gt;, etc) and converts the '&amp;lt;' and '&amp;gt;' characters to
     * their HTML escape sequences.
     *
     * @param in the text to be converted.
     * @param includeLF set to true to replace \n with &lt;br&gt;.
     * @return the input string with the characters '&amp;lt;' and '&amp;gt;' replaced
     *         with their HTML escape sequences.
     */
    public static String escapeHTMLTags(String in, boolean includeLF) {
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (in == null) {</span>
<span class="nc" id="L225">            return null;</span>
        }
        char ch;
<span class="nc" id="L228">        int i = 0;</span>
<span class="nc" id="L229">        int last = 0;</span>
<span class="nc" id="L230">        char[] input = in.toCharArray();</span>
<span class="nc" id="L231">        int len = input.length;</span>
<span class="nc" id="L232">        StringBuilder out = new StringBuilder((int)(len * 1.3));</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">        for (; i &lt; len; i++) {</span>
<span class="nc" id="L234">            ch = input[i];</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">            if (ch &gt; '&gt;') {</span>
            }
<span class="nc bnc" id="L237" title="All 2 branches missed.">            else if (ch == '&lt;') {</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">                if (i &gt; last) {</span>
<span class="nc" id="L239">                    out.append(input, last, i - last);</span>
                }
<span class="nc" id="L241">                last = i + 1;</span>
<span class="nc" id="L242">                out.append(LT_ENCODE);</span>
            }
<span class="nc bnc" id="L244" title="All 2 branches missed.">            else if (ch == '&gt;') {</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">                if (i &gt; last) {</span>
<span class="nc" id="L246">                    out.append(input, last, i - last);</span>
                }
<span class="nc" id="L248">                last = i + 1;</span>
<span class="nc" id="L249">                out.append(GT_ENCODE);</span>
            }
<span class="nc bnc" id="L251" title="All 4 branches missed.">            else if (ch == '\n' &amp;&amp; includeLF == true) {</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">                if (i &gt; last) {</span>
<span class="nc" id="L253">                    out.append(input, last, i - last);</span>
                }
<span class="nc" id="L255">                last = i + 1;</span>
<span class="nc" id="L256">                out.append(&quot;&lt;br&gt;&quot;);</span>
            }
        }
<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (last == 0) {</span>
<span class="nc" id="L260">            return in;</span>
        }
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (i &gt; last) {</span>
<span class="nc" id="L263">            out.append(input, last, i - last);</span>
        }
<span class="nc" id="L265">        return out.toString();</span>
    }

    /**
     * Used by the hash method.
     */
<span class="fc" id="L271">    private static Map&lt;String, MessageDigest&gt; digests =</span>
            new ConcurrentHashMap&lt;&gt;();

    /**
     * Hashes a String using the Md5 algorithm and returns the result as a
     * String of hexadecimal numbers. This method is synchronized to avoid
     * excessive MessageDigest object creation. If calling this method becomes
     * a bottleneck in your code, you may wish to maintain a pool of
     * MessageDigest objects instead of using this method.
     * &lt;p&gt;
     * A hash is a one-way function -- that is, given an
     * input, an output is easily computed. However, given the output, the
     * input is almost impossible to compute. This is useful for passwords
     * since we can store the hash and a hacker will then have a very hard time
     * determining the original password.&lt;/p&gt;
     * &lt;p&gt;
     * In Jive, every time a user logs in, we simply
     * take their plain text password, compute the hash, and compare the
     * generated hash to the stored hash. Since it is almost impossible that
     * two passwords will generate the same hash, we know if the user gave us
     * the correct password or not. The only negative to this system is that
     * password recovery is basically impossible. Therefore, a reset password
     * method is used instead.&lt;/p&gt;
     *
     * @param data the String to compute the hash of.
     * @return a hashed version of the passed-in String
     */
    public static String hash(String data) {
<span class="fc" id="L299">        return hash(data, &quot;MD5&quot;);</span>
    }

    /**
     * Hashes a String using the specified algorithm and returns the result as a
     * String of hexadecimal numbers. This method is synchronized to avoid
     * excessive MessageDigest object creation. If calling this method becomes
     * a bottleneck in your code, you may wish to maintain a pool of
     * MessageDigest objects instead of using this method.
     * &lt;p&gt;
     * A hash is a one-way function -- that is, given an
     * input, an output is easily computed. However, given the output, the
     * input is almost impossible to compute. This is useful for passwords
     * since we can store the hash and a hacker will then have a very hard time
     * determining the original password.&lt;/p&gt;
     * &lt;p&gt;
     * In Jive, every time a user logs in, we simply
     * take their plain text password, compute the hash, and compare the
     * generated hash to the stored hash. Since it is almost impossible that
     * two passwords will generate the same hash, we know if the user gave us
     * the correct password or not. The only negative to this system is that
     * password recovery is basically impossible. Therefore, a reset password
     * method is used instead.&lt;/p&gt;
     *
     * @param data the String to compute the hash of.
     * @param algorithm the name of the algorithm requested.
     * @return a hashed version of the passed-in String
     */
    public static String hash(String data, String algorithm) {
<span class="fc" id="L328">        return hash(data.getBytes(StandardCharsets.UTF_8), algorithm);</span>
    }

    /**
     * Hashes a byte array using the specified algorithm and returns the result as a
     * String of hexadecimal numbers. This method is synchronized to avoid
     * excessive MessageDigest object creation. If calling this method becomes
     * a bottleneck in your code, you may wish to maintain a pool of
     * MessageDigest objects instead of using this method.
     * &lt;p&gt;
     * A hash is a one-way function -- that is, given an
     * input, an output is easily computed. However, given the output, the
     * input is almost impossible to compute. This is useful for passwords
     * since we can store the hash and a hacker will then have a very hard time
     * determining the original password.
     * &lt;/p&gt;
     * &lt;p&gt;In Jive, every time a user logs in, we simply
     * take their plain text password, compute the hash, and compare the
     * generated hash to the stored hash. Since it is almost impossible that
     * two passwords will generate the same hash, we know if the user gave us
     * the correct password or not. The only negative to this system is that
     * password recovery is basically impossible. Therefore, a reset password
     * method is used instead.&lt;/p&gt;
     *
     * @param bytes the byte array to compute the hash of.
     * @param algorithm the name of the algorithm requested.
     * @return a hashed version of the passed-in String
     */
    public static String hash(byte[] bytes, String algorithm) {
<span class="fc" id="L357">        synchronized (algorithm.intern()) {</span>
<span class="fc" id="L358">            MessageDigest digest = digests.get(algorithm);</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">            if (digest == null) {</span>
                try {
<span class="fc" id="L361">                    digest = MessageDigest.getInstance(algorithm);</span>
<span class="fc" id="L362">                    digests.put(algorithm, digest);</span>
                }
<span class="nc" id="L364">                catch (NoSuchAlgorithmException nsae) {</span>
<span class="nc" id="L365">                    Log.error(&quot;Failed to load the &quot; + algorithm + &quot; MessageDigest. &quot; +</span>
                            &quot;Jive will be unable to function normally.&quot;, nsae);
<span class="nc" id="L367">                    return null;</span>
<span class="fc" id="L368">                }</span>
            }
            // Now, compute hash.
<span class="fc" id="L371">            digest.update(bytes);</span>
<span class="fc" id="L372">            return encodeHex(digest.digest());</span>
<span class="nc" id="L373">        }</span>
    }

    /**
     * Turns an array of bytes into a String representing each byte as an
     * unsigned hex number.
     *
     * @param bytes an array of bytes to convert to a hex-string
     * @return generated hex string
     */
    public static String encodeHex(byte[] bytes) {
<span class="fc" id="L384">        return DatatypeConverter.printHexBinary(bytes).toLowerCase();</span>
    }

    /**
     * Turns a hex encoded string into a byte array. It is specifically meant
     * to &quot;reverse&quot; the toHex(byte[]) method.
     *
     * @param hex a hex encoded String to transform into a byte array.
     * @return a byte array representing the hex String[
     */
    public static byte[] decodeHex(String hex) {
<span class="fc" id="L395">        return DatatypeConverter.parseHexBinary(hex);</span>
    }

    /**
     * Encodes a String as a base64 String.
     *
     * @param data a String to encode.
     * @return a base64 encoded String.
     */
    public static String encodeBase64(String data) {
<span class="nc" id="L405">        byte[] bytes = data.getBytes(StandardCharsets.UTF_8);</span>
<span class="nc" id="L406">        return encodeBase64(bytes);</span>
    }

    /**
     * Encodes a byte array into a base64 String.
     *
     * @param data a byte array to encode.
     * @return a base64 encode String.
     */
    public static String encodeBase64(byte[] data) {
        // Encode the String. We pass in a flag to specify that line
        // breaks not be added. This is consistent with our previous base64
        // implementation. Section 2.1 of 3548 (base64 spec) also specifies
        // no line breaks by default.
<span class="fc" id="L420">        return Base64.encodeBytes(data, Base64.DONT_BREAK_LINES);</span>
    }

    /**
     * Decodes a base64 String.
     *
     * @param data a base64 encoded String to decode.
     * @return the decoded String.
     */
    public static byte[] decodeBase64(String data) {
<span class="nc" id="L430">        return Base64.decode(data);</span>
    }

    /**
     * Encodes a String as a base32 String using the base32hex profile.
     *
     * @param data a String to encode.
     * @return a base32 encoded String.
     */
    public static String encodeBase32(String data) {
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">        byte[] bytes = data == null ? null : data.getBytes(StandardCharsets.UTF_8);</span>
<span class="fc" id="L441">        return encodeBase32(bytes);</span>
    }

    /**
     * Encodes a byte array into a base32 String using the base32hex profile.
     * Implementation is case-insensitive and returns encoded strings in lower case.
     *
     * @param data a byte array to encode.
     * @return a base32 encode String.
     */
    public static String encodeBase32(byte[] data) {
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">        return data == null ? null : Base32Hex.encodeAsString(data).toLowerCase();</span>
    }

    /**
     * Decodes a base32 String using the base32hex profile. Implementation
     * is case-insensitive and converts the given string to upper case before
     * decoding.
     *
     * @param data a base32 encoded String to decode.
     * @return the decoded String.
     */
    public static byte[] decodeBase32(String data) {
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">        return data == null ? null : Base32Hex.decode(data.toUpperCase());</span>
    }
    
    /**
     * Validates a string to ensure all its bytes are in the Base32 alphabet.
     * Implementation is case-insensitive and converts the given string to 
     * upper case before evaluating.
     * 
     * @param data the string to test
     * @return True if the given string can be decoded using Base32
     */
    public static boolean isBase32(String data) {
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">        return data == null ? false : Base32Hex.isInAlphabet(data.toUpperCase());</span>
    }

    /**
     * Converts a line of text into an array of lower case words using a
     * BreakIterator.wordInstance().&lt;p&gt;
     *
     * This method is under the Jive Open Source Software License and was
     * written by Mark Imbriaco.
     *
     * @param text a String of text to convert into an array of words
     * @return text broken up into an array of words.
     */
    public static String[] toLowerCaseWordArray(String text) {
<span class="nc bnc" id="L490" title="All 4 branches missed.">        if (text == null || text.length() == 0) {</span>
<span class="nc" id="L491">            return new String[0];</span>
        }

<span class="nc" id="L494">        List&lt;String&gt; wordList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L495">        BreakIterator boundary = BreakIterator.getWordInstance();</span>
<span class="nc" id="L496">        boundary.setText(text);</span>
<span class="nc" id="L497">        int start = 0;</span>

<span class="nc bnc" id="L499" title="All 2 branches missed.">        for (int end = boundary.next(); end != BreakIterator.DONE;</span>
<span class="nc" id="L500">             start = end, end = boundary.next()) {</span>
<span class="nc" id="L501">            String tmp = text.substring(start, end).trim();</span>
            // Remove characters that are not needed.
<span class="nc" id="L503">            tmp = replace(tmp, &quot;+&quot;, &quot;&quot;);</span>
<span class="nc" id="L504">            tmp = replace(tmp, &quot;/&quot;, &quot;&quot;);</span>
<span class="nc" id="L505">            tmp = replace(tmp, &quot;\\&quot;, &quot;&quot;);</span>
<span class="nc" id="L506">            tmp = replace(tmp, &quot;#&quot;, &quot;&quot;);</span>
<span class="nc" id="L507">            tmp = replace(tmp, &quot;*&quot;, &quot;&quot;);</span>
<span class="nc" id="L508">            tmp = replace(tmp, &quot;)&quot;, &quot;&quot;);</span>
<span class="nc" id="L509">            tmp = replace(tmp, &quot;(&quot;, &quot;&quot;);</span>
<span class="nc" id="L510">            tmp = replace(tmp, &quot;&amp;&quot;, &quot;&quot;);</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">            if (tmp.length() &gt; 0) {</span>
<span class="nc" id="L512">                wordList.add(tmp);</span>
            }
        }
<span class="nc" id="L515">        return wordList.toArray(new String[wordList.size()]);</span>
    }

    /**
     * A cryptographically strong random number generator object for use with randomString().
     */
<span class="fc" id="L521">    private static Random randGen = new SecureRandom();</span>

    /**
     * Array of numbers and letters of mixed case. Numbers appear in the list
     * twice so that there is a more equal chance that a number will be picked.
     * We can use the array to get a random number or letter by picking a random
     * array index.
     */
<span class="fc" id="L529">    private static char[] numbersAndLetters = (&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot; +</span>
<span class="fc" id="L530">            &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;).toCharArray();</span>

    /**
     * Returns a random String of numbers and letters (lower and upper case)
     * of the specified length. The method uses a cryptographically strong
     * random number generator as provided by {@link SecureRandom}
     * &lt;p&gt;
     * The specified length must be at least one. If not, the method will return
     * null.&lt;/p&gt;
     *
     * @param length the desired length of the random String to return.
     * @return a random String of numbers and letters of the specified length.
     */
    public static String randomString(int length) {
<span class="nc bnc" id="L544" title="All 2 branches missed.">        if (length &lt; 1) {</span>
<span class="nc" id="L545">            return null;</span>
        }
        // Create a char buffer to put random letters and numbers in.
<span class="nc" id="L548">        char[] randBuffer = new char[length];</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">        for (int i = 0; i &lt; randBuffer.length; i++) {</span>
<span class="nc" id="L550">            randBuffer[i] = numbersAndLetters[randGen.nextInt(numbersAndLetters.length)];</span>
        }
<span class="nc" id="L552">        return new String(randBuffer);</span>
    }

    /**
     * Intelligently chops a String at a word boundary (whitespace) that occurs
     * at the specified index in the argument or before. However, if there is a
     * newline character before &lt;code&gt;length&lt;/code&gt;, the String will be chopped
     * there. If no newline or whitespace is found in &lt;code&gt;string&lt;/code&gt; up to
     * the index &lt;code&gt;length&lt;/code&gt;, the String will chopped at &lt;code&gt;length&lt;/code&gt;.
     * &lt;p&gt;
     * For example, chopAtWord(&quot;This is a nice String&quot;, 10) will return
     * &quot;This is a&quot; which is the first word boundary less than or equal to 10
     * characters into the original String.&lt;/p&gt;
     *
     * @param string the String to chop.
     * @param length the index in &lt;code&gt;string&lt;/code&gt; to start looking for a
     *               whitespace boundary at.
     * @return a substring of &lt;code&gt;string&lt;/code&gt; whose length is less than or
     *         equal to &lt;code&gt;length&lt;/code&gt;, and that is chopped at whitespace.
     */
    public static String chopAtWord(String string, int length) {
<span class="nc bnc" id="L573" title="All 4 branches missed.">        if (string == null || string.length() == 0) {</span>
<span class="nc" id="L574">            return string;</span>
        }

<span class="nc" id="L577">        char[] charArray = string.toCharArray();</span>
<span class="nc" id="L578">        int sLength = string.length();</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">        if (length &lt; sLength) {</span>
<span class="nc" id="L580">            sLength = length;</span>
        }

        // First check if there is a newline character before length; if so,
        // chop word there.
<span class="nc bnc" id="L585" title="All 2 branches missed.">        for (int i = 0; i &lt; sLength - 1; i++) {</span>
            // Windows
<span class="nc bnc" id="L587" title="All 4 branches missed.">            if (charArray[i] == '\r' &amp;&amp; charArray[i + 1] == '\n') {</span>
<span class="nc" id="L588">                return string.substring(0, i + 1);</span>
            }
            // Unix
<span class="nc bnc" id="L591" title="All 2 branches missed.">            else if (charArray[i] == '\n') {</span>
<span class="nc" id="L592">                return string.substring(0, i);</span>
            }
        }
        // Also check boundary case of Unix newline
<span class="nc bnc" id="L596" title="All 2 branches missed.">        if (charArray[sLength - 1] == '\n') {</span>
<span class="nc" id="L597">            return string.substring(0, sLength - 1);</span>
        }

        // Done checking for newline, now see if the total string is less than
        // the specified chop point.
<span class="nc bnc" id="L602" title="All 2 branches missed.">        if (string.length() &lt; length) {</span>
<span class="nc" id="L603">            return string;</span>
        }

        // No newline, so chop at the first whitespace.
<span class="nc bnc" id="L607" title="All 2 branches missed.">        for (int i = length - 1; i &gt; 0; i--) {</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">            if (charArray[i] == ' ') {</span>
<span class="nc" id="L609">                return string.substring(0, i).trim();</span>
            }
        }

        // Did not find word boundary so return original String chopped at
        // specified length.
<span class="nc" id="L615">        return string.substring(0, length);</span>
    }

    /**
     * Reformats a string where lines that are longer than {@code width}
     * are split apart at the earliest wordbreak or at maxLength, whichever is
     * sooner. If the width specified is less than 5 or greater than the input
     * Strings length the string will be returned as is.
     * &lt;p&gt;
     * Please note that this method can be lossy - trailing spaces on wrapped
     * lines may be trimmed.&lt;/p&gt;
     *
     * @param input the String to reformat.
     * @param width the maximum length of any one line.
     * @param locale the local
     * @return a new String with reformatted as needed.
     */
    public static String wordWrap(String input, int width, Locale locale) {
        // protect ourselves
<span class="nc bnc" id="L634" title="All 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L635">            return &quot;&quot;;</span>
        }
<span class="nc bnc" id="L637" title="All 2 branches missed.">        else if (width &lt; 5) {</span>
<span class="nc" id="L638">            return input;</span>
        }
<span class="nc bnc" id="L640" title="All 2 branches missed.">        else if (width &gt;= input.length()) {</span>
<span class="nc" id="L641">            return input;</span>
        }

        // default locale
<span class="nc bnc" id="L645" title="All 2 branches missed.">        if (locale == null) {</span>
<span class="nc" id="L646">            locale = JiveGlobals.getLocale();</span>
        }

<span class="nc" id="L649">        StringBuilder buf = new StringBuilder(input);</span>
<span class="nc" id="L650">        boolean endOfLine = false;</span>
<span class="nc" id="L651">        int lineStart = 0;</span>

<span class="nc bnc" id="L653" title="All 2 branches missed.">        for (int i = 0; i &lt; buf.length(); i++) {</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">            if (buf.charAt(i) == '\n') {</span>
<span class="nc" id="L655">                lineStart = i + 1;</span>
<span class="nc" id="L656">                endOfLine = true;</span>
            }

            // handle splitting at width character
<span class="nc bnc" id="L660" title="All 2 branches missed.">            if (i &gt; lineStart + width - 1) {</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">                if (!endOfLine) {</span>
<span class="nc" id="L662">                    int limit = i - lineStart - 1;</span>
<span class="nc" id="L663">                    BreakIterator breaks = BreakIterator.getLineInstance(locale);</span>
<span class="nc" id="L664">                    breaks.setText(buf.substring(lineStart, i));</span>
<span class="nc" id="L665">                    int end = breaks.last();</span>

                    // if the last character in the search string isn't a space,
                    // we can't split on it (looks bad). Search for a previous
                    // break character
<span class="nc bnc" id="L670" title="All 2 branches missed.">                    if (end == limit + 1) {</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">                        if (!Character.isWhitespace(buf.charAt(lineStart + end))) {</span>
<span class="nc" id="L672">                            end = breaks.preceding(end - 1);</span>
                        }
                    }

                    // if the last character is a space, replace it with a \n
<span class="nc bnc" id="L677" title="All 4 branches missed.">                    if (end != BreakIterator.DONE &amp;&amp; end == limit + 1) {</span>
<span class="nc" id="L678">                        buf.replace(lineStart + end, lineStart + end + 1, &quot;\n&quot;);</span>
<span class="nc" id="L679">                        lineStart = lineStart + end;</span>
                    }
                    // otherwise, just insert a \n
<span class="nc bnc" id="L682" title="All 4 branches missed.">                    else if (end != BreakIterator.DONE &amp;&amp; end != 0) {</span>
<span class="nc" id="L683">                        buf.insert(lineStart + end, '\n');</span>
<span class="nc" id="L684">                        lineStart = lineStart + end + 1;</span>
                    }
                    else {
<span class="nc" id="L687">                        buf.insert(i, '\n');</span>
<span class="nc" id="L688">                        lineStart = i + 1;</span>
                    }
<span class="nc" id="L690">                }</span>
                else {
<span class="nc" id="L692">                    buf.insert(i, '\n');</span>
<span class="nc" id="L693">                    lineStart = i + 1;</span>
<span class="nc" id="L694">                    endOfLine = false;</span>
                }
            }
        }

<span class="nc" id="L699">        return buf.toString();</span>
    }

    /**
     * Escapes all necessary characters in the String so that it can be used in SQL
     *
     * @param string the string to escape.
     * @return the string with appropriate characters escaped.
     */
    public static String escapeForSQL(String string) {
<span class="nc bnc" id="L709" title="All 2 branches missed.">        if (string == null) {</span>
<span class="nc" id="L710">            return null;</span>
        }
<span class="nc bnc" id="L712" title="All 2 branches missed.">        else if (string.length() == 0) {</span>
<span class="nc" id="L713">            return string;</span>
        }

        char ch;
<span class="nc" id="L717">        char[] input = string.toCharArray();</span>
<span class="nc" id="L718">        int i = 0;</span>
<span class="nc" id="L719">        int last = 0;</span>
<span class="nc" id="L720">        int len = input.length;</span>
<span class="nc" id="L721">        StringBuilder out = null;</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">        for (; i &lt; len; i++) {</span>
<span class="nc" id="L723">            ch = input[i];</span>

<span class="nc bnc" id="L725" title="All 2 branches missed.">            if (ch == '\'') {</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">                if (out == null) {</span>
<span class="nc" id="L727">                     out = new StringBuilder(len + 2);</span>
                }
<span class="nc bnc" id="L729" title="All 2 branches missed.">                if (i &gt; last) {</span>
<span class="nc" id="L730">                    out.append(input, last, i - last);</span>
                }
<span class="nc" id="L732">                last = i + 1;</span>
<span class="nc" id="L733">                out.append('\'').append('\'');</span>
            }
        }

<span class="nc bnc" id="L737" title="All 2 branches missed.">        if (out == null) {</span>
<span class="nc" id="L738">            return string;</span>
        }
<span class="nc bnc" id="L740" title="All 2 branches missed.">        else if (i &gt; last) {</span>
<span class="nc" id="L741">            out.append(input, last, i - last);</span>
        }

<span class="nc" id="L744">        return out.toString();</span>
    }

    /**
     * Escapes all necessary characters in the String so that it can be used
     * in an XML doc.
     *
     * @param string the string to escape.
     * @return the string with appropriate characters escaped.
     */
    public static String escapeForXML(String string) {
<span class="nc bnc" id="L755" title="All 2 branches missed.">        if (string == null) {</span>
<span class="nc" id="L756">            return null;</span>
        }
        char ch;
<span class="nc" id="L759">        int i = 0;</span>
<span class="nc" id="L760">        int last = 0;</span>
<span class="nc" id="L761">        char[] input = string.toCharArray();</span>
<span class="nc" id="L762">        int len = input.length;</span>
<span class="nc" id="L763">        StringBuilder out = new StringBuilder((int)(len * 1.3));</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">        for (; i &lt; len; i++) {</span>
<span class="nc" id="L765">            ch = input[i];</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">            if (ch &gt; '&gt;') {</span>
            }
<span class="nc bnc" id="L768" title="All 2 branches missed.">            else if (ch == '&lt;') {</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">                if (i &gt; last) {</span>
<span class="nc" id="L770">                    out.append(input, last, i - last);</span>
                }
<span class="nc" id="L772">                last = i + 1;</span>
<span class="nc" id="L773">                out.append(LT_ENCODE);</span>
            }
<span class="nc bnc" id="L775" title="All 2 branches missed.">            else if (ch == '&amp;') {</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">                if (i &gt; last) {</span>
<span class="nc" id="L777">                    out.append(input, last, i - last);</span>
                }
<span class="nc" id="L779">                last = i + 1;</span>
<span class="nc" id="L780">                out.append(AMP_ENCODE);</span>
            }
<span class="nc bnc" id="L782" title="All 2 branches missed.">            else if (ch == '&quot;') {</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">                if (i &gt; last) {</span>
<span class="nc" id="L784">                    out.append(input, last, i - last);</span>
                }
<span class="nc" id="L786">                last = i + 1;</span>
<span class="nc" id="L787">                out.append(QUOTE_ENCODE);</span>
            }
        }
<span class="nc bnc" id="L790" title="All 2 branches missed.">        if (last == 0) {</span>
<span class="nc" id="L791">            return string;</span>
        }
<span class="nc bnc" id="L793" title="All 2 branches missed.">        if (i &gt; last) {</span>
<span class="nc" id="L794">            out.append(input, last, i - last);</span>
        }
<span class="nc" id="L796">        return out.toString();</span>
    }

    /**
     * Unescapes the String by converting XML escape sequences back into normal
     * characters.
     *
     * @param string the string to unescape.
     * @return the string with appropriate characters unescaped.
     */
    public static String unescapeFromXML(String string) {
<span class="nc" id="L807">        string = replace(string, &quot;&amp;lt;&quot;, &quot;&lt;&quot;);</span>
<span class="nc" id="L808">        string = replace(string, &quot;&amp;gt;&quot;, &quot;&gt;&quot;);</span>
<span class="nc" id="L809">        string = replace(string, &quot;&amp;quot;&quot;, &quot;\&quot;&quot;);</span>
<span class="nc" id="L810">        return replace(string, &quot;&amp;amp;&quot;, &quot;&amp;&quot;);</span>
    }

<span class="fc" id="L813">    private static final char[] zeroArray =</span>
<span class="fc" id="L814">            &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;.toCharArray();</span>

    /**
     * Pads the supplied String with 0's to the specified length and returns
     * the result as a new String. For example, if the initial String is
     * &quot;9999&quot; and the desired length is 8, the result would be &quot;00009999&quot;.
     * This type of padding is useful for creating numerical values that need
     * to be stored and sorted as character data. Note: the current
     * implementation of this method allows for a maximum {@code length} of
     * 64.
     *
     * @param string the original String to pad.
     * @param length the desired length of the new padded String.
     * @return a new String padded with the required number of 0's.
     */
    public static String zeroPadString(String string, int length) {
<span class="nc bnc" id="L830" title="All 4 branches missed.">        if (string == null || string.length() &gt; length) {</span>
<span class="nc" id="L831">            return string;</span>
        }
<span class="nc" id="L833">        StringBuilder buf = new StringBuilder(length);</span>
<span class="nc" id="L834">        buf.append(zeroArray, 0, length - string.length()).append(string);</span>
<span class="nc" id="L835">        return buf.toString();</span>
    }

    /**
     * Formats a Date as a fifteen character long String made up of the Date's
     * padded millisecond value.
     * @param date the date to encode
     * @return a Date encoded as a String.
     */
    public static String dateToMillis(Date date) {
<span class="nc" id="L845">        return zeroPadString(Long.toString(date.getTime()), 15);</span>
    }

    /**
     * Returns a textual representation for the time that has elapsed.
     *
     * @param delta the elapsed time in milliseconds
     * @return textual representation for the time that has elapsed.
     */
    public static String getFullElapsedTime(final long delta) {
<span class="fc bfc" id="L855" title="All 2 branches covered.">        if (delta &lt; JiveConstants.SECOND) {</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">            return String.format(&quot;%d %s&quot;, delta, delta == 1 ? LocaleUtils.getLocalizedString(&quot;global.millisecond&quot;) : LocaleUtils.getLocalizedString(&quot;global.milliseconds&quot;));</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">        } else if (delta &lt; JiveConstants.MINUTE) {</span>
<span class="fc" id="L858">            final long millis = delta % JiveConstants.SECOND;</span>
<span class="fc" id="L859">            final long seconds = delta / JiveConstants.SECOND;</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">            final String secondsString = String.format(&quot;%d %s&quot;, seconds, seconds == 1 ? LocaleUtils.getLocalizedString(&quot;global.second&quot;) : LocaleUtils.getLocalizedString(&quot;global.seconds&quot;));</span>
<span class="fc bfc" id="L861" title="All 2 branches covered.">            if (millis &gt; 0) {</span>
<span class="fc" id="L862">                return secondsString + &quot;, &quot; + getFullElapsedTime(millis);</span>
            } else {
<span class="fc" id="L864">                return secondsString;</span>
            }
<span class="fc bfc" id="L866" title="All 2 branches covered.">        } else if (delta &lt; JiveConstants.HOUR) {</span>
<span class="fc" id="L867">            final long millis = delta % JiveConstants.MINUTE;</span>
<span class="fc" id="L868">            final long minutes = delta / JiveConstants.MINUTE;</span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">            final String minutesString = String.format(&quot;%d %s&quot;, minutes, minutes == 1 ? LocaleUtils.getLocalizedString(&quot;global.minute&quot;) : LocaleUtils.getLocalizedString(&quot;global.minutes&quot;));</span>
<span class="fc bfc" id="L870" title="All 2 branches covered.">            if (millis &gt; 0) {</span>
<span class="fc" id="L871">                return minutesString + &quot;, &quot; + getFullElapsedTime(millis);</span>
            } else {
<span class="fc" id="L873">                return minutesString;</span>
            }
<span class="fc bfc" id="L875" title="All 2 branches covered.">        } else if (delta &lt; JiveConstants.DAY) {</span>
<span class="fc" id="L876">            final long millis = delta % JiveConstants.HOUR;</span>
<span class="fc" id="L877">            final long hours = delta / JiveConstants.HOUR;</span>
<span class="fc bfc" id="L878" title="All 2 branches covered.">            final String daysString = String.format(&quot;%d %s&quot;, hours, hours == 1 ? LocaleUtils.getLocalizedString(&quot;global.hour&quot;) : LocaleUtils.getLocalizedString(&quot;global.hours&quot;));</span>
<span class="fc bfc" id="L879" title="All 2 branches covered.">            if (millis &gt; 0) {</span>
<span class="fc" id="L880">                return daysString + &quot;, &quot; + getFullElapsedTime(millis);</span>
            } else {
<span class="fc" id="L882">                return daysString;</span>
            }
        } else {
<span class="fc" id="L885">            final long millis = delta % JiveConstants.DAY;</span>
<span class="fc" id="L886">            final long days = delta / JiveConstants.DAY;</span>
<span class="fc bfc" id="L887" title="All 2 branches covered.">            final String daysString = String.format(&quot;%d %s&quot;, days, days == 1 ? LocaleUtils.getLocalizedString(&quot;global.day&quot;) : LocaleUtils.getLocalizedString(&quot;global.days&quot;));</span>
<span class="fc bfc" id="L888" title="All 2 branches covered.">            if (millis &gt; 0) {</span>
<span class="fc" id="L889">                return daysString + &quot;, &quot; + getFullElapsedTime(millis);</span>
            } else {
<span class="fc" id="L891">                return daysString;</span>
            }
        }
    }

    /**
     * Returns a textual representation for the time that has elapsed.
     *
     * @param delta the elapsed time.
     * @return textual representation for the time that has elapsed.
     */
    public static String getFullElapsedTime(final Duration delta) {
<span class="fc" id="L903">        return getFullElapsedTime(delta.toMillis());</span>
    }

    /**
     * Returns a textual representation for the time that has elapsed.
     *
     * @param delta the elapsed time in milliseconds.
     * @return textual representation for the time that has elapsed.
     */
    public static String getElapsedTime(long delta) {
<span class="nc bnc" id="L913" title="All 2 branches missed.">        if (delta &lt; JiveConstants.MINUTE) {</span>
<span class="nc" id="L914">            return LocaleUtils.getLocalizedString(&quot;global.less-minute&quot;);</span>
        }
<span class="nc bnc" id="L916" title="All 2 branches missed.">        else if (delta &lt; JiveConstants.HOUR) {</span>
<span class="nc" id="L917">            long mins = delta / JiveConstants.MINUTE;</span>
<span class="nc" id="L918">            StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L919">            sb.append(mins).append(' ');</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">            sb.append((mins==1) ? LocaleUtils.getLocalizedString(&quot;global.minute&quot;) : LocaleUtils.getLocalizedString(&quot;global.minutes&quot;));</span>
<span class="nc" id="L921">            return sb.toString();</span>
        }
<span class="nc bnc" id="L923" title="All 2 branches missed.">        else if (delta &lt; JiveConstants.DAY) {</span>
<span class="nc" id="L924">            long hours = delta / JiveConstants.HOUR;</span>
<span class="nc" id="L925">            delta -= hours * JiveConstants.HOUR;</span>
<span class="nc" id="L926">            long mins = delta / JiveConstants.MINUTE;</span>
<span class="nc" id="L927">            StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L928">            sb.append(hours).append(' ');</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">            sb.append((hours == 1) ? LocaleUtils.getLocalizedString(&quot;global.hour&quot;) : LocaleUtils.getLocalizedString(&quot;global.hours&quot;));</span>
<span class="nc" id="L930">            sb.append(&quot;, &quot;);</span>
<span class="nc" id="L931">            sb.append(mins).append(' ');</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">            sb.append((mins == 1) ? LocaleUtils.getLocalizedString(&quot;global.minute&quot;) : LocaleUtils.getLocalizedString(&quot;global.minutes&quot;));</span>
<span class="nc" id="L933">            return sb.toString();</span>
        } else {
<span class="nc" id="L935">            long days = delta / JiveConstants.DAY;</span>
<span class="nc" id="L936">            delta -= days * JiveConstants.DAY;</span>
<span class="nc" id="L937">            long hours = delta / JiveConstants.HOUR;</span>
<span class="nc" id="L938">            delta -= hours * JiveConstants.HOUR;</span>
<span class="nc" id="L939">            long mins = delta / JiveConstants.MINUTE;</span>
<span class="nc" id="L940">            StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L941">            sb.append(days).append(' ');</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">            sb.append((days == 1) ? LocaleUtils.getLocalizedString(&quot;global.day&quot;) : LocaleUtils.getLocalizedString(&quot;global.days&quot;));</span>
<span class="nc" id="L943">            sb.append(&quot;, &quot;);</span>
<span class="nc" id="L944">            sb.append(hours).append(' ');</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">            sb.append((hours == 1) ? LocaleUtils.getLocalizedString(&quot;global.hour&quot;) : LocaleUtils.getLocalizedString(&quot;global.hours&quot;));</span>
<span class="nc" id="L946">            sb.append(&quot;, &quot;);</span>
<span class="nc" id="L947">            sb.append(mins).append(' ');</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">            sb.append((mins == 1) ? LocaleUtils.getLocalizedString(&quot;global.minute&quot;) : LocaleUtils.getLocalizedString(&quot;global.minutes&quot;));</span>
<span class="nc" id="L949">            return sb.toString();</span>
        }
    }

    /**
     * Returns a formatted String from time.
     *
     * @param diff the amount of elapsed time.
     * @return the formatte String.
     */
    public static String getTimeFromLong(long diff) {
<span class="nc" id="L960">        final String HOURS = &quot;h&quot;;</span>
<span class="nc" id="L961">        final String MINUTES = &quot;min&quot;;</span>
        //final String SECONDS = &quot;sec&quot;;

<span class="nc" id="L964">        final long MS_IN_A_DAY = 1000 * 60 * 60 * 24;</span>
<span class="nc" id="L965">        final long MS_IN_AN_HOUR = 1000 * 60 * 60;</span>
<span class="nc" id="L966">        final long MS_IN_A_MINUTE = 1000 * 60;</span>
<span class="nc" id="L967">        final long MS_IN_A_SECOND = 1000;</span>
        //Date currentTime = new Date();
        //long numDays = diff / MS_IN_A_DAY;
<span class="nc" id="L970">        diff = diff % MS_IN_A_DAY;</span>
<span class="nc" id="L971">        long numHours = diff / MS_IN_AN_HOUR;</span>
<span class="nc" id="L972">        diff = diff % MS_IN_AN_HOUR;</span>
<span class="nc" id="L973">        long numMinutes = diff / MS_IN_A_MINUTE;</span>
<span class="nc" id="L974">        diff = diff % MS_IN_A_MINUTE;</span>
        //long numSeconds = diff / MS_IN_A_SECOND;
<span class="nc" id="L976">        diff = diff % MS_IN_A_SECOND;</span>
        //long numMilliseconds = diff;

<span class="nc" id="L979">        StringBuilder buf = new StringBuilder();</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">        if (numHours &gt; 0) {</span>
<span class="nc" id="L981">            buf.append(numHours).append(' ').append(HOURS).append(&quot;, &quot;);</span>
        }

<span class="nc bnc" id="L984" title="All 2 branches missed.">        if (numMinutes &gt; 0) {</span>
<span class="nc" id="L985">            buf.append(numMinutes).append(' ').append(MINUTES);</span>
        }

        //buf.append(numSeconds + &quot; &quot; + SECONDS);

<span class="nc" id="L990">        String result = buf.toString();</span>

<span class="nc bnc" id="L992" title="All 2 branches missed.">        if (numMinutes &lt; 1) {</span>
<span class="nc" id="L993">            result = &quot;&lt; 1 minute&quot;;</span>
        }

<span class="nc" id="L996">        return result;</span>
    }

    /**
     * Returns a collection of Strings as a comma-delimitted list of strings.
     * @param collection the collection of strings
     * @return a String representing the Collection.
     */
    public static String collectionToString(Collection&lt;String&gt; collection) {
<span class="nc bnc" id="L1005" title="All 4 branches missed.">        if (collection == null || collection.isEmpty()) {</span>
<span class="nc" id="L1006">            return &quot;&quot;;</span>
        }
<span class="nc" id="L1008">        StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L1009">        String delim = &quot;&quot;;</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">        for (String element : collection) {</span>
<span class="nc" id="L1011">            buf.append(delim);</span>
<span class="nc" id="L1012">            buf.append(element);</span>
<span class="nc" id="L1013">            delim = &quot;,&quot;;</span>
<span class="nc" id="L1014">        }</span>
<span class="nc" id="L1015">        return buf.toString();</span>
    }

    /**
     * Returns a comma-delimitted list of Strings as a Collection.
     * @param string the string to split
     * @return a Collection representing the String.
     */
    public static Collection&lt;String&gt; stringToCollection(String string) {
<span class="pc bpc" id="L1024" title="2 of 4 branches missed.">        if (string == null || string.trim().length() == 0) {</span>
<span class="nc" id="L1025">            return Collections.emptyList();</span>
        }
<span class="fc" id="L1027">        Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1028">        StringTokenizer tokens = new StringTokenizer(string, &quot;,&quot;);</span>
<span class="fc bfc" id="L1029" title="All 2 branches covered.">        while (tokens.hasMoreTokens()) {</span>
<span class="fc" id="L1030">            collection.add(tokens.nextToken().trim());</span>
        }
<span class="fc" id="L1032">        return collection;</span>
    }

    /**
     * Returns true if the given string is in the given array.
     * 
     * @param array an array of Strings to check
     * @param item the item to look for
     * @return true if the array contains the item
     */
    public static boolean contains(String[] array, String item) {
<span class="nc bnc" id="L1043" title="All 6 branches missed.">        if (array == null || array.length == 0 || item == null) {</span>
<span class="nc" id="L1044">            return false;</span>
        }
<span class="nc bnc" id="L1046" title="All 2 branches missed.">        for (String anArray : array) {</span>
<span class="nc bnc" id="L1047" title="All 2 branches missed.">            if (item.equals(anArray)) {</span>
<span class="nc" id="L1048">                return true;</span>
            }
        }
<span class="nc" id="L1051">        return false;</span>
    }

    /**
     * Abbreviates a string to a specified length and then adds an ellipsis
     * if the input is greater than the maxWidth. Example input:
     * &lt;pre&gt;
     *      user1@jivesoftware.com/home
     * &lt;/pre&gt;
     * and a maximum length of 20 characters, the abbreviate method will return:
     * &lt;pre&gt;
     *      user1@jivesoftware.c...
     * &lt;/pre&gt;
     * @param str the String to abbreviate.
     * @param maxWidth the maximum size of the string, minus the ellipsis.
     * @return the abbreviated String, or {@code null} if the string was {@code null}.
     */
    public static String abbreviate(String str, int maxWidth) {
<span class="nc bnc" id="L1069" title="All 2 branches missed.">        if (null == str) {</span>
<span class="nc" id="L1070">            return null;</span>
        }

<span class="nc bnc" id="L1073" title="All 2 branches missed.">        if (str.length() &lt;= maxWidth) {</span>
<span class="nc" id="L1074">            return str;</span>
        }
        
<span class="nc" id="L1077">        return str.substring(0, maxWidth) + &quot;...&quot;;</span>
    }

    /**
     * Returns true if the string passed in is a valid Email address.
     *
     * @param address Email address to test for validity.
     * @return true if the string passed in is a valid email address.
     */
    public static boolean isValidEmailAddress(String address) {
<span class="nc bnc" id="L1087" title="All 2 branches missed.">        if (address == null) {</span>
<span class="nc" id="L1088">            return false;</span>
        }

<span class="nc bnc" id="L1091" title="All 2 branches missed.">        if (!address.contains(&quot;@&quot;)) {</span>
<span class="nc" id="L1092">            return false;</span>
        }

        try {
<span class="nc" id="L1096">            InternetAddress.parse(address);</span>
<span class="nc" id="L1097">            return true;</span>
        }
<span class="nc" id="L1099">        catch (AddressException e) {</span>
<span class="nc" id="L1100">            return false;</span>
        }
    }
    
    /**
     * Returns a valid domain name, possibly as an ACE-encoded IDN 
     * (per &lt;a href=&quot;http://www.ietf.org/rfc/rfc3490.txt&quot;&gt;RFC 3490&lt;/a&gt;).
     * 
     * @param domain Proposed domain name
     * @return The validated domain name, possibly ACE-encoded
     * @throws IllegalArgumentException The given domain name is not valid
     */
    public static String validateDomainName(String domain) {
<span class="pc bpc" id="L1113" title="2 of 4 branches missed.">        if (domain == null || domain.trim().length() == 0) {</span>
<span class="nc" id="L1114">            throw new IllegalArgumentException(&quot;Domain name cannot be null or empty&quot;);</span>
        }
<span class="fc" id="L1116">        String result = IDN.toASCII(domain);</span>
<span class="fc bfc" id="L1117" title="All 2 branches covered.">        if (result.equals(domain)) {</span>
            // no conversion; validate again via USE_STD3_ASCII_RULES
<span class="fc" id="L1119">            IDN.toASCII(domain, IDN.USE_STD3_ASCII_RULES);</span>
        } else {
<span class="fc" id="L1121">            Log.info(MessageFormat.format(&quot;Converted domain name: from '{0}' to '{1}'&quot;,  domain, result));</span>
        }
<span class="fc" id="L1123">        return result;</span>
    }
    
    /**
     * Removes characters likely to enable Cross Site Scripting attacks from the
     * provided input string. The characters that are removed from the input
     * string, if present, are:
     * 
     * &lt;pre&gt;
     * &amp;lt; &amp;gt; &amp;quot; ' % ; ) ( &amp;amp; + -
     * &lt;/pre&gt;
     * 
     * @param input the string to be scrubbed
     * @return Input without certain characters;
     */
    public static String removeXSSCharacters(String input) {
<span class="nc" id="L1139">        final String[] xss = { &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;\&quot;&quot;, &quot;'&quot;, &quot;%&quot;, &quot;;&quot;, &quot;)&quot;, &quot;(&quot;, &quot;&amp;&quot;,</span>
                &quot;+&quot;, &quot;-&quot; };
<span class="nc bnc" id="L1141" title="All 2 branches missed.">        for (int i = 0; i &lt; xss.length; i++) {</span>
<span class="nc" id="L1142">            input = input.replace(xss[i], &quot;&quot;);</span>
        }
<span class="nc" id="L1144">        return input;</span>
    }
    
    /**
     * Returns the UTF-8 bytes for the given String.
     * 
     * @param input The source string
     * @return The UTF-8 encoding for the given string
     * @deprecated Use {@code input.getBytes(StandardCharsets.UTF_8)}
     */
    @Deprecated
    public static byte[] getBytes(String input) {
<span class="nc" id="L1156">        return input.getBytes(StandardCharsets.UTF_8);</span>
    }
    
    /**
     * Returns the UTF-8 String for the given byte array.
     * 
     * @param input The source byte array
     * @return The UTF-8 encoded String for the given byte array
     * @deprecated Use {@code new String(input, StandardCharsets.UTF_8)}
     */
    @Deprecated
    public static String getString(byte[] input) {
<span class="fc" id="L1168">        return new String(input, StandardCharsets.UTF_8);</span>
    }


    /**
     * @param nullableString the string to check
     * @param value          the string to match against
     * @return {@code true} is nullableString is not null and contains the supplied value, otherwise {@code false}
     */
    public static boolean containsIgnoringCase(final String nullableString, final String value) {
<span class="nc bnc" id="L1178" title="All 2 branches missed.">        if (nullableString != null) {</span>
<span class="nc" id="L1179">            return nullableString.toLowerCase().contains(value.toLowerCase());</span>
        } else {
<span class="nc" id="L1181">            return false;</span>
        }
    }

    public static Optional&lt;Integer&gt; parseInteger(final String value) {
<span class="nc bnc" id="L1186" title="All 4 branches missed.">        if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1187">            return Optional.empty();</span>
        }
        try {
<span class="nc" id="L1190">            return Optional.of(Integer.valueOf(value));</span>
<span class="nc" id="L1191">        } catch (final NumberFormatException ignored) {</span>
<span class="nc" id="L1192">            return Optional.empty();</span>
        }
    }

    public static Optional&lt;Long&gt; parseLong(final String value) {
<span class="pc bpc" id="L1197" title="1 of 4 branches missed.">        if (value == null || value.isEmpty()) {</span>
<span class="fc" id="L1198">            return Optional.empty();</span>
        }
        try {
<span class="fc" id="L1201">            return Optional.of(Long.valueOf(value));</span>
<span class="nc" id="L1202">        } catch (final NumberFormatException ignored) {</span>
<span class="nc" id="L1203">            return Optional.empty();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>