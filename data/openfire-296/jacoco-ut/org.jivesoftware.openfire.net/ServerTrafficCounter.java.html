<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ServerTrafficCounter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Core XMPP Server</a> &gt; <a href="index.source.html" class="el_package">org.jivesoftware.openfire.net</a> &gt; <span class="el_source">ServerTrafficCounter.java</span></div><h1>ServerTrafficCounter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2005-2008 Jive Software. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jivesoftware.openfire.net;

import org.jivesoftware.util.LocaleUtils;
import org.jivesoftware.openfire.stats.Statistic;
import org.jivesoftware.openfire.stats.StatisticsManager;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.WritableByteChannel;
import java.util.concurrent.atomic.AtomicLong;

/**
 * A ServerTrafficCounter counts the number of bytes read and written by the server. This
 * includes client-server, server-server, external components and connection managers traffic.
 * Note that traffic is monitored only for entities that are directly connected to the server.
 * However, traffic generated by file transfers is not considered unless files were sent using
 * the in-band method.
 *
 * @author Gaston Dombiak
 */
<span class="nc" id="L40">public class ServerTrafficCounter {</span>

    /**
     * Outgoing server traffic counter.
     */
<span class="nc" id="L45">    private static final AtomicLong outgoingCounter = new AtomicLong(0);</span>
    /**
     * Incoming server traffic counter.
     */
<span class="nc" id="L49">    private static final AtomicLong incomingCounter = new AtomicLong(0);</span>

    private static final String trafficStatGroup = &quot;server_bytes&quot;;
    private static final String incomingStatKey = &quot;server_bytes_in&quot;;
    private static final String outgoingStatKey = &quot;server_bytes_out&quot;;

    /**
     * Creates and adds statistics to statistic manager.
     */
    public static void initStatistics() {
<span class="nc" id="L59">        addReadBytesStat();</span>
<span class="nc" id="L60">        addWrittenBytesStat();</span>
<span class="nc" id="L61">    }</span>

    /**
     * Wraps the specified input stream to count the number of bytes that were read.
     *
     * @param originalStream the input stream to wrap.
     * @return The wrapped input stream over the original stream.
     */
    public static InputStream wrapInputStream(InputStream originalStream) {
<span class="nc" id="L70">        return new InputStreamWrapper(originalStream);</span>
    }

    /**
     * Wraps the specified output stream to count the number of bytes that were written.
     *
     * @param originalStream the output stream to wrap.
     * @return The wrapped output stream over the original stream.
     */
    public static OutputStream wrapOutputStream(OutputStream originalStream) {
<span class="nc" id="L80">        return new OutputStreamWrapper(originalStream);</span>
    }

    /**
     * Wraps the specified readable channel to count the number of bytes that were read.
     *
     * @param originalChannel the readable byte channel to wrap.
     * @return The wrapped readable channel over the original readable channel .
     */
    public static ReadableByteChannel wrapReadableChannel(ReadableByteChannel originalChannel) {
<span class="nc" id="L90">        return new ReadableByteChannelWrapper(originalChannel);</span>
    }

    /**
     * Wraps the specified writable channel to count the number of bytes that were written.
     *
     * @param originalChannel the writable byte channel to wrap.
     * @return The wrapped writable channel over the original writable channel .
     */
    public static WritableByteChannel wrapWritableChannel(WritableByteChannel originalChannel) {
<span class="nc" id="L100">        return new WritableByteChannelWrapper(originalChannel);</span>
    }

    /**
     * Increments the counter of read bytes by delta.
     *
     * @param delta the delta of bytes that were read.
     */
    public static void incrementIncomingCounter(long delta) {
<span class="nc" id="L109">        incomingCounter.getAndAdd(delta);</span>
<span class="nc" id="L110">    }</span>

    /**
     * Increments the counter of written bytes by delta.
     *
     * @param delta the delta of bytes that were written.
     */
    public static void incrementOutgoingCounter(long delta) {
<span class="nc" id="L118">        outgoingCounter.getAndAdd(delta);</span>
<span class="nc" id="L119">    }</span>

    private static void addReadBytesStat() {
        // Register a statistic.
<span class="nc" id="L123">        Statistic statistic = new Statistic() {</span>
            @Override
            public String getName() {
<span class="nc" id="L126">                return LocaleUtils.getLocalizedString(&quot;server_bytes.stats.incoming.name&quot;);</span>
            }

            @Override
            public Type getStatType() {
<span class="nc" id="L131">                return Type.rate;</span>
            }

            @Override
            public String getDescription() {
<span class="nc" id="L136">                return LocaleUtils.getLocalizedString(&quot;server_bytes.stats.incoming.description&quot;);</span>
            }

            @Override
            public String getUnits() {
<span class="nc" id="L141">                return LocaleUtils.getLocalizedString(&quot;server_bytes.stats.incoming.label&quot;);</span>
            }

            @Override
            public double sample() {
                // Divide result by 1024 so that we return the result in Kb.
<span class="nc" id="L147">                return incomingCounter.getAndSet(0)/1024d;</span>
            }

            @Override
            public boolean isPartialSample() {
<span class="nc" id="L152">                return true;</span>
            }
        };
<span class="nc" id="L155">        StatisticsManager.getInstance()</span>
<span class="nc" id="L156">                .addMultiStatistic(incomingStatKey, trafficStatGroup, statistic);</span>
<span class="nc" id="L157">    }</span>

    private static void addWrittenBytesStat() {
        // Register a statistic.
<span class="nc" id="L161">        Statistic statistic = new Statistic() {</span>
            @Override
            public String getName() {
<span class="nc" id="L164">                return LocaleUtils.getLocalizedString(&quot;server_bytes.stats.outgoing.name&quot;);</span>
            }

            @Override
            public Type getStatType() {
<span class="nc" id="L169">                return Type.rate;</span>
            }

            @Override
            public String getDescription() {
<span class="nc" id="L174">                return LocaleUtils.getLocalizedString(&quot;server_bytes.stats.outgoing.description&quot;);</span>
            }

            @Override
            public String getUnits() {
<span class="nc" id="L179">                return LocaleUtils.getLocalizedString(&quot;server_bytes.stats.outgoing.label&quot;);</span>
            }

            @Override
            public double sample() {
<span class="nc" id="L184">                return outgoingCounter.getAndSet(0)/1024d;</span>
            }

            @Override
            public boolean isPartialSample() {
<span class="nc" id="L189">                return true;</span>
            }
        };
<span class="nc" id="L192">        StatisticsManager.getInstance()</span>
<span class="nc" id="L193">                .addMultiStatistic(outgoingStatKey, trafficStatGroup, statistic);</span>
<span class="nc" id="L194">    }</span>

    /**
     * Wrapper on an input stream to intercept and count number of read bytes.
     */
    private static class InputStreamWrapper extends InputStream {
        /**
         * Original input stream being wrapped to count incmoing traffic.
         */
        private InputStream originalStream;

<span class="nc" id="L205">        public InputStreamWrapper(InputStream originalStream) {</span>
<span class="nc" id="L206">            this.originalStream = originalStream;</span>
<span class="nc" id="L207">        }</span>

        @Override
        public int read() throws IOException {
<span class="nc" id="L211">            int readByte = originalStream.read();</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            if (readByte &gt; -1) {</span>
<span class="nc" id="L213">                incrementIncomingCounter(1);</span>
            }
<span class="nc" id="L215">            return readByte;</span>
        }

        @Override
        public int read(byte b[]) throws IOException {
<span class="nc" id="L220">            int bytes = originalStream.read(b);</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">            if (bytes &gt; -1) {</span>
<span class="nc" id="L222">                incrementIncomingCounter(bytes);</span>
            }
<span class="nc" id="L224">            return bytes;</span>
        }

        @Override
        public int read(byte b[], int off, int len) throws IOException {
<span class="nc" id="L229">            int bytes = originalStream.read(b, off, len);</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (bytes &gt; -1) {</span>
<span class="nc" id="L231">                incrementIncomingCounter(bytes);</span>
            }
<span class="nc" id="L233">            return bytes;</span>
        }

        @Override
        public int available() throws IOException {
<span class="nc" id="L238">            return originalStream.available();</span>
        }

        @Override
        public void close() throws IOException {
<span class="nc" id="L243">            originalStream.close();</span>
<span class="nc" id="L244">        }</span>

        @Override
        public synchronized void mark(int readlimit) {
<span class="nc" id="L248">            originalStream.mark(readlimit);</span>
<span class="nc" id="L249">        }</span>

        @Override
        public boolean markSupported() {
<span class="nc" id="L253">            return originalStream.markSupported();</span>
        }

        @Override
        public synchronized void reset() throws IOException {
<span class="nc" id="L258">            originalStream.reset();</span>
<span class="nc" id="L259">        }</span>

        @Override
        public long skip(long n) throws IOException {
<span class="nc" id="L263">            return originalStream.skip(n);</span>
        }
    }

    /**
     * Wrapper on an output stream to intercept and count number of written bytes.
     */
    private static class OutputStreamWrapper extends OutputStream {
        /**
         * Original output stream being wrapped to count outgoing traffic.
         */
        private OutputStream originalStream;

<span class="nc" id="L276">        public OutputStreamWrapper(OutputStream originalStream) {</span>
<span class="nc" id="L277">            this.originalStream = originalStream;</span>
<span class="nc" id="L278">        }</span>

        @Override
        public void write(int b) throws IOException {
            // forward request to wrapped stream
<span class="nc" id="L283">            originalStream.write(b);</span>
            // update outgoingCounter
<span class="nc" id="L285">            incrementOutgoingCounter(1);</span>
<span class="nc" id="L286">        }</span>

        @Override
        public void write(byte b[]) throws IOException {
            // forward request to wrapped stream
<span class="nc" id="L291">            originalStream.write(b);</span>
            // update outgoingCounter
<span class="nc" id="L293">            incrementOutgoingCounter(b.length);</span>
<span class="nc" id="L294">        }</span>

        @Override
        public void write(byte b[], int off, int len) throws IOException {
            // forward request to wrapped stream
<span class="nc" id="L299">            originalStream.write(b, off, len);</span>
            // update outgoingCounter
<span class="nc" id="L301">            incrementOutgoingCounter(b.length);</span>
<span class="nc" id="L302">        }</span>

        @Override
        public void close() throws IOException {
<span class="nc" id="L306">            originalStream.close();</span>
<span class="nc" id="L307">        }</span>

        @Override
        public void flush() throws IOException {
<span class="nc" id="L311">            originalStream.flush();</span>
<span class="nc" id="L312">        }</span>
    }

    /**
     * Wrapper on a ReadableByteChannel to intercept and count number of read bytes.
     */
    private static class ReadableByteChannelWrapper implements ReadableByteChannel {
        private ReadableByteChannel originalChannel;

<span class="nc" id="L321">        public ReadableByteChannelWrapper(ReadableByteChannel originalChannel) {</span>
<span class="nc" id="L322">            this.originalChannel = originalChannel;</span>
<span class="nc" id="L323">        }</span>

        @Override
        public int read(ByteBuffer dst) throws IOException {
<span class="nc" id="L327">            int bytes = originalChannel.read(dst);</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">            if (bytes &gt; -1) {</span>
<span class="nc" id="L329">                incrementIncomingCounter(bytes);</span>
            }
<span class="nc" id="L331">            return bytes;</span>
        }

        @Override
        public void close() throws IOException {
<span class="nc" id="L336">            originalChannel.close();</span>
<span class="nc" id="L337">        }</span>

        @Override
        public boolean isOpen() {
<span class="nc" id="L341">            return originalChannel.isOpen();</span>
        }
    }

    /**
     * Wrapper on a WritableByteChannel to intercept and count number of written bytes.
     */
    private static class WritableByteChannelWrapper implements WritableByteChannel {
        private WritableByteChannel originalChannel;

<span class="nc" id="L351">        public WritableByteChannelWrapper(WritableByteChannel originalChannel) {</span>
<span class="nc" id="L352">            this.originalChannel = originalChannel;</span>
<span class="nc" id="L353">        }</span>

        @Override
        public void close() throws IOException {
<span class="nc" id="L357">            originalChannel.close();</span>
<span class="nc" id="L358">        }</span>

        @Override
        public boolean isOpen() {
<span class="nc" id="L362">            return originalChannel.isOpen();</span>
        }

        @Override
        public int write(ByteBuffer src) throws IOException {
<span class="nc" id="L367">            int bytes = originalChannel.write(src);</span>
<span class="nc" id="L368">            incrementOutgoingCounter(bytes);</span>
<span class="nc" id="L369">            return bytes;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>