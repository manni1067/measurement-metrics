<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>HttpBindManager.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Core XMPP Server</a> &gt; <a href="index.source.html" class="el_package">org.jivesoftware.openfire.http</a> &gt; <span class="el_source">HttpBindManager.java</span></div><h1>HttpBindManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2005-2008 Jive Software. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jivesoftware.openfire.http;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.jasper.servlet.JasperInitializer;
import org.apache.tomcat.InstanceManager;
import org.apache.tomcat.SimpleInstanceManager;
import org.eclipse.jetty.http.HttpMethod;
import org.eclipse.jetty.plus.annotation.ContainerInitializer;
import org.eclipse.jetty.server.Connector;
import org.eclipse.jetty.server.ForwardedRequestCustomizer;
import org.eclipse.jetty.server.Handler;
import org.eclipse.jetty.server.HttpConfiguration;
import org.eclipse.jetty.server.HttpConnectionFactory;
import org.eclipse.jetty.server.SecureRequestCustomizer;
import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.server.ServerConnector;
import org.eclipse.jetty.server.SslConnectionFactory;
import org.eclipse.jetty.server.handler.HandlerCollection;
import org.eclipse.jetty.server.handler.HandlerList;
import org.eclipse.jetty.server.handler.gzip.GzipHandler;
import org.eclipse.jetty.servlet.ServletContextHandler;
import org.eclipse.jetty.servlet.ServletHolder;
import org.eclipse.jetty.util.WebAppLoaderFix;
import org.eclipse.jetty.util.ssl.SslContextFactory;
import org.eclipse.jetty.util.thread.QueuedThreadPool;
import org.eclipse.jetty.webapp.WebAppContext;
import org.jivesoftware.openfire.Connection;
import org.jivesoftware.openfire.JMXManager;
import org.jivesoftware.openfire.XMPPServer;
import org.jivesoftware.openfire.keystore.CertificateStore;
import org.jivesoftware.openfire.keystore.IdentityStore;
import org.jivesoftware.openfire.spi.ConnectionConfiguration;
import org.jivesoftware.openfire.spi.ConnectionManagerImpl;
import org.jivesoftware.openfire.spi.ConnectionType;
import org.jivesoftware.openfire.spi.EncryptionArtifactFactory;
import org.jivesoftware.openfire.websocket.OpenfireWebSocketServlet;
import org.jivesoftware.util.CertificateEventListener;
import org.jivesoftware.util.CertificateManager;
import org.jivesoftware.util.JiveConstants;
import org.jivesoftware.util.JiveGlobals;
import org.jivesoftware.util.PropertyEventDispatcher;
import org.jivesoftware.util.PropertyEventListener;
import org.jivesoftware.util.TaskEngine;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Responsible for making available BOSH (functionality to the outside world, using an embedded web server.
 */
public final class HttpBindManager implements CertificateEventListener, PropertyEventListener {

<span class="nc" id="L73">    private static final Logger Log = LoggerFactory.getLogger(HttpBindManager.class);</span>

    public static final String HTTP_BIND_ENABLED = &quot;httpbind.enabled&quot;;

    public static final boolean HTTP_BIND_ENABLED_DEFAULT = true;

    public static final String HTTP_BIND_PORT = &quot;httpbind.port.plain&quot;;

    public static final int HTTP_BIND_PORT_DEFAULT = 7070;

    public static final String HTTP_BIND_SECURE_PORT = &quot;httpbind.port.secure&quot;;

    public static final int HTTP_BIND_SECURE_PORT_DEFAULT = 7443;

    public static final String HTTP_BIND_THREADS = &quot;httpbind.client.processing.threads&quot;;

    public static final String HTTP_BIND_AUTH_PER_CLIENTCERT_POLICY = &quot;httpbind.client.cert.policy&quot;;

    public static final int HTTP_BIND_THREADS_DEFAULT = 200;

    private static final String HTTP_BIND_FORWARDED = &quot;httpbind.forwarded.enabled&quot;;

    private static final String HTTP_BIND_FORWARDED_FOR = &quot;httpbind.forwarded.for.header&quot;;

    private static final String HTTP_BIND_FORWARDED_SERVER = &quot;httpbind.forwarded.server.header&quot;;

    private static final String HTTP_BIND_FORWARDED_HOST = &quot;httpbind.forwarded.host.header&quot;;

    private static final String HTTP_BIND_FORWARDED_HOST_NAME = &quot;httpbind.forwarded.host.name&quot;;

    // http binding CORS default properties

    public static final String HTTP_BIND_CORS_ENABLED = &quot;httpbind.CORS.enabled&quot;;

    public static final boolean HTTP_BIND_CORS_ENABLED_DEFAULT = true;

    public static final String HTTP_BIND_CORS_ALLOW_ORIGIN = &quot;httpbind.CORS.domains&quot;;

    public static final String HTTP_BIND_CORS_ALLOW_ORIGIN_DEFAULT = &quot;*&quot;;

    public static final String HTTP_BIND_CORS_ALLOW_METHODS_DEFAULT = &quot;PROPFIND, PROPPATCH, COPY, MOVE, DELETE, MKCOL, LOCK, UNLOCK, PUT, GETLIB, VERSION-CONTROL, CHECKIN, CHECKOUT, UNCHECKOUT, REPORT, UPDATE, CANCELUPLOAD, HEAD, OPTIONS, GET, POST&quot;;

    public static final String HTTP_BIND_CORS_ALLOW_HEADERS_DEFAULT = &quot;Overwrite, Destination, Content-Type, Depth, User-Agent, X-File-Size, X-Requested-With, If-Modified-Since, X-File-Name, Cache-Control&quot;;

    public static final String HTTP_BIND_CORS_MAX_AGE_DEFAULT = &quot;86400&quot;;

    public static final String HTTP_BIND_REQUEST_HEADER_SIZE = &quot;httpbind.request.header.size&quot;;

    public static final int HTTP_BIND_REQUEST_HEADER_SIZE_DEFAULT = 32768;

<span class="nc" id="L123">    public static Map&lt;String, Boolean&gt; HTTP_BIND_ALLOWED_ORIGINS = new HashMap&lt;&gt;();</span>

<span class="nc" id="L125">    private static HttpBindManager instance = new HttpBindManager();</span>

    private Server httpBindServer;

    private final HttpSessionManager httpSessionManager;

    /**
     * An ordered collection of all handlers (that is created to include the #extensionHandlers).
     *
     * A reference to this collection is maintained outside of the Jetty server implementation ({@link #httpBindServer})
     * as its lifecycle differs from that server: the server is recreated upon configuration changes, while the
     * collection of handlers need not be.
     *
     * This collection is ordered, which ensures that:
     * &lt;ul&gt;
     *     &lt;li&gt;The handlers providing BOSH functionality are tried first.&lt;/li&gt;
     *     &lt;li&gt;Any handlers that are registered by external sources ({@link #extensionHandlers}) are tried in between.&lt;/li&gt;
     *     &lt;li&gt;The 'catch-all' handler that maps to static content is tried last.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * This collection should be regarded as immutable. When handlers are to be added/removed dynamically, this should
     * occur in {@link #extensionHandlers}, to which a reference is stored in this list by the constructor of this class.
     */
<span class="nc" id="L148">    private final HandlerList handlerList = new HandlerList();</span>

    /**
     * Contains all Jetty handlers that are added as an extension.
     *
     * This collection is mutable. Handlers can be added and removed at runtime.
     */
<span class="nc" id="L155">    private final HandlerCollection extensionHandlers = new HandlerCollection( true );</span>

    /**
     * A task that, periodically, updates the 'last modified' date of all files in the Jetty 'tmp' directories. This
     * prevents operating systems from removing files that are deemed unused.
     *
     * @see &lt;a href=&quot;https://issues.igniterealtime.org/browse/OF-1534&quot;&gt;OF-1534&lt;/a&gt;
     */
    private TempFileToucherTask tempFileToucherTask;

    public static HttpBindManager getInstance() {
<span class="nc" id="L166">        return instance;</span>
    }

<span class="nc" id="L169">    private HttpBindManager() {</span>
<span class="nc" id="L170">        JiveGlobals.migrateProperty(HTTP_BIND_ENABLED);</span>
<span class="nc" id="L171">        JiveGlobals.migrateProperty(HTTP_BIND_PORT);</span>
<span class="nc" id="L172">        JiveGlobals.migrateProperty(HTTP_BIND_SECURE_PORT);</span>
<span class="nc" id="L173">        JiveGlobals.migrateProperty(HTTP_BIND_THREADS);</span>
<span class="nc" id="L174">        JiveGlobals.migrateProperty(HTTP_BIND_FORWARDED);</span>
<span class="nc" id="L175">        JiveGlobals.migrateProperty(HTTP_BIND_FORWARDED_FOR);</span>
<span class="nc" id="L176">        JiveGlobals.migrateProperty(HTTP_BIND_FORWARDED_SERVER);</span>
<span class="nc" id="L177">        JiveGlobals.migrateProperty(HTTP_BIND_FORWARDED_HOST);</span>
<span class="nc" id="L178">        JiveGlobals.migrateProperty(HTTP_BIND_FORWARDED_HOST_NAME);</span>
<span class="nc" id="L179">        JiveGlobals.migrateProperty(HTTP_BIND_CORS_ENABLED);</span>
<span class="nc" id="L180">        JiveGlobals.migrateProperty(HTTP_BIND_CORS_ALLOW_ORIGIN);</span>
<span class="nc" id="L181">        JiveGlobals.migrateProperty(HTTP_BIND_REQUEST_HEADER_SIZE);</span>

<span class="nc" id="L183">        PropertyEventDispatcher.addListener( this );</span>
<span class="nc" id="L184">        this.httpSessionManager = new HttpSessionManager();</span>

        // setup the cache for the allowed origins
<span class="nc" id="L187">        this.setupAllowedOriginsMap();</span>

        // Setup the default handlers. Order is important here. First, evaluate if the 'standard' handlers can be used to fulfill requests.
<span class="nc" id="L190">        this.handlerList.addHandler( createBoshHandler() );</span>
<span class="nc" id="L191">        this.handlerList.addHandler( createWebsocketHandler() );</span>
<span class="nc" id="L192">        this.handlerList.addHandler( createCrossDomainHandler() );</span>

        // When standard handling does not apply, see if any of the handlers in the extension pool of handlers applies to the request.
<span class="nc" id="L195">        this.handlerList.addHandler( this.extensionHandlers );</span>

        // When everything else fails, use the static content handler. This one should be last, as it is mapping to the root context.
        // This means that it will catch everything and prevent the invocation of later handlers.
<span class="nc" id="L199">        final Handler staticContentHandler = createStaticContentHandler();</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">        if ( staticContentHandler != null )</span>
        {
<span class="nc" id="L202">            this.handlerList.addHandler( staticContentHandler );</span>
        }
<span class="nc" id="L204">    }</span>

    public void start() {

<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (!isHttpBindServiceEnabled()) {</span>
<span class="nc" id="L209">            return;</span>
        }

        // this is the number of threads allocated to each connector/port
<span class="nc" id="L213">        final int processingThreads = JiveGlobals.getIntProperty(HTTP_BIND_THREADS, HTTP_BIND_THREADS_DEFAULT);</span>

<span class="nc" id="L215">        final QueuedThreadPool tp = new QueuedThreadPool(processingThreads);</span>
<span class="nc" id="L216">        tp.setName(&quot;Jetty-QTP-BOSH&quot;);</span>

<span class="nc" id="L218">        httpBindServer = new Server(tp);</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">        if (JMXManager.isEnabled()) {</span>
<span class="nc" id="L220">            JMXManager jmx = JMXManager.getInstance();</span>
<span class="nc" id="L221">            httpBindServer.addBean(jmx.getContainer());</span>
        }

<span class="nc" id="L224">        final Connector httpConnector = createConnector( httpBindServer );</span>
<span class="nc" id="L225">        final Connector httpsConnector = createSSLConnector( httpBindServer);</span>

<span class="nc bnc" id="L227" title="All 4 branches missed.">        if (httpConnector == null &amp;&amp; httpsConnector == null) {</span>
<span class="nc" id="L228">            httpBindServer = null;</span>
<span class="nc" id="L229">            return;</span>
        }
<span class="nc bnc" id="L231" title="All 2 branches missed.">        if (httpConnector != null) {</span>
<span class="nc" id="L232">            httpBindServer.addConnector(httpConnector);</span>
        }
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (httpsConnector != null) {</span>
<span class="nc" id="L235">            httpBindServer.addConnector(httpsConnector);</span>
        }

<span class="nc" id="L238">        httpBindServer.setHandler( handlerList );</span>

        try {
<span class="nc" id="L241">            httpBindServer.start();</span>
<span class="nc" id="L242">            handlerList.start();</span>
<span class="nc" id="L243">            extensionHandlers.start();</span>

<span class="nc" id="L245">            CertificateManager.addListener(this);</span>

<span class="nc" id="L247">            Log.info(&quot;HTTP bind service started&quot;);</span>
        }
<span class="nc" id="L249">        catch (Exception e) {</span>
<span class="nc" id="L250">            Log.error(&quot;Error starting HTTP bind service&quot;, e);</span>
<span class="nc" id="L251">        }</span>

<span class="nc bnc" id="L253" title="All 2 branches missed.">        if ( JiveGlobals.getBooleanProperty( &quot;jetty.temp-file-toucher.enabled&quot;, true ) ) {</span>
<span class="nc" id="L254">            tempFileToucherTask = new TempFileToucherTask( httpBindServer );</span>
<span class="nc" id="L255">            final long period = JiveGlobals.getLongProperty( &quot;jetty.temp-file-toucher.period&quot;, JiveConstants.DAY );</span>
<span class="nc" id="L256">            TaskEngine.getInstance().schedule( tempFileToucherTask, period, period );</span>
        }
<span class="nc" id="L258">    }</span>

    public void stop() {
<span class="nc" id="L261">        CertificateManager.removeListener(this);</span>

<span class="nc bnc" id="L263" title="All 2 branches missed.">        if ( tempFileToucherTask != null ) {</span>
<span class="nc" id="L264">            TaskEngine.getInstance().cancelScheduledTask( tempFileToucherTask );</span>
<span class="nc" id="L265">            tempFileToucherTask = null;</span>
        }

<span class="nc bnc" id="L268" title="All 2 branches missed.">        if (httpBindServer != null) {</span>
            try {
<span class="nc" id="L270">                handlerList.stop();</span>
<span class="nc" id="L271">                extensionHandlers.stop();</span>
<span class="nc" id="L272">                httpBindServer.stop();</span>
<span class="nc" id="L273">                Log.info(&quot;HTTP bind service stopped&quot;);</span>
            }
<span class="nc" id="L275">            catch (Exception e) {</span>
<span class="nc" id="L276">                Log.error(&quot;Error stopping HTTP bind service&quot;, e);</span>
<span class="nc" id="L277">            }</span>
<span class="nc" id="L278">            httpBindServer = null;</span>
        }
<span class="nc" id="L280">    }</span>

    public HttpSessionManager getSessionManager() {
<span class="nc" id="L283">        return httpSessionManager;</span>
    }

    private boolean isHttpBindServiceEnabled() {
<span class="nc" id="L287">        return JiveGlobals.getBooleanProperty(HTTP_BIND_ENABLED, HTTP_BIND_ENABLED_DEFAULT);</span>
    }

    private Connector createConnector( final Server httpBindServer ) {
<span class="nc" id="L291">        final int port = getHttpBindUnsecurePort();</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (port &gt; 0) {</span>
<span class="nc" id="L293">            HttpConfiguration httpConfig = new HttpConfiguration();</span>
<span class="nc" id="L294">            configureProxiedConnector(httpConfig);</span>
<span class="nc" id="L295">            ServerConnector connector = new ServerConnector(httpBindServer, new HttpConnectionFactory(httpConfig));</span>

            // Listen on a specific network interface if it has been set.
<span class="nc" id="L298">            connector.setHost(getBindInterface());</span>
<span class="nc" id="L299">            connector.setPort(port);</span>
<span class="nc" id="L300">            return connector;</span>
        }
        else
        {
<span class="nc" id="L304">            return null;</span>
        }
    }

    private Connector createSSLConnector( final Server httpBindServer ) {
<span class="nc" id="L309">        final int securePort = getHttpBindSecurePort();</span>
        try {
<span class="nc" id="L311">            final IdentityStore identityStore = XMPPServer.getInstance().getCertificateStoreManager().getIdentityStore( ConnectionType.BOSH_C2S );</span>

<span class="nc bnc" id="L313" title="All 4 branches missed.">            if (securePort &gt; 0 &amp;&amp; identityStore.getStore().aliases().hasMoreElements() ) {</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">                if ( !identityStore.containsDomainCertificate( ) ) {</span>
<span class="nc" id="L315">                    Log.warn(&quot;HTTP binding: Using certificates but they are not valid for the hosted domain&quot;);</span>
                }

<span class="nc" id="L318">                final ConnectionManagerImpl connectionManager = ((ConnectionManagerImpl) XMPPServer.getInstance().getConnectionManager());</span>
<span class="nc" id="L319">                final ConnectionConfiguration configuration = connectionManager.getListener( ConnectionType.BOSH_C2S, true ).generateConnectionConfiguration();</span>
<span class="nc" id="L320">                final SslContextFactory sslContextFactory = new EncryptionArtifactFactory(configuration).getSslContextFactory();</span>

<span class="nc" id="L322">                final HttpConfiguration httpsConfig = new HttpConfiguration();</span>
<span class="nc" id="L323">                httpsConfig.setSecureScheme(&quot;https&quot;);</span>
<span class="nc" id="L324">                httpsConfig.setSecurePort(securePort);</span>
<span class="nc" id="L325">                configureProxiedConnector(httpsConfig);</span>
<span class="nc" id="L326">                httpsConfig.addCustomizer(new SecureRequestCustomizer());</span>

<span class="nc" id="L328">                final ServerConnector sslConnector = new ServerConnector(httpBindServer, new SslConnectionFactory(sslContextFactory, &quot;http/1.1&quot;), new HttpConnectionFactory(httpsConfig));</span>
<span class="nc" id="L329">                sslConnector.setHost(getBindInterface());</span>
<span class="nc" id="L330">                sslConnector.setPort(securePort);</span>
<span class="nc" id="L331">                return sslConnector;</span>
            }
        }
<span class="nc" id="L334">        catch (Exception e) {</span>
<span class="nc" id="L335">            Log.error(&quot;Error creating SSL connector for Http bind&quot;, e);</span>
<span class="nc" id="L336">        }</span>

<span class="nc" id="L338">        return null;</span>
    }

    private void configureProxiedConnector(HttpConfiguration httpConfig) {
        // Check to see if we are deployed behind a proxy
        // Refer to http://eclipse.org/jetty/documentation/current/configuring-connectors.html
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (isXFFEnabled()) {</span>
<span class="nc" id="L345">            ForwardedRequestCustomizer customizer = new ForwardedRequestCustomizer();</span>
            // default: &quot;X-Forwarded-For&quot;
<span class="nc" id="L347">            String forwardedForHeader = getXFFHeader();</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">            if (forwardedForHeader != null) {</span>
<span class="nc" id="L349">                customizer.setForwardedForHeader(forwardedForHeader);</span>
            }
            // default: &quot;X-Forwarded-Server&quot;
<span class="nc" id="L352">            String forwardedServerHeader = getXFFServerHeader();</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">            if (forwardedServerHeader != null) {</span>
<span class="nc" id="L354">                customizer.setForwardedServerHeader(forwardedServerHeader);</span>
            }
            // default: &quot;X-Forwarded-Host&quot;
<span class="nc" id="L357">            String forwardedHostHeader = getXFFHostHeader();</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">            if (forwardedHostHeader != null) {</span>
<span class="nc" id="L359">                customizer.setForwardedHostHeader(forwardedHostHeader);</span>
            }
            // default: none
<span class="nc" id="L362">            String hostName = getXFFHostName();</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">            if (hostName != null) {</span>
<span class="nc" id="L364">                customizer.setHostHeader(hostName);</span>
            }

<span class="nc" id="L367">            httpConfig.addCustomizer(customizer);</span>
        }
<span class="nc" id="L369">        httpConfig.setRequestHeaderSize(JiveGlobals.getIntProperty(HTTP_BIND_REQUEST_HEADER_SIZE, HTTP_BIND_REQUEST_HEADER_SIZE_DEFAULT));</span>
<span class="nc" id="L370">   }</span>

    private String getBindInterface() {
<span class="nc" id="L373">        String interfaceName = JiveGlobals.getXMLProperty(&quot;network.interface&quot;);</span>
<span class="nc" id="L374">        String bindInterface = null;</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">        if (interfaceName != null) {</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">            if (interfaceName.trim().length() &gt; 0) {</span>
<span class="nc" id="L377">                bindInterface = interfaceName;</span>
            }
        }
<span class="nc" id="L380">        return bindInterface;</span>
    }

    /**
     * Returns true if the HTTP binding server is currently enabled.
     *
     * @return true if the HTTP binding server is currently enabled.
     */
    public boolean isHttpBindEnabled() {
<span class="nc bnc" id="L389" title="All 4 branches missed.">        return httpBindServer != null &amp;&amp; httpBindServer.isRunning();</span>
    }

    /**
     * Returns true if a listener on the HTTP binding port is running.
     *
     * @return true if a listener on the HTTP binding port is running.
     */
    public boolean isHttpBindActive()
    {
<span class="nc bnc" id="L399" title="All 2 branches missed.">        if ( isHttpBindEnabled() )</span>
        {
<span class="nc" id="L401">            final int configuredPort = getHttpBindUnsecurePort();</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">            for ( final Connector connector : httpBindServer.getConnectors() )</span>
            {
<span class="nc bnc" id="L404" title="All 2 branches missed.">                if ( !( connector instanceof ServerConnector ) )</span>
                {
<span class="nc" id="L406">                    continue;</span>
                }
<span class="nc" id="L408">                final int activePort = ( (ServerConnector) connector ).getLocalPort();</span>

<span class="nc bnc" id="L410" title="All 2 branches missed.">                if ( activePort == configuredPort )</span>
                {
<span class="nc" id="L412">                    return true;</span>
                }
            }
        }
<span class="nc" id="L416">        return false;</span>
    }

    /**
     * Returns true if a listener on the HTTPS binding port is running.
     *
     * @return true if a listener on the HTTPS binding port is running.
     */
    public boolean isHttpsBindActive()
    {
<span class="nc bnc" id="L426" title="All 2 branches missed.">        if ( isHttpBindEnabled() )</span>
        {
<span class="nc" id="L428">            final int configuredPort = getHttpBindSecurePort();</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">            for ( final Connector connector : httpBindServer.getConnectors() )</span>
            {
<span class="nc bnc" id="L431" title="All 2 branches missed.">                if ( !( connector instanceof ServerConnector ) )</span>
                {
<span class="nc" id="L433">                    continue;</span>
                }
<span class="nc" id="L435">                final int activePort = ( (ServerConnector) connector ).getLocalPort();</span>

<span class="nc bnc" id="L437" title="All 2 branches missed.">                if ( activePort == configuredPort )</span>
                {
<span class="nc" id="L439">                    return true;</span>
                }
            }
        }
<span class="nc" id="L443">        return false;</span>
    }

    public String getHttpBindUnsecureAddress() {
<span class="nc" id="L447">        return &quot;http://&quot; + XMPPServer.getInstance().getServerInfo().getHostname() + &quot;:&quot; + getHttpBindUnsecurePort() + &quot;/http-bind/&quot;;</span>
    }

    public String getHttpBindSecureAddress() {
<span class="nc" id="L451">        return &quot;https://&quot; + XMPPServer.getInstance().getServerInfo().getHostname() + &quot;:&quot; + getHttpBindSecurePort() + &quot;/http-bind/&quot;;</span>
    }

    public String getJavaScriptUrl() {
<span class="nc" id="L455">        return &quot;http://&quot; + XMPPServer.getInstance().getServerInfo().getHostname() + &quot;:&quot; + getHttpBindUnsecurePort() + &quot;/scripts/&quot;;</span>
    }

    // http binding CORS support start

    private void setupAllowedOriginsMap() {
<span class="nc" id="L461">        final String originString = getCORSAllowOrigin();</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">        if (!originString.equals(HTTP_BIND_CORS_ALLOW_ORIGIN_DEFAULT)) {</span>
<span class="nc" id="L463">            String[] origins = originString.split(&quot;,&quot;);</span>
            // reset the cache
<span class="nc" id="L465">            HTTP_BIND_ALLOWED_ORIGINS.clear();</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">            for (String str : origins) {</span>
<span class="nc" id="L467">                HTTP_BIND_ALLOWED_ORIGINS.put(str, true);</span>
            }
        }
<span class="nc" id="L470">    }</span>

    public boolean isCORSEnabled() {
<span class="nc" id="L473">        return JiveGlobals.getBooleanProperty(HTTP_BIND_CORS_ENABLED, HTTP_BIND_CORS_ENABLED_DEFAULT);</span>
    }

    public void setCORSEnabled(Boolean value) {
<span class="nc bnc" id="L477" title="All 2 branches missed.">        if (value != null)</span>
<span class="nc" id="L478">            JiveGlobals.setProperty(HTTP_BIND_CORS_ENABLED, String.valueOf(value));</span>
<span class="nc" id="L479">    }</span>

    public String getCORSAllowOrigin() {
<span class="nc" id="L482">        return JiveGlobals.getProperty(HTTP_BIND_CORS_ALLOW_ORIGIN , HTTP_BIND_CORS_ALLOW_ORIGIN_DEFAULT);</span>
    }

    public void setCORSAllowOrigin(String origins) {
<span class="nc bnc" id="L486" title="All 4 branches missed.">        if (origins == null || origins.trim().length() == 0)</span>
<span class="nc" id="L487">             origins = HTTP_BIND_CORS_ALLOW_ORIGIN_DEFAULT;</span>
        else {
<span class="nc" id="L489">            origins = origins.replaceAll(&quot;\\s+&quot;, &quot;&quot;);</span>
        }
<span class="nc" id="L491">        JiveGlobals.setProperty(HTTP_BIND_CORS_ALLOW_ORIGIN, origins);</span>
<span class="nc" id="L492">        setupAllowedOriginsMap();</span>
<span class="nc" id="L493">    }</span>

    public boolean isAllOriginsAllowed() {
<span class="nc" id="L496">        return HTTP_BIND_CORS_ALLOW_ORIGIN_DEFAULT.equals( getCORSAllowOrigin() );</span>
    }

    public boolean isThisOriginAllowed(String origin) {
<span class="nc bnc" id="L500" title="All 4 branches missed.">        return isAllOriginsAllowed() || HTTP_BIND_ALLOWED_ORIGINS.get(origin) != null;</span>
    }

    // http binding CORS support end

    public boolean isXFFEnabled() {
<span class="nc" id="L506">        return JiveGlobals.getBooleanProperty(HTTP_BIND_FORWARDED, false);</span>
    }

    public void setXFFEnabled(boolean enabled) {
<span class="nc" id="L510">        JiveGlobals.setProperty(HTTP_BIND_FORWARDED, String.valueOf(enabled));</span>
<span class="nc" id="L511">    }</span>

    public String getXFFHeader() {
<span class="nc" id="L514">        return JiveGlobals.getProperty(HTTP_BIND_FORWARDED_FOR);</span>
    }

    public void setXFFHeader(String header) {
<span class="nc bnc" id="L518" title="All 4 branches missed.">        if (header == null || header.trim().length() == 0) {</span>
<span class="nc" id="L519">            JiveGlobals.deleteProperty(HTTP_BIND_FORWARDED_FOR);</span>
        } else {
<span class="nc" id="L521">            JiveGlobals.setProperty(HTTP_BIND_FORWARDED_FOR, header);</span>
        }
<span class="nc" id="L523">    }</span>

    public String getXFFServerHeader() {
<span class="nc" id="L526">        return JiveGlobals.getProperty(HTTP_BIND_FORWARDED_SERVER);</span>
    }

    public void setXFFServerHeader(String header) {
<span class="nc bnc" id="L530" title="All 4 branches missed.">        if (header == null || header.trim().length() == 0) {</span>
<span class="nc" id="L531">            JiveGlobals.deleteProperty(HTTP_BIND_FORWARDED_SERVER);</span>
        } else {
<span class="nc" id="L533">            JiveGlobals.setProperty(HTTP_BIND_FORWARDED_SERVER, header);</span>
        }
<span class="nc" id="L535">    }</span>

    public String getXFFHostHeader() {
<span class="nc" id="L538">        return JiveGlobals.getProperty(HTTP_BIND_FORWARDED_HOST);</span>
    }

    public void setXFFHostHeader(String header) {
<span class="nc bnc" id="L542" title="All 4 branches missed.">        if (header == null || header.trim().length() == 0) {</span>
<span class="nc" id="L543">            JiveGlobals.deleteProperty(HTTP_BIND_FORWARDED_HOST);</span>
        } else {
<span class="nc" id="L545">            JiveGlobals.setProperty(HTTP_BIND_FORWARDED_HOST, header);</span>
        }
<span class="nc" id="L547">    }</span>

    public String getXFFHostName() {
<span class="nc" id="L550">        return JiveGlobals.getProperty(HTTP_BIND_FORWARDED_HOST_NAME);</span>
    }

    public void setXFFHostName(String name) {
<span class="nc bnc" id="L554" title="All 4 branches missed.">        if (name == null || name.trim().length() == 0) {</span>
<span class="nc" id="L555">            JiveGlobals.deleteProperty(HTTP_BIND_FORWARDED_HOST_NAME);</span>
        } else {
<span class="nc" id="L557">            JiveGlobals.setProperty(HTTP_BIND_FORWARDED_HOST_NAME, name);</span>
        }
<span class="nc" id="L559">    }</span>

    public void setHttpBindEnabled(boolean isEnabled) {
<span class="nc" id="L562">        JiveGlobals.setProperty(HTTP_BIND_ENABLED, String.valueOf(isEnabled));</span>
<span class="nc" id="L563">    }</span>

    /**
     * Set the ports on which the HTTP binding service will be running.
     *
     * @param unsecurePort the unsecured connection port which clients can connect to.
     * @param securePort the secured connection port which clients can connect to.
     * @throws Exception when there is an error configuring the HTTP binding ports.
     */
    public void setHttpBindPorts(int unsecurePort, int securePort) throws Exception {
<span class="nc bnc" id="L573" title="All 2 branches missed.">        if (unsecurePort != HTTP_BIND_PORT_DEFAULT) {</span>
<span class="nc" id="L574">            JiveGlobals.setProperty(HTTP_BIND_PORT, String.valueOf(unsecurePort));</span>
        }
        else {
<span class="nc" id="L577">            JiveGlobals.deleteProperty(HTTP_BIND_PORT);</span>
        }
<span class="nc bnc" id="L579" title="All 2 branches missed.">        if (securePort != HTTP_BIND_SECURE_PORT_DEFAULT) {</span>
<span class="nc" id="L580">            JiveGlobals.setProperty(HTTP_BIND_SECURE_PORT, String.valueOf(securePort));</span>
        }
        else {
<span class="nc" id="L583">            JiveGlobals.deleteProperty(HTTP_BIND_SECURE_PORT);</span>
        }
<span class="nc" id="L585">    }</span>

    /**
     * Creates a Jetty context handler that can be used to expose BOSH (HTTP-Bind) functionality.
     *
     * Note that an invocation of this method will not register the handler (and thus make the related functionality
     * available to the end user). Instead, the created handler is returned by this method, and will need to be
     * registered with the embedded Jetty webserver by the caller.
     *
     * @return A Jetty context handler (never null).
     */
    protected Handler createBoshHandler()
    {
        final int options;
<span class="nc bnc" id="L599" title="All 2 branches missed.">        if(isHttpCompressionEnabled()) {</span>
<span class="nc" id="L600">            options = ServletContextHandler.SESSIONS | ServletContextHandler.GZIP;</span>
        } else {
<span class="nc" id="L602">            options = ServletContextHandler.SESSIONS;</span>
        }
<span class="nc" id="L604">        final ServletContextHandler context = new ServletContextHandler( null, &quot;/http-bind&quot;, options );</span>

        // Ensure the JSP engine is initialized correctly (in order to be able to cope with Tomcat/Jasper precompiled JSPs).
<span class="nc" id="L607">        final List&lt;ContainerInitializer&gt; initializers = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L608">        initializers.add( new ContainerInitializer( new JasperInitializer(), null ) );</span>
<span class="nc" id="L609">        context.setAttribute( &quot;org.eclipse.jetty.containerInitializers&quot;, initializers );</span>
<span class="nc" id="L610">        context.setAttribute( InstanceManager.class.getName(), new SimpleInstanceManager() );</span>

        // Generic configuration of the context.
<span class="nc" id="L613">        context.setAllowNullPathInfo( true );</span>

        // Add the functionality-providers.
<span class="nc" id="L616">        context.addServlet( new ServletHolder( new HttpBindServlet() ), &quot;/*&quot; );</span>

        // Add compression filter when needed.
<span class="nc bnc" id="L619" title="All 2 branches missed.">        if (isHttpCompressionEnabled()) {</span>
<span class="nc" id="L620">            final GzipHandler gzipHandler = context.getGzipHandler();</span>
<span class="nc" id="L621">            gzipHandler.addIncludedPaths(&quot;/*&quot;);</span>
<span class="nc" id="L622">            gzipHandler.addIncludedMethods(HttpMethod.POST.asString());</span>
        }

<span class="nc" id="L625">        return context;</span>
    }

    /**
     * Creates a Jetty context handler that can be used to expose Websocket functionality.
     *
     * Note that an invocation of this method will not register the handler (and thus make the related functionality
     * available to the end user). Instead, the created handler is returned by this method, and will need to be
     * registered with the embedded Jetty webserver by the caller.
     *
     * @return A Jetty context handler (never null).
     */
    protected Handler createWebsocketHandler()
    {
<span class="nc" id="L639">        final ServletContextHandler context = new ServletContextHandler( null, &quot;/ws&quot;, ServletContextHandler.SESSIONS );</span>
<span class="nc" id="L640">        context.setAllowNullPathInfo(true);</span>
        // Add the functionality-providers.
<span class="nc" id="L642">        context.addServlet( new ServletHolder( new OpenfireWebSocketServlet() ), &quot;/*&quot; );</span>

<span class="nc" id="L644">        return context;</span>
    }

    // NOTE: enabled by default
    private boolean isHttpCompressionEnabled() {
<span class="nc" id="L649">        final ConnectionManagerImpl connectionManager = ((ConnectionManagerImpl) XMPPServer.getInstance().getConnectionManager());</span>
<span class="nc" id="L650">        final ConnectionConfiguration configuration = connectionManager.getListener( ConnectionType.BOSH_C2S, true ).generateConnectionConfiguration();</span>
<span class="nc bnc" id="L651" title="All 4 branches missed.">        return configuration.getCompressionPolicy() == null || configuration.getCompressionPolicy().equals( Connection.CompressionPolicy.optional );</span>
    }

    /**
     * Creates a Jetty context handler that can be used to expose the cross-domain functionality as implemented by
     * {@link FlashCrossDomainServlet}.
     *
     * Note that an invocation of this method will not register the handler (and thus make the related functionality
     * available to the end user). Instead, the created handler is returned by this method, and will need to be
     * registered with the embedded Jetty webserver by the caller.
     *
     * @return A Jetty context handler (never null).
     */
    protected Handler createCrossDomainHandler()
    {
<span class="nc" id="L666">        final ServletContextHandler context = new ServletContextHandler( null, &quot;/crossdomain.xml&quot;, ServletContextHandler.SESSIONS );</span>

        // Ensure the JSP engine is initialized correctly (in order to be able to cope with Tomcat/Jasper precompiled JSPs).
<span class="nc" id="L669">        final List&lt;ContainerInitializer&gt; initializers = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L670">        initializers.add( new ContainerInitializer( new JasperInitializer(), null ) );</span>
<span class="nc" id="L671">        context.setAttribute( &quot;org.eclipse.jetty.containerInitializers&quot;, initializers );</span>
<span class="nc" id="L672">        context.setAttribute( InstanceManager.class.getName(), new SimpleInstanceManager() );</span>

        // Generic configuration of the context.
<span class="nc" id="L675">        context.setAllowNullPathInfo( true );</span>

        // Add the functionality-providers.
<span class="nc" id="L678">        context.addServlet( new ServletHolder( new FlashCrossDomainServlet() ), &quot;&quot; );</span>

<span class="nc" id="L680">        return context;</span>
    }

    /**
     * Creates a Jetty context handler that can be used to expose static files.
     *
     * Note that an invocation of this method will not register the handler (and thus make the related functionality
     * available to the end user). Instead, the created handler is returned by this method, and will need to be
     * registered with the embedded Jetty webserver by the caller.
     *
     * @return A Jetty context handler, or null when the static content could not be accessed.
     */
    protected Handler createStaticContentHandler()
    {
<span class="nc" id="L694">        final File spankDirectory = new File( JiveGlobals.getHomeDirectory() + File.separator + &quot;resources&quot; + File.separator + &quot;spank&quot; );</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">        if ( spankDirectory.exists() )</span>
        {
<span class="nc bnc" id="L697" title="All 2 branches missed.">            if ( spankDirectory.canRead() )</span>
            {
<span class="nc" id="L699">                final WebAppContext context = new WebAppContext( null, spankDirectory.getPath(), &quot;/&quot; );</span>
<span class="nc" id="L700">                context.setWelcomeFiles( new String[] { &quot;index.html&quot; } );</span>

<span class="nc" id="L702">                return context;</span>
            }
            else
            {
<span class="nc" id="L706">                Log.warn( &quot;Openfire cannot read the directory: &quot; + spankDirectory );</span>
            }
        }
<span class="nc" id="L709">        return null;</span>
    }

    /**
     * Adds a Jetty handler to be added to the embedded web server that is used to expose BOSH (HTTP-bind)
     * functionality.
     *
     * @param handler The handler (cannot be null).
     */
    public void addJettyHandler( Handler handler )
    {
<span class="nc bnc" id="L720" title="All 2 branches missed.">        if ( handler == null )</span>
        {
<span class="nc" id="L722">            throw new IllegalArgumentException( &quot;Argument 'handler' cannot be null.&quot; );</span>
        }

<span class="nc" id="L725">        extensionHandlers.addHandler( handler );</span>

<span class="nc bnc" id="L727" title="All 4 branches missed.">        if ( !handler.isStarted() &amp;&amp; extensionHandlers.isStarted() )</span>
        {
            try
            {
<span class="nc" id="L731">                handler.start();</span>
            }
<span class="nc" id="L733">            catch ( Exception e )</span>
            {
<span class="nc" id="L735">                Log.warn( &quot;Unable to start handler {}&quot;, handler, e );</span>
<span class="nc" id="L736">            }</span>
        }
<span class="nc" id="L738">    }</span>

    /**
     * Removes a Jetty handler to be added to the embedded web server that is used to expose BOSH (HTTP-bind)
     * functionality.
     *
     * Removing a handler, even when null, or non-existing, might have side-effects as introduced by the Jetty
     * implementation. At the time of writing, Jetty will re
     *
     * @param handler The handler (should not be null).
     */
    public void removeJettyHandler( Handler handler )
    {
<span class="nc bnc" id="L751" title="All 2 branches missed.">        if (handler instanceof WebAppContext) {</span>
            // A work-around of the Jetty bug described at https://github.com/eclipse/jetty.project/issues/1425
            // NOTE: According to some comments on WebAppLoaderFix, this may stop working on Java 9.
            // Hopefully the Jetty team will have fixed the underlying bug by then
<span class="nc" id="L755">            WebAppLoaderFix.checkAndClose(((WebAppContext) handler).getClassLoader());</span>
        }
<span class="nc" id="L757">        extensionHandlers.removeHandler( handler );</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">        if ( handler.isStarted() )</span>
        {
            try
            {
<span class="nc" id="L762">                handler.stop();</span>
            }
<span class="nc" id="L764">            catch ( Exception e )</span>
            {
<span class="nc" id="L766">                Log.warn( &quot;Unable to stop the handler that was removed: {}&quot;, handler, e );</span>
<span class="nc" id="L767">            }</span>
        }

<span class="nc" id="L770">    }</span>

    private void doEnableHttpBind(boolean shouldEnable) {
<span class="nc bnc" id="L773" title="All 4 branches missed.">        if (shouldEnable &amp;&amp; httpBindServer == null) {</span>
<span class="nc" id="L774">            start();</span>
        }
<span class="nc bnc" id="L776" title="All 4 branches missed.">        else if (!shouldEnable &amp;&amp; httpBindServer != null) {</span>
<span class="nc" id="L777">            stop();</span>
        }
<span class="nc" id="L779">    }</span>

    /**
     * Returns the HTTP binding port which does not use SSL.
     *
     * @return the HTTP binding port which does not use SSL.
     */
    public int getHttpBindUnsecurePort() {
<span class="nc" id="L787">        return JiveGlobals.getIntProperty(HTTP_BIND_PORT, HTTP_BIND_PORT_DEFAULT);</span>
    }

    /**
     * Returns the HTTP binding port which uses SSL.
     *
     * @return the HTTP binding port which uses SSL.
     */
    public int getHttpBindSecurePort() {
<span class="nc" id="L796">        return JiveGlobals.getIntProperty(HTTP_BIND_SECURE_PORT, HTTP_BIND_SECURE_PORT_DEFAULT);</span>
    }

    /**
     * Returns true if script syntax is enabled. Script syntax allows BOSH to be used in
     * environments where clients may be restricted to using a particular server. Instead of using
     * standard HTTP Post requests to transmit data,  HTTP Get requests are used.
     *
     * @return true if script syntax is enabled.
     * @see &lt;a href=&quot;http://www.xmpp.org/extensions/xep-0124.html#script&quot;&gt;BOSH: Alternative Script
     * Syntax&lt;/a&gt;
     */
    public boolean isScriptSyntaxEnabled() {
<span class="nc" id="L809">        return JiveGlobals.getBooleanProperty(&quot;xmpp.httpbind.scriptSyntax.enabled&quot;, false);</span>
    }

    /**
     * Enables or disables script syntax.
     *
     * @param isEnabled true to enable script syntax and false to disable it.
     * @see #isScriptSyntaxEnabled()
     * @see &lt;a href=&quot;http://www.xmpp.org/extensions/xep-0124.html#script&quot;&gt;BOSH: Alternative Script
     * Syntax&lt;/a&gt;
     */
    public void setScriptSyntaxEnabled(boolean isEnabled) {
<span class="nc" id="L821">        final String property = &quot;xmpp.httpbind.scriptSyntax.enabled&quot;;</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">        if(!isEnabled) {</span>
<span class="nc" id="L823">            JiveGlobals.deleteProperty(property);</span>
        }
        else {
<span class="nc" id="L826">            JiveGlobals.setProperty(property, String.valueOf(isEnabled));</span>
        }
<span class="nc" id="L828">    }</span>

    private synchronized void restartServer() {
<span class="nc" id="L831">        stop();</span>
<span class="nc" id="L832">        start();</span>
<span class="nc" id="L833">    }</span>

    @Override
    public void propertySet(String property, Map&lt;String, Object&gt; params) {
<span class="nc bnc" id="L837" title="All 2 branches missed.">        if (property.equalsIgnoreCase(HTTP_BIND_ENABLED)) {</span>
<span class="nc" id="L838">            doEnableHttpBind(Boolean.valueOf(params.get(&quot;value&quot;).toString()));</span>
        }
<span class="nc bnc" id="L840" title="All 2 branches missed.">        else if (property.equalsIgnoreCase(HTTP_BIND_PORT)) {</span>
            try {
<span class="nc" id="L842">                Integer.valueOf(params.get(&quot;value&quot;).toString());</span>
            }
<span class="nc" id="L844">            catch (NumberFormatException ne) {</span>
<span class="nc" id="L845">                JiveGlobals.deleteProperty(HTTP_BIND_PORT);</span>
<span class="nc" id="L846">                return;</span>
<span class="nc" id="L847">            }</span>
<span class="nc" id="L848">            restartServer();</span>
        }
<span class="nc bnc" id="L850" title="All 2 branches missed.">        else if (property.equalsIgnoreCase(HTTP_BIND_SECURE_PORT)) {</span>
            try {
<span class="nc" id="L852">                Integer.valueOf(params.get(&quot;value&quot;).toString());</span>
            }
<span class="nc" id="L854">            catch (NumberFormatException ne) {</span>
<span class="nc" id="L855">                JiveGlobals.deleteProperty(HTTP_BIND_SECURE_PORT);</span>
<span class="nc" id="L856">                return;</span>
<span class="nc" id="L857">            }</span>
<span class="nc" id="L858">            restartServer();</span>
        }
<span class="nc bnc" id="L860" title="All 2 branches missed.">        else if (HTTP_BIND_AUTH_PER_CLIENTCERT_POLICY.equalsIgnoreCase( property )) {</span>
<span class="nc" id="L861">            restartServer();</span>
        }
<span class="nc" id="L863">    }</span>

    @Override
    public void propertyDeleted(String property, Map&lt;String, Object&gt; params) {
<span class="nc bnc" id="L867" title="All 2 branches missed.">        if (property.equalsIgnoreCase(HTTP_BIND_ENABLED)) {</span>
<span class="nc" id="L868">            doEnableHttpBind(HTTP_BIND_ENABLED_DEFAULT);</span>
        }
<span class="nc bnc" id="L870" title="All 2 branches missed.">        else if (property.equalsIgnoreCase(HTTP_BIND_PORT)) {</span>
<span class="nc" id="L871">            restartServer();</span>
        }
<span class="nc bnc" id="L873" title="All 2 branches missed.">        else if (property.equalsIgnoreCase(HTTP_BIND_SECURE_PORT)) {</span>
<span class="nc" id="L874">            restartServer();</span>
        }
<span class="nc bnc" id="L876" title="All 2 branches missed.">        else if (HTTP_BIND_AUTH_PER_CLIENTCERT_POLICY.equalsIgnoreCase( property )) {</span>
<span class="nc" id="L877">            restartServer();</span>
        }
<span class="nc" id="L879">    }</span>

    @Override
    public void xmlPropertySet(String property, Map&lt;String, Object&gt; params) {
<span class="nc" id="L883">    }</span>

    @Override
    public void xmlPropertyDeleted(String property, Map&lt;String, Object&gt; params) {
<span class="nc" id="L887">    }</span>

    @Override
    public void storeContentChanged( CertificateStore store )
    {
<span class="nc" id="L892">        restartServer();</span>
<span class="nc" id="L893">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>