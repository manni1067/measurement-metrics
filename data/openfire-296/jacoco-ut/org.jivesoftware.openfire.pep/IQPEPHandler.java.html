<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>IQPEPHandler.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Core XMPP Server</a> &gt; <a href="index.source.html" class="el_package">org.jivesoftware.openfire.pep</a> &gt; <span class="el_source">IQPEPHandler.java</span></div><h1>IQPEPHandler.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2005-2008 Jive Software. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jivesoftware.openfire.pep;

import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import org.dom4j.DocumentHelper;
import org.dom4j.Element;
import org.dom4j.QName;
import org.jivesoftware.openfire.IQHandlerInfo;
import org.jivesoftware.openfire.XMPPServer;
import org.jivesoftware.openfire.auth.UnauthorizedException;
import org.jivesoftware.openfire.disco.*;
import org.jivesoftware.openfire.event.UserEventDispatcher;
import org.jivesoftware.openfire.event.UserEventListener;
import org.jivesoftware.openfire.handler.IQHandler;
import org.jivesoftware.openfire.pubsub.*;
import org.jivesoftware.openfire.pubsub.models.AccessModel;
import org.jivesoftware.openfire.roster.Roster;
import org.jivesoftware.openfire.roster.RosterEventDispatcher;
import org.jivesoftware.openfire.roster.RosterEventListener;
import org.jivesoftware.openfire.roster.RosterItem;
import org.jivesoftware.openfire.roster.RosterManager;
import org.jivesoftware.openfire.session.ClientSession;
import org.jivesoftware.openfire.user.PresenceEventDispatcher;
import org.jivesoftware.openfire.user.PresenceEventListener;
import org.jivesoftware.openfire.user.User;
import org.jivesoftware.openfire.user.UserNotFoundException;
import org.jivesoftware.util.JiveGlobals;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xmpp.forms.DataForm;
import org.xmpp.forms.FormField;
import org.xmpp.packet.IQ;
import org.xmpp.packet.JID;
import org.xmpp.packet.PacketError;
import org.xmpp.packet.Presence;

/**
 * &lt;p&gt;
 * An {@link IQHandler} used to implement XEP-0163: &quot;Personal Eventing via Pubsub&quot;
 * Version 1.0
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * For each user on the server there is an associated {@link PEPService} interacting
 * with a single {@link PubSubEngine} for managing the user's PEP nodes.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * An IQHandler can only handle one namespace in its IQHandlerInfo. However, PEP
 * related packets are seen having a variety of different namespaces. Thus,
 * classes like {@link IQPEPOwnerHandler} are used to forward packets having these other
 * namespaces to {@link IQPEPHandler#handleIQ(IQ)}.
 *
 * &lt;p&gt;
 * This handler is used for the following namespaces:&lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;&lt;i&gt;http://jabber.org/protocol/pubsub&lt;/i&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;i&gt;http://jabber.org/protocol/pubsub#owner&lt;/i&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Armando Jagucki
 * @author Guus der Kinderen, guus.der.kinderen@gmail.com
 */
public class IQPEPHandler extends IQHandler implements ServerIdentitiesProvider, ServerFeaturesProvider,
        UserIdentitiesProvider, UserFeaturesProvider, UserItemsProvider, PresenceEventListener,
        RosterEventListener, UserEventListener, DiscoInfoProvider {

<span class="nc" id="L87">    private static final Logger Log = LoggerFactory.getLogger(IQPEPHandler.class);</span>

    /**
     * Metadata that relates to the IQ processing capabilities of this specific {@link IQHandler}.
     */
    private final IQHandlerInfo info;

<span class="nc" id="L94">    private PEPServiceManager pepServiceManager = null;</span>

    /**
     * The managed thread pool that will do most of the processing. The amount
     * of worker threads in this pool should be kept low to avoid resource
     * contention.
     */
    // There's room for future improvement here. If anywhere in the future,
    // Openfire allows implementations to use dedicated resource pools, we can
    // significantly increase the number of worker threads in this executor. The
    // bottleneck for this particular executor is the database pool. During
    // startup, PEP queries the database a lot, which causes all of the
    // connections in the generic database pool to be used up by this PEP
    // implementation. This can cause problems in other parts of Openfire that
    // depend on database access (ideally, these should get dedicated resource
    // pools too).
<span class="nc" id="L110">    private ExecutorService executor = null;</span>

    /**
     * Constructs a new {@link IQPEPHandler} instance.
     */
    public IQPEPHandler() {
<span class="nc" id="L116">        super(&quot;Personal Eventing Handler&quot;);</span>
<span class="nc" id="L117">        info = new IQHandlerInfo(&quot;pubsub&quot;, &quot;http://jabber.org/protocol/pubsub&quot;);</span>
<span class="nc" id="L118">    }</span>

    /* 
     * (non-Javadoc)
     * @see org.jivesoftware.openfire.handler.IQHandler#initialize(org.jivesoftware.openfire.XMPPServer)
     */
    @Override
    public void initialize(XMPPServer server) {
<span class="nc" id="L126">        super.initialize(server);</span>

<span class="nc" id="L128">        pepServiceManager = new PEPServiceManager();</span>
<span class="nc" id="L129">    }</span>

    public PEPServiceManager getServiceManager()
    {
<span class="nc" id="L133">        return pepServiceManager;</span>
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.jivesoftware.openfire.container.BasicModule#destroy()
     */
    @Override
    public void destroy() {
<span class="nc" id="L143">        super.destroy();</span>
<span class="nc" id="L144">    }</span>

    /*
     * (non-Javadoc)
     * 
     * @see org.jivesoftware.openfire.container.BasicModule#start()
     */
    @Override
    public void start() {
<span class="nc" id="L153">        super.start();</span>
        
        // start the service manager
<span class="nc" id="L156">        pepServiceManager.start();</span>
        
        // start a new executor service
<span class="nc" id="L159">        startExecutor();</span>
        
        // Listen to presence events to manage PEP auto-subscriptions.
<span class="nc" id="L162">        PresenceEventDispatcher.addListener(this);</span>
        // Listen to roster events for PEP subscription cancelling on contact deletion.
<span class="nc" id="L164">        RosterEventDispatcher.addListener(this);</span>
        // Listen to user events in order to destroy a PEP service when a user is deleted.
<span class="nc" id="L166">        UserEventDispatcher.addListener(this);</span>
<span class="nc" id="L167">    }</span>
    
    /*
     * (non-Javadoc)
     * 
     * @see org.jivesoftware.openfire.container.BasicModule#stop()
     */
    @Override
    public void stop() {
<span class="nc" id="L176">        super.stop();</span>
        
        // Remove listeners
<span class="nc" id="L179">        PresenceEventDispatcher.removeListener(this);</span>
<span class="nc" id="L180">        RosterEventDispatcher.removeListener(this);</span>
<span class="nc" id="L181">        UserEventDispatcher.removeListener(this);        </span>
        
        // stop the executor service
<span class="nc" id="L184">        stopExecutor();</span>
        
        // stop the pepservicemananger
<span class="nc" id="L187">        pepServiceManager.stop();</span>
<span class="nc" id="L188">    }</span>
    
    /**
     * Starts a new thread pool, unless an existing one is still running.
     */
    private void startExecutor() {
<span class="nc bnc" id="L194" title="All 4 branches missed.">        if (executor == null || executor.isShutdown()) {</span>
            // keep the amount of workers low! See comment that goes with the
            // field named 'executor'.
<span class="nc" id="L197">            Log.debug(&quot;Starting executor service...&quot;);</span>
<span class="nc" id="L198">            executor = Executors.newScheduledThreadPool(2);</span>
        }
<span class="nc" id="L200">    }</span>
    
    /**
     * Shuts down the executor by dropping all tasks from the queue. This method
     * will allow the executor to finish operations on running tasks for a
     * period of two seconds. After that, tasks are forcefully stopped.
     * &lt;p&gt;
     * The order in which the various shutdown routines of the executor are
     * called, is:
     * &lt;ol&gt;
     * &lt;li&gt;{@link ExecutorService#shutdown()}&lt;/li&gt;
     * &lt;li&gt;{@link ExecutorService#awaitTermination(long, TimeUnit)} (two
     * seconds)&lt;/li&gt;
     * &lt;li&gt;{@link ExecutorService#shutdownNow()}&lt;/li&gt;
     * &lt;/ol&gt;
     */
    private void stopExecutor() {
<span class="nc" id="L217">        Log.debug(&quot;Stopping executor service...&quot;);</span>
        /*
         * This method gets called as part of the Component#shutdown() routine.
         * If that method gets called, the component has already been removed
         * from the routing tables. We don't need to worry about new packets to
         * arrive - there won't be any.
         */
<span class="nc" id="L224">        executor.shutdown();</span>
        try {
<span class="nc bnc" id="L226" title="All 2 branches missed.">            if (!executor.awaitTermination(2, TimeUnit.SECONDS)) {</span>
<span class="nc" id="L227">                Log.debug(&quot;Forcing a shutdown for the executor service (after a two-second timeout has elapsed...&quot;);</span>
<span class="nc" id="L228">                executor.shutdownNow();</span>
                // Note that if any IQ request stanzas had been scheduled, they
                // MUST be responded to with an error here. A list of tasks that
                // have never been commenced by the executor is returned by the
                // #shutdownNow() method of the ExecutorService.
            }
<span class="nc" id="L234">        } catch (InterruptedException e) {</span>
            // ignore, as we're shutting down anyway.
<span class="nc" id="L236">        }</span>
<span class="nc" id="L237">    }</span>

    /*
     * (non-Javadoc)
     * 
     * @see org.jivesoftware.openfire.handler.IQHandler#getInfo()
     */
    @Override
    public IQHandlerInfo getInfo() {
<span class="nc" id="L246">        return info;</span>
    }

    /**
     * Implements ServerIdentitiesProvider and UserIdentitiesProvider, adding
     * the PEP identity to the respective disco#info results.
     */
    @Override
    public Iterator&lt;Element&gt; getIdentities() {
<span class="nc" id="L255">        Element identity = DocumentHelper.createElement(&quot;identity&quot;);</span>
<span class="nc" id="L256">        identity.addAttribute(&quot;category&quot;, &quot;pubsub&quot;);</span>
<span class="nc" id="L257">        identity.addAttribute(&quot;type&quot;, &quot;pep&quot;);</span>
<span class="nc" id="L258">        return Collections.singleton(identity).iterator();</span>
    }

    /**
     * Implements ServerFeaturesProvider to include all supported XEP-0060 features
     * in the server's disco#info result (as per section 4 of XEP-0163).
     */
    @Override
    public Iterator&lt;String&gt; getFeatures() {
<span class="nc" id="L267">        Iterator&lt;String&gt; it = XMPPServer.getInstance().getPubSubModule().getFeatures(null, null, null);</span>
<span class="nc" id="L268">        ArrayList&lt;String&gt; features = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L270">            features.add(it.next());</span>
        }
        // Auto Creation of nodes is supported in PEP
<span class="nc" id="L273">        features.add(&quot;http://jabber.org/protocol/pubsub#auto-create&quot;);</span>
<span class="nc" id="L274">        return features.iterator();</span>
    }


    /**
     * Returns true if the PEP service is enabled in the server.
     *
     * @return true if the PEP service is enabled in the server.
     */
    // TODO: listen for property changes to stop/start this module.
    public boolean isEnabled() {
<span class="nc" id="L285">        return JiveGlobals.getBooleanProperty(&quot;xmpp.pep.enabled&quot;, true);</span>
    }

    // *****************************************************************
    // *** Generic module management ends here. From this point on   ***
    // *** more specific PEP related implementation after this point ***
    // *****************************************************************
    
    /*
     * (non-Javadoc)
     * 
     * @see
     * org.jivesoftware.openfire.handler.IQHandler#handleIQ(org.xmpp.packet.IQ)
     */
    @Override
    public IQ handleIQ(IQ packet) throws UnauthorizedException {
        // Do nothing if server is not enabled
<span class="nc bnc" id="L302" title="All 2 branches missed.">        if (!isEnabled()) {</span>
<span class="nc" id="L303">            IQ reply = IQ.createResultIQ(packet);</span>
<span class="nc" id="L304">            reply.setChildElement(packet.getChildElement().createCopy());</span>
<span class="nc" id="L305">            reply.setError(PacketError.Condition.service_unavailable);</span>
<span class="nc" id="L306">            return reply;</span>
        }

<span class="nc" id="L309">        final JID senderJID = packet.getFrom();</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">        if (packet.getTo() == null) {</span>
            // packet addressed to service itself (not to a node/user)
<span class="nc" id="L312">            final String jidFrom = senderJID.toBareJID();</span>
<span class="nc" id="L313">            packet = packet.createCopy();</span>
<span class="nc" id="L314">            packet.setTo(jidFrom);</span>

<span class="nc bnc" id="L316" title="All 2 branches missed.">            if (packet.getType() == IQ.Type.set) {</span>
<span class="nc" id="L317">                PEPService pepService = pepServiceManager.getPEPService(jidFrom);</span>

                // If no service exists yet for jidFrom, create one.
<span class="nc bnc" id="L320" title="All 2 branches missed.">                if (pepService == null) {</span>
                    try {
<span class="nc" id="L322">                        pepService = pepServiceManager.create(senderJID);                		</span>
<span class="nc" id="L323">                    } catch (IllegalArgumentException ex) {</span>
<span class="nc" id="L324">                        final IQ reply = IQ.createResultIQ(packet);</span>
<span class="nc" id="L325">                        reply.setChildElement(packet.getChildElement().createCopy());</span>
<span class="nc" id="L326">                        reply.setError(PacketError.Condition.not_allowed);</span>
<span class="nc" id="L327">                        return reply;</span>
<span class="nc" id="L328">                    }</span>

                    // Probe presences
<span class="nc" id="L331">                    pepServiceManager.start(pepService);</span>

                    // Those who already have presence subscriptions to jidFrom
                    // will now automatically be subscribed to this new
                    // PEPService.
                    try {
<span class="nc" id="L337">                        final RosterManager rm = XMPPServer.getInstance()</span>
<span class="nc" id="L338">                                .getRosterManager();</span>
<span class="nc" id="L339">                        final Roster roster = rm.getRoster(senderJID.getNode());</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">                        for (final RosterItem item : roster.getRosterItems()) {</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">                            if (item.getSubStatus() == RosterItem.SUB_BOTH</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">                                    || item.getSubStatus() == RosterItem.SUB_FROM) {</span>
<span class="nc" id="L343">                                createSubscriptionToPEPService(pepService, item</span>
<span class="nc" id="L344">                                        .getJid(), senderJID);</span>
                            }
<span class="nc" id="L346">                        }</span>
<span class="nc" id="L347">                    } catch (UserNotFoundException e) {</span>
                        // Do nothing
<span class="nc" id="L349">                    }</span>
                }

                // If publishing a node, and the node doesn't exist, create it.
<span class="nc" id="L353">                final Element childElement = packet.getChildElement();</span>
<span class="nc" id="L354">                final Element publishElement = childElement.element(&quot;publish&quot;);</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">                if (publishElement != null) {</span>
<span class="nc" id="L356">                    final String nodeID = publishElement.attributeValue(&quot;node&quot;);</span>

                    // Do not allow User Avatar nodes to be created.
                    // TODO: Implement XEP-0084
<span class="nc bnc" id="L360" title="All 2 branches missed.">                    if (nodeID.startsWith(&quot;http://www.xmpp.org/extensions/xep-0084.html&quot;)) {</span>
<span class="nc" id="L361">                        IQ reply = IQ.createResultIQ(packet);</span>
<span class="nc" id="L362">                        reply.setChildElement(packet.getChildElement().createCopy());</span>
<span class="nc" id="L363">                        reply.setError(PacketError.Condition.feature_not_implemented);</span>
<span class="nc" id="L364">                        return reply;</span>
                    }

<span class="nc bnc" id="L367" title="All 2 branches missed.">                    if (pepService.getNode(nodeID) == null) {</span>
                        // Create the node
<span class="nc" id="L369">                        final JID creator = new JID(jidFrom);</span>
<span class="nc" id="L370">                        final LeafNode newNode = new LeafNode(pepService, pepService.getRootCollectionNode(), nodeID, creator);</span>
<span class="nc" id="L371">                        final DataForm publishOptions = PubSubEngine.getPublishOptions( packet );</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">                        if ( publishOptions != null )</span>
                        {
                            try
                            {
<span class="nc" id="L376">                                newNode.configure( publishOptions );</span>
                            }
<span class="nc" id="L378">                            catch ( NotAcceptableException e )</span>
                            {
<span class="nc" id="L380">                                Log.warn( &quot;Unable to apply publish-options when creating a new PEP node {} for {}&quot;, nodeID, creator, e );</span>
<span class="nc" id="L381">                            }</span>
                        }
<span class="nc" id="L383">                        newNode.addOwner(creator);</span>
<span class="nc" id="L384">                        newNode.saveToDB();</span>
                    }
                }

                // Process with PubSub as usual.
<span class="nc" id="L389">                pepServiceManager.process(pepService, packet);</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">            } else if (packet.getType() == IQ.Type.get) {</span>
<span class="nc" id="L391">                final PEPService pepService = pepServiceManager.getPEPService(jidFrom);            	</span>
                
<span class="nc bnc" id="L393" title="All 2 branches missed.">                if (pepService != null) {</span>
<span class="nc" id="L394">                    pepServiceManager.process(pepService, packet);</span>
                } else {
                    // Process with PubSub using a dummyService. In the case where an IQ packet is sent to
                    // a user who does not have a PEP service, we wish to utilize the error reporting flow
                    // already present in the PubSubEngine. This gives the illusion that every user has a
                    // PEP service, as required by the specification.
<span class="nc" id="L400">                    PEPService dummyService = new PEPService(XMPPServer.getInstance(), senderJID.toBareJID());</span>
<span class="nc" id="L401">                    pepServiceManager.process(dummyService, packet);</span>
                }
            }
<span class="nc" id="L404">        }</span>
<span class="nc bnc" id="L405" title="All 4 branches missed.">        else if (packet.getType() == IQ.Type.get || packet.getType() == IQ.Type.set) {</span>
            // packet was addressed to a node.
            
<span class="nc" id="L408">            final String jidTo = packet.getTo().toBareJID();</span>

<span class="nc" id="L410">            final PEPService pepService = pepServiceManager.getPEPService(jidTo);</span>

<span class="nc bnc" id="L412" title="All 2 branches missed.">            if (pepService != null) {</span>
<span class="nc" id="L413">                pepServiceManager.process(pepService, packet);</span>
            } else {
                // Process with PubSub using a dummyService. In the case where an IQ packet is sent to
                // a user who does not have a PEP service, we wish to utilize the error reporting flow
                // already present in the PubSubEngine. This gives the illusion that every user has a
                // PEP service, as required by the specification.
<span class="nc" id="L419">                PEPService dummyService = new PEPService(XMPPServer.getInstance(), senderJID.toBareJID());</span>
<span class="nc" id="L420">                pepServiceManager.process(dummyService, packet);</span>
            }
<span class="nc" id="L422">        } else {</span>
            // Ignore IQ packets of type 'error' or 'result'.
<span class="nc" id="L424">            return null;</span>
        }

        // Other error flows were handled in pubSubEngine.process(...)
<span class="nc" id="L428">        return null;</span>
    }

    /**
     * Generates and processes an IQ stanza that subscribes to a PEP service.
     *
     * @param pepService the PEP service of the owner.
     * @param subscriber the JID of the entity that is subscribing to the PEP service.
     * @param owner      the JID of the owner of the PEP service.
     */
    private void createSubscriptionToPEPService(PEPService pepService, JID subscriber, JID owner) {
        // If `owner` has a PEP service, generate and process a pubsub subscription packet
        // that is equivalent to: (where 'from' field is JID of subscriber and 'to' field is JID of owner)
        //
        //        &lt;iq type='set'
        //            from='nurse@capulet.com/chamber'
        //            to='juliet@capulet.com
        //            id='collsub'&gt;
        //          &lt;pubsub xmlns='http://jabber.org/protocol/pubsub'&gt;
        //            &lt;subscribe jid='nurse@capulet.com'/&gt;
        //            &lt;options&gt;
        //              &lt;x xmlns='jabber:x:data'&gt;
        //                &lt;field var='FORM_TYPE' type='hidden'&gt;
        //                  &lt;value&gt;http://jabber.org/protocol/pubsub#subscribe_options&lt;/value&gt;
        //                &lt;/field&gt;
        //                &lt;field var='pubsub#subscription_type'&gt;
        //                  &lt;value&gt;items&lt;/value&gt;
        //                &lt;/field&gt;
        //                &lt;field var='pubsub#subscription_depth'&gt;
        //                  &lt;value&gt;all&lt;/value&gt;
        //                &lt;/field&gt;
        //              &lt;/x&gt;
        //           &lt;/options&gt;
        //         &lt;/pubsub&gt;
        //        &lt;/iq&gt;

<span class="nc" id="L464">        IQ subscriptionPacket = new IQ(IQ.Type.set);</span>
<span class="nc" id="L465">        subscriptionPacket.setFrom(subscriber);</span>
<span class="nc" id="L466">        subscriptionPacket.setTo(owner.toBareJID());</span>

<span class="nc" id="L468">        Element pubsubElement = subscriptionPacket.setChildElement(&quot;pubsub&quot;, &quot;http://jabber.org/protocol/pubsub&quot;);</span>

<span class="nc" id="L470">        Element subscribeElement = pubsubElement.addElement(&quot;subscribe&quot;);</span>
<span class="nc" id="L471">        subscribeElement.addAttribute(&quot;jid&quot;, subscriber.toBareJID());</span>

<span class="nc" id="L473">        Element optionsElement = pubsubElement.addElement(&quot;options&quot;);</span>
<span class="nc" id="L474">        Element xElement = optionsElement.addElement(QName.get(&quot;x&quot;, &quot;jabber:x:data&quot;));</span>

<span class="nc" id="L476">        DataForm dataForm = new DataForm(xElement);</span>

<span class="nc" id="L478">        FormField formField = dataForm.addField();</span>
<span class="nc" id="L479">        formField.setVariable(&quot;FORM_TYPE&quot;);</span>
<span class="nc" id="L480">        formField.setType(FormField.Type.hidden);</span>
<span class="nc" id="L481">        formField.addValue(&quot;http://jabber.org/protocol/pubsub#subscribe_options&quot;);</span>

<span class="nc" id="L483">        formField = dataForm.addField();</span>
<span class="nc" id="L484">        formField.setVariable(&quot;pubsub#subscription_type&quot;);</span>
<span class="nc" id="L485">        formField.addValue(&quot;items&quot;);</span>

<span class="nc" id="L487">        formField = dataForm.addField();</span>
<span class="nc" id="L488">        formField.setVariable(&quot;pubsub#subscription_depth&quot;);</span>
<span class="nc" id="L489">        formField.addValue(&quot;all&quot;);</span>

<span class="nc" id="L491">        pepServiceManager.process(pepService, subscriptionPacket);</span>
<span class="nc" id="L492">    }</span>

    /**
     * Cancels a subscription to a PEPService's root collection node.
     *
     * @param unsubscriber the JID of the subscriber whose subscription is being canceled.
     * @param serviceOwner the JID of the owner of the PEP service for which the subscription is being canceled.
     */
    private void cancelSubscriptionToPEPService(JID unsubscriber, JID serviceOwner) {
        // Retrieve recipientJID's PEP service, if it exists.
<span class="nc" id="L502">        PEPService pepService = pepServiceManager.getPEPService(serviceOwner.toBareJID());</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">        if (pepService == null) {</span>
<span class="nc" id="L504">            return;</span>
        }

        // Cancel unsubscriberJID's subscription to recipientJID's PEP service, if it exists.
<span class="nc" id="L508">        CollectionNode rootNode = pepService.getRootCollectionNode();</span>
<span class="nc" id="L509">        NodeSubscription nodeSubscription = rootNode.getSubscription(unsubscriber);</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">        if (nodeSubscription != null) {</span>
<span class="nc" id="L511">            rootNode.cancelSubscription(nodeSubscription);</span>
        }
<span class="nc" id="L513">    }</span>

    /**
     * Implements UserItemsProvider, adding PEP related items to a disco#items
     * result.
     */
    @Override
    public Iterator&lt;Element&gt; getUserItems(String name, JID senderJID) {
<span class="nc" id="L521">        ArrayList&lt;Element&gt; items = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L523">        String recipientJID = XMPPServer.getInstance().createJID(name, null, true).toBareJID();</span>
<span class="nc" id="L524">        PEPService pepService = pepServiceManager.getPEPService(recipientJID);</span>

<span class="nc bnc" id="L526" title="All 2 branches missed.">        if (pepService != null) {</span>
<span class="nc" id="L527">            CollectionNode rootNode = pepService.getRootCollectionNode();</span>

<span class="nc" id="L529">            Element defaultItem = DocumentHelper.createElement(&quot;item&quot;);</span>
<span class="nc" id="L530">            defaultItem.addAttribute(&quot;jid&quot;, recipientJID);</span>

<span class="nc bnc" id="L532" title="All 2 branches missed.">            for (Node node : pepService.getNodes()) {</span>
                // Do not include the root node as an item element.
<span class="nc bnc" id="L534" title="All 2 branches missed.">                if (node == rootNode) {</span>
<span class="nc" id="L535">                    continue;</span>
                }

<span class="nc" id="L538">                AccessModel accessModel = node.getAccessModel();</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">                if (accessModel.canAccessItems(node, senderJID, new JID(recipientJID))) {</span>
<span class="nc" id="L540">                    Element item = defaultItem.createCopy();</span>
<span class="nc" id="L541">                    item.addAttribute(&quot;node&quot;, node.getNodeID());</span>
<span class="nc" id="L542">                    items.add(item);</span>
                }
<span class="nc" id="L544">            }</span>
        }

<span class="nc" id="L547">        return items.iterator();</span>
    }

    @Override
    public void subscribedToPresence(JID subscriberJID, JID authorizerJID) {
<span class="nc" id="L552">        final PEPService pepService = pepServiceManager.getPEPService(authorizerJID.toBareJID());</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">        if (pepService != null) {</span>
<span class="nc" id="L554">            createSubscriptionToPEPService(pepService, subscriberJID, authorizerJID);</span>

            // Delete any leaf node subscriptions the subscriber may have already
            // had (since a subscription to the PEP service, and thus its leaf PEP
            // nodes, would be duplicating publish notifications from previous leaf
            // node subscriptions).
<span class="nc" id="L560">            CollectionNode rootNode = pepService.getRootCollectionNode();</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">            for (Node node : pepService.getNodes()) {</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">                if (rootNode.isChildNode(node)) {</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">                    for (NodeSubscription subscription : node.getSubscriptions(subscriberJID)) {</span>
<span class="nc" id="L564">                        node.cancelSubscription(subscription);</span>
<span class="nc" id="L565">                    }</span>
                }
<span class="nc" id="L567">            }</span>

<span class="nc" id="L569">            pepService.sendLastPublishedItems(subscriberJID);</span>
        }
<span class="nc" id="L571">    }</span>

    @Override
    public void unsubscribedToPresence(JID unsubscriberJID, JID recipientJID) {
<span class="nc" id="L575">        cancelSubscriptionToPEPService(unsubscriberJID, recipientJID);</span>
<span class="nc" id="L576">    }</span>

    @Override
    public void availableSession(ClientSession session, Presence presence) {
        // Do nothing if server is not enabled
<span class="nc bnc" id="L581" title="All 2 branches missed.">        if (!isEnabled()) {</span>
<span class="nc" id="L582">            return;</span>
        }
<span class="nc" id="L584">        JID newlyAvailableJID = presence.getFrom();</span>

<span class="nc bnc" id="L586" title="All 2 branches missed.">        if (newlyAvailableJID == null) {</span>
<span class="nc" id="L587">            return;</span>
        }
        
<span class="nc" id="L590">        final GetNotificationsOnInitialPresence task = new GetNotificationsOnInitialPresence(newlyAvailableJID);</span>
<span class="nc" id="L591">        executor.submit(task);</span>
<span class="nc" id="L592">    }</span>

    @Override
    public void contactDeleted(Roster roster, RosterItem item) {
<span class="nc" id="L596">        JID rosterOwner = XMPPServer.getInstance().createJID(roster.getUsername(), null);</span>
<span class="nc" id="L597">        JID deletedContact = item.getJid();</span>

<span class="nc" id="L599">        cancelSubscriptionToPEPService(deletedContact, rosterOwner);</span>
<span class="nc" id="L600">    }</span>

    @Override
    public void userDeleting(User user, Map&lt;String, Object&gt; params) {
<span class="nc" id="L604">        final JID bareJID = XMPPServer.getInstance().createJID(user.getUsername(), null);</span>
<span class="nc" id="L605">        final PEPService pepService = pepServiceManager.getPEPService(bareJID.toString());</span>

<span class="nc bnc" id="L607" title="All 2 branches missed.">        if (pepService == null) {</span>
<span class="nc" id="L608">            return;</span>
        }

        // Remove the user's PEP service, finally.
<span class="nc" id="L612">        pepServiceManager.remove(bareJID);</span>
<span class="nc" id="L613">    }</span>

    /**
     *  The following functions are unimplemented required interface methods.
     */
    @Override
    public void unavailableSession(ClientSession session, Presence presence) {
        // Do nothing
<span class="nc" id="L621">    }</span>

    @Override
    public void presenceChanged(ClientSession session, Presence presence) {
        // Do nothing
<span class="nc" id="L626">    }</span>

    @Override
    public boolean addingContact(Roster roster, RosterItem item, boolean persistent) {
        // Do nothing
<span class="nc" id="L631">        return true;</span>
    }

    @Override
    public void contactAdded(Roster roster, RosterItem item) {
        // Do nothing
<span class="nc" id="L637">    }</span>

    @Override
    public void contactUpdated(Roster roster, RosterItem item) {
        // Do nothing
<span class="nc" id="L642">    }</span>

    @Override
    public void rosterLoaded(Roster roster) {
        // Do nothing
<span class="nc" id="L647">    }</span>

    @Override
    public void userCreated(User user, Map&lt;String, Object&gt; params) {
        // Do nothing
<span class="nc" id="L652">    }</span>

    @Override
    public void userModified(User user, Map&lt;String, Object&gt; params) {
        // Do nothing
<span class="nc" id="L657">    }</span>

    // DiscoInfoProvider

    /*
     * With all these, there are basically two axes of binary choice.
     * Either the PEPService exists already - in which case we can defer to it,
     * or else it doesn't, in which case we should use the generic engine.
     *
     * In either case, we might be being asked for a node, or the root. If we're
     * asked for a node when the PEPService doesn't exist that's an error. Otherwise
     * if we're asked for the root we can safely defer to the generic engine.
     */

    @Override
    public Iterator&lt;Element&gt; getIdentities(String name, String node, JID senderJID) {
<span class="nc" id="L673">        String recipientJID = XMPPServer.getInstance().createJID(name, null, true).toBareJID();</span>
<span class="nc" id="L674">        PEPService pepService = pepServiceManager.getPEPService(recipientJID);</span>

<span class="nc bnc" id="L676" title="All 4 branches missed.">        if (node != null &amp;&amp; pepService != null) {</span>
<span class="nc" id="L677">            Node pubNode = pepService.getNode(node);</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">            if (pubNode == null) return null;</span>
            // Answer the identity of a given node
<span class="nc" id="L680">            Element identity = DocumentHelper.createElement(&quot;identity&quot;);</span>
<span class="nc" id="L681">            identity.addAttribute(&quot;category&quot;, &quot;pubsub&quot;);</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">            identity.addAttribute(&quot;type&quot;, pubNode.isCollectionNode() ? &quot;collection&quot; : &quot;leaf&quot;);</span>

<span class="nc" id="L684">            List&lt;Element&gt; identities = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L685">            identities.add(identity);</span>
<span class="nc" id="L686">            return identities.iterator();</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">        } else if (node != null) {</span>
<span class="nc" id="L688">            return null;</span>
        } else {
<span class="nc" id="L690">            PubSubModule pubsub = XMPPServer.getInstance().getPubSubModule();</span>
<span class="nc" id="L691">            return pubsub.getIdentities(null, null, senderJID);</span>
        }
    }

    @Override
    public Iterator&lt;String&gt; getFeatures(String name, String node, JID senderJID) {
<span class="nc bnc" id="L697" title="All 2 branches missed.">        if (node == null) {</span>
<span class="nc" id="L698">            PubSubModule pubsub = XMPPServer.getInstance().getPubSubModule();</span>
<span class="nc" id="L699">            return pubsub.getFeatures(null, null, senderJID);</span>
        } else {
<span class="nc" id="L701">            List&lt;String&gt; features = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L702">            features.add(&quot;http://jabber.org/protocol/pubsub&quot;);</span>
<span class="nc" id="L703">            return features.iterator();</span>
        }
    }

    @Override
    public DataForm getExtendedInfo(String name, String node, JID senderJID) {
<span class="nc" id="L709">        String recipientJID = XMPPServer.getInstance().createJID(name, null, true).toBareJID();</span>
<span class="nc" id="L710">        PEPService pepService = pepServiceManager.getPEPService(recipientJID);</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">        if (node != null) {</span>
            // Answer the extended info of a given node
<span class="nc" id="L713">            Node pubNode = pepService.getNode(node);</span>
            // Get the metadata data form
<span class="nc" id="L715">            return pubNode.getMetadataForm();</span>
        }
<span class="nc" id="L717">        return null;</span>
    }

    @Override
    public boolean hasInfo(String name, String node, JID senderJID) {
<span class="nc bnc" id="L722" title="All 2 branches missed.">        if (node == null) return true;</span>
<span class="nc" id="L723">        String recipientJID = XMPPServer.getInstance().createJID(name, null, true).toBareJID();</span>
<span class="nc" id="L724">        PEPService pepService = pepServiceManager.getPEPService(recipientJID);</span>

<span class="nc bnc" id="L726" title="All 2 branches missed.">        return pepService.getNode(node) != null;</span>
    }

    private class GetNotificationsOnInitialPresence implements Runnable {
        
        private final JID availableSessionJID;
<span class="nc" id="L732">        public GetNotificationsOnInitialPresence(final JID availableSessionJID) {</span>
<span class="nc" id="L733">            this.availableSessionJID = availableSessionJID;</span>
<span class="nc" id="L734">        }</span>
        
        @Override
        public void run() {
            // Send the last published items for the contacts on availableSessionJID's roster.
            try {
<span class="nc" id="L740">                final XMPPServer server = XMPPServer.getInstance();</span>
<span class="nc" id="L741">                final Roster roster = server.getRosterManager().getRoster(availableSessionJID.getNode());</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">                for (final RosterItem item : roster.getRosterItems()) {</span>
<span class="nc bnc" id="L743" title="All 4 branches missed.">                    if (server.isLocal(item.getJid()) &amp;&amp; (item.getSubStatus() == RosterItem.SUB_BOTH ||</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">                            item.getSubStatus() == RosterItem.SUB_TO)) {</span>
<span class="nc" id="L745">                        PEPService pepService = pepServiceManager.getPEPService(item.getJid().toBareJID());</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">                        if (pepService != null) {</span>
<span class="nc" id="L747">                            pepService.sendLastPublishedItems(availableSessionJID);</span>
                        }
                    }
<span class="nc" id="L750">                }</span>
            }
<span class="nc" id="L752">            catch (UserNotFoundException e) {</span>
                // Do nothing
<span class="nc" id="L754">            }</span>
<span class="nc" id="L755">        }    	</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>