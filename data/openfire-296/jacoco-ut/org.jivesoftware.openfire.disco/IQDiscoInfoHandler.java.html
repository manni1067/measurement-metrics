<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>IQDiscoInfoHandler.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Core XMPP Server</a> &gt; <a href="index.source.html" class="el_package">org.jivesoftware.openfire.disco</a> &gt; <span class="el_source">IQDiscoInfoHandler.java</span></div><h1>IQDiscoInfoHandler.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2004-2008 Jive Software. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jivesoftware.openfire.disco;

import org.dom4j.DocumentHelper;
import org.dom4j.Element;
import org.dom4j.QName;
import org.jivesoftware.openfire.IQHandlerInfo;
import org.jivesoftware.openfire.SessionManager;
import org.jivesoftware.openfire.XMPPServer;
import org.jivesoftware.openfire.cluster.ClusterEventListener;
import org.jivesoftware.openfire.cluster.ClusterManager;
import org.jivesoftware.openfire.cluster.NodeID;
import org.jivesoftware.openfire.entitycaps.EntityCapabilitiesManager;
import org.jivesoftware.openfire.handler.IQHandler;
import org.jivesoftware.openfire.user.UserManager;
import org.jivesoftware.openfire.user.UserNotFoundException;
import org.jivesoftware.util.JiveGlobals;
import org.jivesoftware.util.cache.Cache;
import org.jivesoftware.util.cache.CacheFactory;
import org.xmpp.forms.DataForm;
import org.xmpp.forms.FormField;
import org.xmpp.packet.IQ;
import org.xmpp.packet.JID;
import org.xmpp.packet.PacketError;
import org.xmpp.resultsetmanagement.ResultSet;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.locks.Lock;

/**
 * IQDiscoInfoHandler is responsible for handling disco#info requests. This class holds a map with
 * the main entities and the associated DiscoInfoProvider. We are considering the host of the
 * recipient JIDs as main entities. It's the DiscoInfoProvider responsibility to provide information
 * about the JID's name together with any possible requested node.
 * &lt;p&gt;
 * For example, let's have in the entities map the following entries: &quot;localhost&quot; and
 * &quot;conference.localhost&quot;. Associated with each entry we have different DiscoInfoProviders. Now we
 * receive a disco#info request for the following JID: &quot;room@conference.localhost&quot; which is a disco
 * request for a MUC room. So IQDiscoInfoHandler will look for the DiscoInfoProvider associated
 * with the JID's host which in this case is &quot;conference.localhost&quot;. Once we have located the
 * provider we will delegate to the provider the responsibility to provide the info specific to
 * the JID's name which in this case is &quot;room&quot;. Among the information that a room could provide we
 * could find its identity and the features it supports (e.g. 'muc_passwordprotected',
 * 'muc_unmoderated', etc.). Finally, after we have collected all the information provided by the
 * provider we will add it to the reply. On the other hand, if no provider was found or the provider
 * has no information for the requested name/node then a not-found error will be returned.&lt;/p&gt;
 *
 * @author Gaston Dombiak
 */
public class IQDiscoInfoHandler extends IQHandler implements ClusterEventListener {

    public static final String NAMESPACE_DISCO_INFO = &quot;http://jabber.org/protocol/disco#info&quot;;
<span class="nc" id="L70">    private Map&lt;String, DiscoInfoProvider&gt; entities = new HashMap&lt;&gt;();</span>
<span class="nc" id="L71">    private Set&lt;String&gt; localServerFeatures = new CopyOnWriteArraySet&lt;&gt;();</span>
    private Cache&lt;String, HashSet&lt;NodeID&gt;&gt; serverFeatures;
<span class="nc" id="L73">    private List&lt;ServerIdentitiesProvider&gt; serverIdentityProviders = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L74">    private Map&lt;String, DiscoInfoProvider&gt; serverNodeProviders = new ConcurrentHashMap&lt;&gt;();</span>
    private IQHandlerInfo info;

<span class="nc" id="L77">    private List&lt;UserIdentitiesProvider&gt; anonymousUserIdentityProviders = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L78">    private List&lt;UserIdentitiesProvider&gt; registeredUserIdentityProviders = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L79">    private List&lt;UserFeaturesProvider&gt; anonymousUserFeatureProviders = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L80">    private List&lt;UserFeaturesProvider&gt; registeredUserFeatureProviders = new ArrayList&lt;&gt;();</span>

    public IQDiscoInfoHandler() {
<span class="nc" id="L83">        super(&quot;XMPP Disco Info Handler&quot;);</span>
<span class="nc" id="L84">        info = new IQHandlerInfo(&quot;query&quot;, NAMESPACE_DISCO_INFO);</span>

<span class="nc" id="L86">        anonymousUserIdentityProviders.add( new UserIdentitiesProvider()</span>
<span class="nc" id="L87">        {</span>
            @Override
            public Iterator&lt;Element&gt; getIdentities()
            {
<span class="nc" id="L91">                final Element userIdentity = DocumentHelper.createElement( &quot;identity&quot; );</span>
<span class="nc" id="L92">                userIdentity.addAttribute( &quot;category&quot;, &quot;account&quot; );</span>
<span class="nc" id="L93">                userIdentity.addAttribute( &quot;type&quot;, &quot;anonymous&quot; );</span>

<span class="nc" id="L95">                return Collections.singleton( userIdentity ).iterator();</span>
            }
        } );

<span class="nc" id="L99">        registeredUserIdentityProviders.add( new UserIdentitiesProvider()</span>
<span class="nc" id="L100">        {</span>
            @Override
            public Iterator&lt;Element&gt; getIdentities()
            {
<span class="nc" id="L104">                final Element userIdentity = DocumentHelper.createElement( &quot;identity&quot; );</span>
<span class="nc" id="L105">                userIdentity.addAttribute( &quot;category&quot;, &quot;account&quot; );</span>
<span class="nc" id="L106">                userIdentity.addAttribute( &quot;type&quot;, &quot;registered&quot; );</span>

<span class="nc" id="L108">                return Collections.singleton( userIdentity ).iterator();</span>
            }
        } );
<span class="nc" id="L111">    }</span>

    @Override
    public IQHandlerInfo getInfo() {
<span class="nc" id="L115">        return info;</span>
    }

    @Override
    public IQ handleIQ(IQ packet) {
        // Create a copy of the sent pack that will be used as the reply
        // we only need to add the requested info to the reply if any otherwise add 
        // a not found error
<span class="nc" id="L123">        IQ reply = IQ.createResultIQ(packet);</span>

        // Look for a DiscoInfoProvider associated with the requested entity.
        // We consider the host of the recipient JID of the packet as the entity. It's the 
        // DiscoInfoProvider responsibility to provide information about the JID's name together 
        // with any possible requested node.  
<span class="nc bnc" id="L129" title="All 2 branches missed.">        DiscoInfoProvider infoProvider = getProvider(packet.getTo() == null ?</span>
<span class="nc" id="L130">                XMPPServer.getInstance().getServerInfo().getXMPPDomain() : packet.getTo().getDomain());</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (infoProvider != null) {</span>
            // Get the JID's name
<span class="nc bnc" id="L133" title="All 2 branches missed.">            String name = packet.getTo() == null ? null : packet.getTo().getNode();</span>
<span class="nc bnc" id="L134" title="All 4 branches missed.">            if (name == null || name.trim().length() == 0) {</span>
<span class="nc" id="L135">                name = null;</span>
            }
            // Get the requested node
<span class="nc" id="L138">            Element iq = packet.getChildElement();</span>
<span class="nc" id="L139">            String node = iq.attributeValue(&quot;node&quot;);</span>
            //String node = metaData.getProperty(&quot;query:node&quot;);

            // Legacy implementation assumes that, when querying the server, the node is null.
            // This is not true for the XEP-0115 based requests for the server itself. As a
            // hack, the node value is considered 'null' when the request that's being handled
            // appears to be such a request.
<span class="nc bnc" id="L146" title="All 4 branches missed.">            if ( node != null &amp;&amp; node.startsWith( EntityCapabilitiesManager.OPENFIRE_IDENTIFIER_NODE + &quot;#&quot; ) ) {</span>
<span class="nc" id="L147">                node = null;</span>
            }

            // Check if we have information about the requested name and node
<span class="nc bnc" id="L151" title="All 2 branches missed.">            if (infoProvider.hasInfo(name, node, packet.getFrom())) {</span>
<span class="nc" id="L152">                reply.setChildElement(iq.createCopy());</span>
<span class="nc" id="L153">                Element queryElement = reply.getChildElement();</span>

                // Add to the reply all the identities provided by the DiscoInfoProvider
                Element identity;
<span class="nc" id="L157">                Iterator&lt;Element&gt; identities = infoProvider.getIdentities(name, node, packet.getFrom());</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">                while (identities.hasNext()) {</span>
<span class="nc" id="L159">                    identity = identities.next();</span>
<span class="nc" id="L160">                    identity.setQName(new QName(identity.getName(), queryElement.getNamespace()));</span>
<span class="nc" id="L161">                    queryElement.add((Element)identity.clone());</span>
                }

                // Add to the reply all the features provided by the DiscoInfoProvider
<span class="nc" id="L165">                Iterator&lt;String&gt; features = infoProvider.getFeatures(name, node, packet.getFrom());</span>
<span class="nc" id="L166">                boolean hasDiscoInfoFeature = false;</span>
<span class="nc" id="L167">                boolean hasDiscoItemsFeature = false;</span>
<span class="nc" id="L168">                boolean hasResultSetManagementFeature = false;</span>

<span class="nc bnc" id="L170" title="All 2 branches missed.">                while (features.hasNext()) {</span>
<span class="nc" id="L171">                    final String feature = features.next();</span>
<span class="nc" id="L172">                    queryElement.addElement(&quot;feature&quot;).addAttribute(&quot;var&quot;, feature);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">                    if (feature.equals(NAMESPACE_DISCO_INFO)) {</span>
<span class="nc" id="L174">                        hasDiscoInfoFeature = true;</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                    } else if (feature.equals(&quot;http://jabber.org/protocol/disco#items&quot;)) {</span>
<span class="nc" id="L176">                        hasDiscoItemsFeature = true;</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">                    } else if (feature.equals(ResultSet.NAMESPACE_RESULT_SET_MANAGEMENT)) {</span>
<span class="nc" id="L178">                        hasResultSetManagementFeature = true;</span>
                    }
<span class="nc" id="L180">                }</span>

<span class="nc bnc" id="L182" title="All 4 branches missed.">                if (hasDiscoItemsFeature &amp;&amp; !hasResultSetManagementFeature) {</span>
                    // IQDiscoItemsHandler provides result set management
                    // support.
<span class="nc" id="L185">                    queryElement.addElement(&quot;feature&quot;).addAttribute(&quot;var&quot;,</span>
                            ResultSet.NAMESPACE_RESULT_SET_MANAGEMENT);
                }

<span class="nc bnc" id="L189" title="All 2 branches missed.">                if (!hasDiscoInfoFeature) {</span>
                    // XEP-0030 requires that every entity that supports service
                    // discovery broadcasts the disco#info feature.
<span class="nc" id="L192">                    queryElement.addElement(&quot;feature&quot;).addAttribute(&quot;var&quot;, NAMESPACE_DISCO_INFO);</span>
                }

                // Add to the reply the extended info (XDataForm) provided by the DiscoInfoProvider
<span class="nc" id="L196">                DataForm dataForm = infoProvider.getExtendedInfo(name, node, packet.getFrom());</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">                if (dataForm != null) {</span>
<span class="nc" id="L198">                    queryElement.add(dataForm.getElement());</span>
                }
<span class="nc" id="L200">            }</span>
            else {
                // If the DiscoInfoProvider has no information for the requested name and node 
                // then answer a not found error
<span class="nc" id="L204">                reply.setChildElement(packet.getChildElement().createCopy());</span>
<span class="nc" id="L205">                reply.setError(PacketError.Condition.item_not_found);</span>
            }
<span class="nc" id="L207">        }</span>
        else {
            // If we didn't find a DiscoInfoProvider then answer a not found error
<span class="nc" id="L210">            reply.setChildElement(packet.getChildElement().createCopy());</span>
<span class="nc" id="L211">            reply.setError(PacketError.Condition.item_not_found);</span>
        }

<span class="nc" id="L214">        return reply;</span>
    }

    /**
     * Sets the DiscoInfoProvider to use when a disco#info packet is sent to the server itself
     * and the specified node. For instance, if node matches &quot;http://jabber.org/protocol/offline&quot;
     * then a special DiscoInfoProvider should be use to return information about offline messages.
     *
     * @param node the node that the provider will handle.
     * @param provider the DiscoInfoProvider that will handle disco#info packets sent with the
     *        specified node.
     */
    public void setServerNodeInfoProvider(String node, DiscoInfoProvider provider) {
<span class="nc" id="L227">        serverNodeProviders.put(node, provider);</span>
<span class="nc" id="L228">    }</span>

    /**
     * Removes the DiscoInfoProvider to use when a disco#info packet is sent to the server itself
     * and the specified node.
     *
     * @param node the node that the provider was handling.
     */
    public void removeServerNodeInfoProvider(String node) {
<span class="nc" id="L237">        serverNodeProviders.remove(node);</span>
<span class="nc" id="L238">    }</span>

    /**
     * Returns the DiscoInfoProvider responsible for providing information about a given entity or
     * null if none was found.
     *
     * @param name the name of the identity.
     * @return the DiscoInfoProvider responsible for providing information about a given entity or
     *         null if none was found.
     */
    private DiscoInfoProvider getProvider(String name) {
<span class="nc" id="L249">        return entities.get(name);</span>
    }

    /**
     * Sets that a given DiscoInfoProvider will provide information about a given entity. This
     * message must be used when new modules (e.g. MUC) are implemented and need to provide
     * information about them.
     *
     * @param name     the name of the entity.
     * @param provider the DiscoInfoProvider that will provide the entity's information.
     */
    protected void setProvider(String name, DiscoInfoProvider provider) {
<span class="nc" id="L261">        entities.put(name, provider);</span>
<span class="nc" id="L262">    }</span>

    /**
     * Removes the DiscoInfoProvider related to a given entity.
     *
     * @param name the name of the entity.
     */
    protected void removeProvider(String name) {
<span class="nc" id="L270">        entities.remove(name);</span>
<span class="nc" id="L271">    }</span>

    /**
     * Adds the features provided by the new service that implements the ServerFeaturesProvider
     * interface. This information will be used whenever a disco for information is made against
     * the server (i.e. the packet's target is the server).
     * Example of features are: jabber:iq:agents, jabber:iq:time, etc.
     *
     * @param provider the ServerFeaturesProvider that provides new server features.
     */
    public void addServerFeaturesProvider(ServerFeaturesProvider provider) {
<span class="nc bnc" id="L282" title="All 2 branches missed.">        for (Iterator&lt;String&gt; it = provider.getFeatures(); it.hasNext();) {</span>
<span class="nc" id="L283">            addServerFeature(it.next());</span>
        }
<span class="nc" id="L285">    }</span>

    /**
     * Adds the &quot;discoverable&quot; identities provided by the provider whenever a disco for info is made against the server.
     *
     * @param provider The provider of identities.
     */
    public void addServerIdentitiesProvider(ServerIdentitiesProvider provider) {
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if ( provider == null )</span>
        {
<span class="nc" id="L295">            throw new NullPointerException( &quot;Argument 'provider' cannot be null.&quot; );</span>
        }
<span class="nc" id="L297">        serverIdentityProviders.add( provider );</span>
<span class="nc" id="L298">    }</span>

    /**
     * Removes this provider of identities.
     *
     * @param provider The provider of identities.
     */
    public void removeServerIdentitiesProvider(ServerIdentitiesProvider provider) {
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if ( provider == null )</span>
        {
<span class="nc" id="L308">            throw new NullPointerException( &quot;Argument 'provider' cannot be null.&quot; );</span>
        }
<span class="nc" id="L310">        serverIdentityProviders.remove( provider );</span>
<span class="nc" id="L311">    }</span>

    /**
     * Adds the &quot;discoverable&quot; user identities provided by the provider whenever a disco for info is made against users
     * of the server.
     *
     * @param provider The provider of user identities.
     */
    public void addUserIdentitiesProvider(UserIdentitiesProvider provider) {
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if ( provider == null )</span>
        {
<span class="nc" id="L322">            throw new NullPointerException( &quot;Argument 'provider' cannot be null.&quot; );</span>
        }
<span class="nc" id="L324">        registeredUserIdentityProviders.add( provider );</span>
<span class="nc" id="L325">    }</span>

    /**
     * Removes this provider of user identities.
     *
     * @param provider The provider of identities.
     */
    public void removeUserIdentitiesProvider(UserIdentitiesProvider provider) {
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if ( provider == null )</span>
        {
<span class="nc" id="L335">            throw new NullPointerException( &quot;Argument 'provider' cannot be null.&quot; );</span>
        }
<span class="nc" id="L337">        registeredUserIdentityProviders.remove( provider );</span>
<span class="nc" id="L338">    }</span>

    /**
     * Adds the &quot;discoverable&quot; user features provided by the provider whenever a disco for info is made against users
     * of the server.
     *
     * @param provider The provider of user features.
     */
    public void addUserFeaturesProvider(UserFeaturesProvider provider) {
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if ( provider == null )</span>
        {
<span class="nc" id="L349">            throw new NullPointerException( &quot;Argument 'provider' cannot be null.&quot; );</span>
        }
<span class="nc" id="L351">        registeredUserFeatureProviders.add( provider );</span>
<span class="nc" id="L352">    }</span>

    /**
     * Removes this provider of user features.
     *
     * @param provider The provider of features.
     */
    public void removeUserFeaturesProvider(UserFeaturesProvider provider) {
<span class="nc bnc" id="L360" title="All 2 branches missed.">        if ( provider == null )</span>
        {
<span class="nc" id="L362">            throw new NullPointerException( &quot;Argument 'provider' cannot be null.&quot; );</span>
        }
<span class="nc" id="L364">        registeredUserFeatureProviders.remove( provider );</span>
<span class="nc" id="L365">    }</span>

    /**
     * Adds one specific feature to the information returned whenever a disco for information is
     * made against the server.
     *
     * @param namespace the namespace identifying the new server feature.
     */
    public void addServerFeature(String namespace) {
<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (localServerFeatures.add(namespace)) {</span>
<span class="nc" id="L375">            Lock lock = CacheFactory.getLock(namespace, serverFeatures);</span>
            try {
<span class="nc" id="L377">                lock.lock();</span>
<span class="nc" id="L378">                HashSet&lt;NodeID&gt; nodeIDs = serverFeatures.get(namespace);</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">                if (nodeIDs == null) {</span>
<span class="nc" id="L380">                    nodeIDs = new HashSet&lt;&gt;();</span>
                }
<span class="nc" id="L382">                nodeIDs.add(XMPPServer.getInstance().getNodeID());</span>
<span class="nc" id="L383">                serverFeatures.put(namespace, nodeIDs);</span>
            }
            finally {
<span class="nc" id="L386">                lock.unlock();</span>
<span class="nc" id="L387">            }</span>
        }
<span class="nc" id="L389">    }</span>

    /**
     * Removes a feature from the information returned whenever a disco for information is
     * made against the server.
     *
     * @param namespace the namespace of the feature to be removed.
     */
    public void removeServerFeature(String namespace) {
<span class="nc bnc" id="L398" title="All 2 branches missed.">        if (localServerFeatures.remove(namespace)) {</span>
<span class="nc" id="L399">            Lock lock = CacheFactory.getLock(namespace, serverFeatures);</span>
            try {
<span class="nc" id="L401">                lock.lock();</span>
<span class="nc" id="L402">                HashSet&lt;NodeID&gt; nodeIDs = serverFeatures.get(namespace);</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">                if (nodeIDs != null) {</span>
<span class="nc" id="L404">                    nodeIDs.remove(XMPPServer.getInstance().getNodeID());</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">                    if (nodeIDs.isEmpty()) {</span>
<span class="nc" id="L406">                        serverFeatures.remove(namespace);</span>
                    }
                    else {
<span class="nc" id="L409">                        serverFeatures.put(namespace, nodeIDs);</span>
                    }
                }
            }
            finally {
<span class="nc" id="L414">                lock.unlock();</span>
<span class="nc" id="L415">            }</span>
        }
<span class="nc" id="L417">    }</span>

    @Override
    public void initialize(XMPPServer server) {
<span class="nc" id="L421">        super.initialize(server);</span>
<span class="nc" id="L422">        serverFeatures = CacheFactory.createCache(&quot;Disco Server Features&quot;);</span>
<span class="nc" id="L423">        addServerFeature(NAMESPACE_DISCO_INFO);</span>
<span class="nc" id="L424">        setProvider(server.getServerInfo().getXMPPDomain(), getServerInfoProvider());</span>
        // Listen to cluster events
<span class="nc" id="L426">        ClusterManager.addListener(this);</span>
<span class="nc" id="L427">    }</span>

    @Override
    public void joinedCluster() {
<span class="nc" id="L431">        restoreCacheContent();</span>
<span class="nc" id="L432">    }</span>

    @Override
    public void joinedCluster(byte[] nodeID) {
        // Do nothing
<span class="nc" id="L437">    }</span>

    @Override
    public void leftCluster() {
<span class="nc bnc" id="L441" title="All 2 branches missed.">        if (!XMPPServer.getInstance().isShuttingDown()) {</span>
<span class="nc" id="L442">            restoreCacheContent();</span>
        }
<span class="nc" id="L444">    }</span>

    @Override
    public void leftCluster(byte[] nodeID) {
<span class="nc bnc" id="L448" title="All 2 branches missed.">        if (ClusterManager.isSeniorClusterMember()) {</span>
<span class="nc" id="L449">            NodeID leftNode = NodeID.getInstance(nodeID);</span>
            // Remove server features added by node that is gone
<span class="nc bnc" id="L451" title="All 2 branches missed.">            for (Map.Entry&lt;String, HashSet&lt;NodeID&gt;&gt; entry : serverFeatures.entrySet()) {</span>
<span class="nc" id="L452">                String namespace = entry.getKey();</span>
<span class="nc" id="L453">                Lock lock = CacheFactory.getLock(namespace, serverFeatures);</span>
                try {
<span class="nc" id="L455">                    lock.lock();</span>
<span class="nc" id="L456">                    HashSet&lt;NodeID&gt; nodeIDs = entry.getValue();</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">                    if (nodeIDs.remove(leftNode)) {</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">                        if (nodeIDs.isEmpty()) {</span>
<span class="nc" id="L459">                            serverFeatures.remove(namespace);</span>
                        }
                        else {
<span class="nc" id="L462">                            serverFeatures.put(namespace, nodeIDs);</span>
                        }
                    }
                }
                finally {
<span class="nc" id="L467">                    lock.unlock();</span>
<span class="nc" id="L468">                }</span>
<span class="nc" id="L469">            }</span>
        }
<span class="nc" id="L471">    }</span>

    @Override
    public void markedAsSeniorClusterMember() {
        // Do nothing
<span class="nc" id="L476">    }</span>

    private void restoreCacheContent() {
<span class="nc bnc" id="L479" title="All 2 branches missed.">        for (String feature : localServerFeatures) {</span>
<span class="nc" id="L480">            Lock lock = CacheFactory.getLock(feature, serverFeatures);</span>
            try {
<span class="nc" id="L482">                lock.lock();</span>
<span class="nc" id="L483">                HashSet&lt;NodeID&gt; nodeIDs = serverFeatures.get(feature);</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">                if (nodeIDs == null) {</span>
<span class="nc" id="L485">                    nodeIDs = new HashSet&lt;&gt;();</span>
                }
<span class="nc" id="L487">                nodeIDs.add(XMPPServer.getInstance().getNodeID());</span>
<span class="nc" id="L488">                serverFeatures.put(feature, nodeIDs);</span>
            }
            finally {
<span class="nc" id="L491">                lock.unlock();</span>
<span class="nc" id="L492">            }</span>
<span class="nc" id="L493">        }</span>
<span class="nc" id="L494">    }</span>

    /**
     * Returns the DiscoInfoProvider responsible for providing information at the server level. This
     * means that this DiscoInfoProvider will provide information whenever a disco request whose
     * recipient JID is the server (e.g. localhost) is made.
     *
     * @return the DiscoInfoProvider responsible for providing information at the server level.
     */
    private DiscoInfoProvider getServerInfoProvider() {
<span class="nc" id="L504">        return new DiscoInfoProvider() {</span>

            @Override
            public Iterator&lt;Element&gt; getIdentities(String name, String node, JID senderJID) {
<span class="nc bnc" id="L508" title="All 4 branches missed.">                if (node != null &amp;&amp; serverNodeProviders.get(node) != null) {</span>
                    // Redirect the request to the disco info provider of the specified node
<span class="nc" id="L510">                    return serverNodeProviders.get(node).getIdentities(name, node, senderJID);</span>
                }
<span class="nc bnc" id="L512" title="All 4 branches missed.">                if (name == null || name.equals(XMPPServer.getInstance().getServerInfo().getXMPPDomain())) {</span>
                    // Answer identity of the server itself.
<span class="nc" id="L514">                    final ArrayList&lt;Element&gt; identities = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L515">                    final Element identity = DocumentHelper.createElement(&quot;identity&quot;);</span>
<span class="nc" id="L516">                    identity.addAttribute(&quot;category&quot;, &quot;server&quot;);</span>
<span class="nc" id="L517">                    identity.addAttribute(&quot;name&quot;, JiveGlobals.getProperty(&quot;xmpp.server.name&quot;, &quot;Openfire Server&quot;));</span>
<span class="nc" id="L518">                    identity.addAttribute(&quot;type&quot;, &quot;im&quot;);</span>
<span class="nc" id="L519">                    identities.add(identity);</span>

                    // Include identities from modules that implement ServerIdentitiesProvider
<span class="nc bnc" id="L522" title="All 2 branches missed.">                    for (ServerIdentitiesProvider provider : serverIdentityProviders )</span>
                    {
<span class="nc" id="L524">                        final Iterator&lt;Element&gt; iterator = provider.getIdentities();</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">                        while ( iterator.hasNext() )</span>
                        {
<span class="nc" id="L527">                            identities.add( iterator.next() );</span>
                        }
<span class="nc" id="L529">                    }</span>
<span class="nc" id="L530">                    return identities.iterator();</span>
                }
<span class="nc bnc" id="L532" title="All 2 branches missed.">                else if (node != null) {</span>
<span class="nc" id="L533">                    return XMPPServer.getInstance().getIQPEPHandler().getIdentities(name, node, senderJID);</span>
                }
                else {
                    // Answer with identities of users of the server.
                    final Collection&lt;UserIdentitiesProvider&gt; providers;
<span class="nc bnc" id="L538" title="All 2 branches missed.">                    if (SessionManager.getInstance().isAnonymousRoute(name))</span>
                    {
                        // Answer identity of an anonymous user.
<span class="nc" id="L541">                        providers = anonymousUserIdentityProviders;</span>
                    }
                    else
                    {
                        // Answer identity of a registered user.
                        // Note: We know that this user exists because #hasInfo returned true
<span class="nc" id="L547">                        providers = registeredUserIdentityProviders;</span>
                    }

<span class="nc" id="L550">                    final Set&lt;Element&gt; result = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">                    for ( final UserIdentitiesProvider provider : providers )</span>
                    {
<span class="nc" id="L553">                        final Iterator&lt;Element&gt; identities = provider.getIdentities();</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">                        while ( identities.hasNext() )</span>
                        {
<span class="nc" id="L556">                            result.add( identities.next() );</span>
                        }
<span class="nc" id="L558">                    }</span>
<span class="nc" id="L559">                    return result.iterator();</span>
                }
            }

            @Override
            public Iterator&lt;String&gt; getFeatures(String name, String node, JID senderJID) {
<span class="nc bnc" id="L565" title="All 4 branches missed.">                if (node != null &amp;&amp; serverNodeProviders.get(node) != null) {</span>
                    // Redirect the request to the disco info provider of the specified node
<span class="nc" id="L567">                    return serverNodeProviders.get(node).getFeatures(name, node, senderJID);</span>
                }
<span class="nc bnc" id="L569" title="All 4 branches missed.">                if (name == null || name.equals(XMPPServer.getInstance().getServerInfo().getXMPPDomain())) {</span>
                    // Answer features of the server itself.
<span class="nc" id="L571">                    return new HashSet&lt;&gt;(serverFeatures.keySet()).iterator();</span>
                }
<span class="nc bnc" id="L573" title="All 2 branches missed.">                else if (node != null) {</span>
<span class="nc" id="L574">                    return XMPPServer.getInstance().getIQPEPHandler().getFeatures(name, node, senderJID);</span>
                }
                else {
                    // Answer with features of users of the server.
                    final Collection&lt;UserFeaturesProvider&gt; providers;
<span class="nc bnc" id="L579" title="All 2 branches missed.">                    if (SessionManager.getInstance().isAnonymousRoute(name))</span>
                    {
                        // Answer features of an anonymous user.
<span class="nc" id="L582">                        providers = anonymousUserFeatureProviders;</span>
                    }
                    else
                    {
                        // Answer features of a registered user.
                        // Note: We know that this user exists because #hasInfo returned true
<span class="nc" id="L588">                        providers = registeredUserFeatureProviders;</span>
                    }
<span class="nc" id="L590">                    final Set&lt;String&gt; result = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">                    for ( final UserFeaturesProvider provider : providers )</span>
                    {
<span class="nc" id="L593">                        final Iterator&lt;String&gt; features = provider.getFeatures();</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">                        while ( features.hasNext() )</span>
                        {
<span class="nc" id="L596">                            result.add( features.next() );</span>
                        }
<span class="nc" id="L598">                    }</span>
<span class="nc" id="L599">                    return result.iterator();</span>
                }
            }

            @Override
            public boolean hasInfo(String name, String node, JID senderJID) {
<span class="nc bnc" id="L605" title="All 2 branches missed.">                if (node != null) {</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">                    if (serverNodeProviders.get(node) != null) {</span>
                        // Redirect the request to the disco info provider of the specified node
<span class="nc" id="L608">                        return serverNodeProviders.get(node).hasInfo(name, node, senderJID);</span>
                    }
<span class="nc bnc" id="L610" title="All 2 branches missed.">                    if (name != null) {</span>
<span class="nc" id="L611">                        return XMPPServer.getInstance().getIQPEPHandler().hasInfo(name, node, senderJID);</span>
                    }
                    // Unknown node
<span class="nc" id="L614">                    return false;</span>
                }
                try {
                    // True if it is an info request of the server, a registered user or an
                    // anonymous user. We now support disco of user's bare JIDs
<span class="nc bnc" id="L619" title="All 2 branches missed.">                    if (name == null) return true;</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">                    if (UserManager.getInstance().getUser(name) != null ||</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">                            SessionManager.getInstance().isAnonymousRoute(name)) {</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">                        if (node == null) {</span>
<span class="nc" id="L623">                            return true;</span>
                        }
<span class="nc" id="L625">                        return XMPPServer.getInstance().getIQPEPHandler().hasInfo(name, node, senderJID);</span>
                    }
<span class="nc" id="L627">                    return false;</span>
                }
<span class="nc" id="L629">                catch (UserNotFoundException e) {</span>
<span class="nc" id="L630">                    return false;</span>
                }
            }

            @Override
            public DataForm getExtendedInfo(String name, String node, JID senderJID) {
<span class="nc bnc" id="L636" title="All 4 branches missed.">                if (node != null &amp;&amp; serverNodeProviders.get(node) != null) {</span>
                    // Redirect the request to the disco info provider of the specified node
<span class="nc" id="L638">                    return serverNodeProviders.get(node).getExtendedInfo(name, node, senderJID);</span>
                }
<span class="nc bnc" id="L640" title="All 4 branches missed.">                if (name == null || name.equals(XMPPServer.getInstance().getServerInfo().getXMPPDomain())) {</span>
                    // Answer extended info of the server itself.

                    // XEP-0157 Contact addresses for XMPP Services
<span class="nc bnc" id="L644" title="All 2 branches missed.">                    if ( !JiveGlobals.getBooleanProperty( &quot;admin.disable-exposure&quot; ) )</span>
                    {
<span class="nc" id="L646">                        final Collection&lt;JID&gt; admins = XMPPServer.getInstance().getAdmins();</span>
<span class="nc bnc" id="L647" title="All 4 branches missed.">                        if ( admins == null || admins.isEmpty() )</span>
                        {
<span class="nc" id="L649">                            return null;</span>
                        }

<span class="nc" id="L652">                        final DataForm dataForm = new DataForm(DataForm.Type.result);</span>

<span class="nc" id="L654">                        final FormField fieldType = dataForm.addField();</span>
<span class="nc" id="L655">                        fieldType.setVariable(&quot;FORM_TYPE&quot;);</span>
<span class="nc" id="L656">                        fieldType.setType(FormField.Type.hidden);</span>
<span class="nc" id="L657">                        fieldType.addValue(&quot;http://jabber.org/network/serverinfo&quot;);</span>

<span class="nc" id="L659">                        final FormField fieldAdminAddresses = dataForm.addField();</span>
<span class="nc" id="L660">                        fieldAdminAddresses.setVariable(&quot;admin-addresses&quot;);</span>

<span class="nc" id="L662">                        final UserManager userManager = UserManager.getInstance();</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">                        for ( final JID admin : admins )</span>
                        {
<span class="nc" id="L665">                            fieldAdminAddresses.addValue( &quot;xmpp:&quot; + admin.asBareJID() );</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">                            if ( admin.getDomain().equals( XMPPServer.getInstance().getServerInfo().getXMPPDomain() ) )</span>
                            try
                            {
<span class="nc" id="L669">                                final String email = userManager.getUser( admin.getNode() ).getEmail();</span>
<span class="nc bnc" id="L670" title="All 4 branches missed.">                                if ( email != null &amp;&amp; !email.trim().isEmpty() )</span>
                                {
<span class="nc" id="L672">                                    fieldAdminAddresses.addValue( &quot;mailto:&quot; + email );</span>
                                }
                            }
<span class="nc" id="L675">                            catch (Exception e)</span>
                            {
<span class="nc" id="L677">                                continue;</span>
<span class="nc" id="L678">                            }</span>
<span class="nc" id="L679">                        }</span>

<span class="nc" id="L681">                        return dataForm;</span>
                    }
                }
<span class="nc bnc" id="L684" title="All 4 branches missed.">                if (node != null &amp;&amp; name != null) {</span>
<span class="nc" id="L685">                    return XMPPServer.getInstance().getIQPEPHandler().getExtendedInfo(name, node, senderJID);</span>
                }
<span class="nc" id="L687">                return null;</span>
            }
        };
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>